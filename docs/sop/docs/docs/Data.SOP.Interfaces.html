<!DOCTYPE html><html lang="en">

<head>
  <meta charset="utf-8">
  <title>Data.SOP.Interfaces</title>
  <link rel="stylesheet" type="text/css" id="preferredStyle" href="../default.css">
  <script>
    /* Updates the stylesheet to use the preferred one.
       Note that we set the link to root ++ sourceLoc because the config
       is shared across the whole website, so the root may differ from
       page to page.
    */
    function setStyleSource (sourceLoc) {
      document.getElementById("preferredStyle").href = "../" + sourceLoc + ".css";
      document.getElementById("selectPreferredStyle").value = sourceLoc;
    }
    /* Initialises the preferred style sheet:
       1. if there is a stored value then use that
          otherwise select the default
       2. set both the css link href & the drop down menu selected option
    */
    function initStyleSource () {
      var preferredStyle = localStorage.getItem("stylefile");
      if (preferredStyle !== null) {
        setStyleSource(preferredStyle);
      } else {
        setStyleSource("default");
      };
    }
    function saveStyleSource (preferredStyle) {
      localStorage.stylefile = preferredStyle;
    }
    </script>
</head>

<body class="namespace">
<header>
  <strong>Idris2Doc</strong> : Data.SOP.Interfaces
  <nav><a href="../index.html">Index</a>

  <select id="selectPreferredStyle">
    <option value="default">Default</option>
<option value="alternative">Alternative</option>
<option value="blackandwhite">Black & White</option>

  </select>
  </nav>

  <script>
  /* We start by initialising the style source */
  initStyleSource();

  /* This listens for changes on the drop down menu and updates the
     css used for the current page when a selection is made.
  */
  document.getElementById("selectPreferredStyle").addEventListener("change", function(){
    var selected = this.options[this.selectedIndex].value; /* the option chosen */
    setStyleSource (selected);
    saveStyleSource (selected);
  });
</script>

</header>
<div class="container"><div id="module-header"><h1>Data.SOP.Interfaces</h1><span style="float:right">(<a href="Data.SOP.Interfaces.src.html">source</a>)</span><pre>This module provides interfaces similar to `Applicative`
and `Traversable` for heterogeneous container types.
We distinguish between two types of containers: Product
types hold all their values at once, while sum types
represent a choice: A generalization of `Either`.

The core data types in this library are indexed over a
container (typically a List or List of Lists) of values
of type `k` plus a type-level function `f` of type `k -&gt; Type`.
The values of the container index together with `f` determine
the types of values at each position in the
heterogeneous product or sum, while the shape of container
indices mirror the shape of the corresponding product types.

The interfaces in this module allow us to create
hetereogeneous containers from sufficiently general functions
(`HPure`), use unary functions to change the context of
values in a heterogeneous container (`HFunctor`),
collapse heterogeneous containers into a single value (`HFoldable`)
and run an effectful computation over all values in
a heterogeneous container (`HSequence`).

In addition, `HFunctor` can be generalized to arbitrary
n-ary functions (`HAp`). However, this case is special in that only
the last argument of such a function can be a sum type
while all other arguments have to be product types.
This makes sense, since when combining values of two sum types,
we typically cannot guarantee that the values point at
same choice and are therefore compatible.

Implementation notes:

For many of the functions in this module, there is a constrained
version taking an implicit heterogeneous product holding
the desired implementations. Since Idris2 uses the same
mechanism for resolving interface constraints and auto implicits,
we do not need an additional structure or interface
for these constraints.
The disadvantage of this is, that we more often have to explicitly
pattern match on these constraint products in order for Idris2
to know where to look for implementations.
</pre></div><code></code><h2>Definitions</h2><dl class="decls"><dt id="Data.SOP.Interfaces.HCont"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HCont"><span class="name function">HCont</span></a>&ensp;:&ensp;<span class="name type">Type</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd><pre>  A heterogeneous container indexed over a container type `l`<br>  holding values of type `k`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.SOP.Interfaces.HPure"><code><span class="keyword">interface</span>&ensp;<a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HPure"><span class="name type">HPure</span></a>&ensp;:&ensp;(<span class="boundvar">k</span>&ensp;:&ensp;<span class="name type">Type</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">l</span>&ensp;:&ensp;<span class="name type">Type</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HCont"><span class="name function">HCont</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd><pre>  This interface allows a heterogenous product to be filled<br>  with values, given a function which produce values of<br>  every possible type required.<br>  <br>  @ k kind of Types in a heterogeneous container&apos;s  type level code<br>  <br>  @ l kind of container used to describe a heterogeneous containr&apos;s type<br>      level code<br>  <br>  @ p the heterogeneous sum or product</pre><br>  <b>Parameters</b>:&ensp;k,&ensp;l,&ensp;p<br><b>Methods</b>:<br><dl class="decls">  <dt id="Data.SOP.Interfaces.hpure"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.hpure"><span class="name function">hpure</span></a>&ensp;:&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">ks</span></code></dt><dd><pre>  Creates a heterogeneous product by using the given functio<br>  to produce values.<br>  <br>  ```idris example<br>  Person : (f : Type -&gt; Type) -&gt; Type<br>  Person f = NP f [String,Int]<br>  <br>  emptyPerson : Person Maybe<br>  emptyPerson = hpure Nothing<br>  ```</pre></dd></dl><br><b>Implementations</b>:<br><dl class="decls">  <dt id="$resolved5964"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HPure"><span class="name type">HPure</span></a>&ensp;<span class="boundvar">k</span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">k</span>)&ensp;(<a class="type" href="Data.SOP.NP.html#Data.SOP.NP.NP_"><span class="name type">NP_</span></a>&ensp;<span class="boundvar">k</span>)</code></dt>  <dt id="$resolved5762"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HPure"><span class="name type">HPure</span></a>&ensp;<span class="boundvar">k</span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">k</span>))&ensp;(<a class="type" href="Data.SOP.POP.html#Data.SOP.POP.POP_"><span class="name type">POP_</span></a>&ensp;<span class="boundvar">k</span>)</code></dt></dl></dd><dt id="Data.SOP.Interfaces.hpure"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.hpure"><span class="name function">hpure</span></a>&ensp;:&ensp;<a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HPure"><span class="name type">HPure</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">ks</span></code></dt><dd><pre>  Creates a heterogeneous product by using the given functio<br>  to produce values.<br>  <br>  ```idris example<br>  Person : (f : Type -&gt; Type) -&gt; Type<br>  Person f = NP f [String,Int]<br>  <br>  emptyPerson : Person Maybe<br>  emptyPerson = hpure Nothing<br>  ```</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.SOP.Interfaces.hempty"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.hempty"><span class="name function">hempty</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Interfaces.Alternative"><span class="name type">Alternative</span></span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HPure"><span class="name type">HPure</span></a>&ensp;<span class="name type">Type</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">ks</span></code></dt><dd><pre>  Alias for `hpure empty`.<br>  <br>  ```idris example<br>  Person : (f : Type -&gt; Type) -&gt; Type<br>  Person f = NP f [String,Int]<br>  <br>  emptyPerson : Person Maybe<br>  emptyPerson = empty<br>  ```</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.SOP.Interfaces.hconst"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.hconst"><span class="name function">hconst</span></a>&ensp;:&ensp;<a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HPure"><span class="name type">HPure</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;(<a class="type" href="Data.SOP.Utils.html#Data.SOP.Utils.K"><span class="name function">K</span></a>&ensp;<span class="boundvar">a</span>)&ensp;<span class="boundvar">ks</span></code></dt><dd><pre>  Fills a heterogeneous structure with a constant value<br>  in the (K a) functor.<br>  <br>  ```idris example<br>  Person : (f : Type -&gt; Type) -&gt; Type<br>  Person f = NP f [String,Int]<br>  <br>  fooPerson : Person (K String)<br>  fooPerson = hconst &quot;foo&quot;<br>  ```</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.SOP.Interfaces.HFunctor"><code><span class="keyword">interface</span>&ensp;<a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HFunctor"><span class="name type">HFunctor</span></a>&ensp;:&ensp;(<span class="boundvar">k</span>&ensp;:&ensp;<span class="name type">Type</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">l</span>&ensp;:&ensp;<span class="name type">Type</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HCont"><span class="name function">HCont</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd><pre>  A higher kinded functor allowing us to change the<br>  wrapper type or context of an n-ary sum or product.<br>  <br>  @ k kind of Types in a heterogeneous container&apos;s  type level code<br>  <br>  @ l kind of container used to describe a heterogeneous containr&apos;s type<br>      level code<br>  <br>  @ p the actual heterogeneous container</pre><br>  <b>Parameters</b>:&ensp;k,&ensp;l,&ensp;p<br><b>Methods</b>:<br><dl class="decls">  <dt id="Data.SOP.Interfaces.hmap"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.hmap"><span class="name function">hmap</span></a>&ensp;:&ensp;(<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">g</span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">ks</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">g</span>&ensp;<span class="boundvar">ks</span></code></dt><dd><pre>  Maps the given function over all values in a<br>  heterogeneous container, thus changing the context<br>  of all of its values.<br>  <br>  @ fun maps values in a heterogeneous container to a new context<br>  <br>  @ p   the heterogeneous container, over which `fun` is mapped.<br>  <br>  ```idris example<br>  Person : (f : Type -&gt; Type) -&gt; Type<br>  Person f = NP f [String,Int]<br>  <br>  toPersonMaybe : Person I -&gt; Person Maybe<br>  toPersonMaybe = hmap Just<br>  ```</pre></dd></dl><br><b>Implementations</b>:<br><dl class="decls">  <dt id="$resolved6285"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HFunctor"><span class="name type">HFunctor</span></a>&ensp;<span class="boundvar">k</span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">k</span>)&ensp;(<a class="type" href="Data.SOP.NS.html#Data.SOP.NS.NS_"><span class="name type">NS_</span></a>&ensp;<span class="boundvar">k</span>)</code></dt>  <dt id="$resolved5965"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HFunctor"><span class="name type">HFunctor</span></a>&ensp;<span class="boundvar">k</span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">k</span>)&ensp;(<a class="type" href="Data.SOP.NP.html#Data.SOP.NP.NP_"><span class="name type">NP_</span></a>&ensp;<span class="boundvar">k</span>)</code></dt>  <dt id="$resolved5763"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HFunctor"><span class="name type">HFunctor</span></a>&ensp;<span class="boundvar">k</span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">k</span>))&ensp;(<a class="type" href="Data.SOP.POP.html#Data.SOP.POP.POP_"><span class="name type">POP_</span></a>&ensp;<span class="boundvar">k</span>)</code></dt>  <dt id="$resolved4934"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HFunctor"><span class="name type">HFunctor</span></a>&ensp;<span class="boundvar">k</span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">k</span>))&ensp;(<a class="type" href="Data.SOP.SOP.html#Data.SOP.SOP.SOP_"><span class="name type">SOP_</span></a>&ensp;<span class="boundvar">k</span>)</code></dt></dl></dd><dt id="Data.SOP.Interfaces.hmap"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.hmap"><span class="name function">hmap</span></a>&ensp;:&ensp;<a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HFunctor"><span class="name type">HFunctor</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">g</span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">ks</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">g</span>&ensp;<span class="boundvar">ks</span></code></dt><dd><pre>  Maps the given function over all values in a<br>  heterogeneous container, thus changing the context<br>  of all of its values.<br>  <br>  @ fun maps values in a heterogeneous container to a new context<br>  <br>  @ p   the heterogeneous container, over which `fun` is mapped.<br>  <br>  ```idris example<br>  Person : (f : Type -&gt; Type) -&gt; Type<br>  Person f = NP f [String,Int]<br>  <br>  toPersonMaybe : Person I -&gt; Person Maybe<br>  toPersonMaybe = hmap Just<br>  ```</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.SOP.Interfaces.hliftA"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.hliftA"><span class="name function">hliftA</span></a>&ensp;:&ensp;<a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HFunctor"><span class="name type">HFunctor</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">g</span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">ks</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">g</span>&ensp;<span class="boundvar">ks</span></code></dt><dd><pre>  Alias for `hmap`</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.SOP.Interfaces.hcpure"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.hcpure"><span class="name function">hcpure</span></a>&ensp;:&ensp;<a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HFunctor"><span class="name type">HFunctor</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="keyword">0</span>&ensp;<span class="boundvar">c</span>&ensp;:&ensp;(<span class="boundvar">k</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">c</span>&ensp;<span class="boundvar">ks</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">c</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">ks</span></code></dt><dd><pre>  Like `hpure` but using a constrained function for<br>  generating values. Since Idris is able to provide<br>  the required constraints<br>  already wrapped in a container of the correct<br>  shape, this is actually a derivative of `HFunctor` and not<br>  `HPure`. This has interesting consequences for sum<br>  types, for which this function is available as well.<br>  Since Idris has to choose a value of the sum<br>  itself, it will use the first possibility it<br>  can fill with the requested constraints.<br>  <br>  In the first example below, Idris generates the value<br>  `MkSOP (Z [&quot;&quot;,&quot;&quot;,[]])`. However, if the first choice does<br>  not have a Monoid instance, Idris faithfully chooses the<br>  next working possibility. In the second example,<br>  the result is `MkSOP (S (Z [[],[]]))`:<br>  <br>  ```idris example<br>  neutralFoo : SOP I [[String,String,List Int],[Int]]<br>  neutralFoo = hcpure Monoid neutral<br>  <br>  neutralBar : SOP I [[String,Int,List Int],[List String, List Int]]<br>  neutralBar = hcpure Monoid neutral<br>  ```<br>  <br>  @ c   erased function argument to specify the constraint<br>        to use<br>  <br>  @ fun generates values depending on the availability of<br>        a constraint</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.SOP.Interfaces.HAp"><code><span class="keyword">interface</span>&ensp;<a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HAp"><span class="name type">HAp</span></a>&ensp;:&ensp;(<span class="boundvar">k</span>&ensp;:&ensp;<span class="name type">Type</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">l</span>&ensp;:&ensp;<span class="name type">Type</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;((<span class="boundvar">k</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;((<span class="boundvar">k</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd><pre>  Like `Applicative`, this interface allows to<br>  map arbitrary n-ary Rank-2 functions over<br>  heterogeneous data structures of the same shape.<br>  However, in order to support products as well as sum types<br>  all arguments except the last one have to be products<br>  indexed over the same container as the last argument.<br>  <br>  @ k kind of Types in a heterogeneous container&apos;s  type level code<br>  <br>  @ l kind of container used to describe a heterogeneous containr&apos;s type<br>      level code<br>  <br>  @ q heterogeneous product related to `p`. For product types,<br>      this is the same as `p`, for sum types it is the corresponding<br>      product type.<br>  <br>  @ p the actual heterogeneous container (sum or product)</pre><br>  <b>Parameters</b>:&ensp;k,&ensp;l,&ensp;q,&ensp;p<br><b>Constraints</b>:&ensp;HFunctor&ensp;k&ensp;l&ensp;q,&ensp;HFunctor&ensp;k&ensp;l&ensp;p<br><b>Methods</b>:<br><dl class="decls">  <dt id="Data.SOP.Interfaces.hap"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.hap"><span class="name function">hap</span></a>&ensp;:&ensp;<span class="boundvar">q</span>&ensp;(\<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">g</span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="boundvar">ks</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">ks</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">g</span>&ensp;<span class="boundvar">ks</span></code></dt><dd><pre>  Higher kinded equivalent to `(&lt;*&gt;)`.<br>  <br>  Applies wrapped functions in the product<br>  container to the corresponding values in the<br>  second container.<br>  <br>  @ q product holding unary Rank-2 functions.<br>  <br>  @ p sum or product to whose values the functions in `q` should<br>      be applied<br>  <br>  ```idris example<br>  hapTest : SOP Maybe [[String,Int]] -&gt; SOP I [[String,Int]]<br>  hapTest = hap (MkPOP $ [[fromMaybe &quot;foo&quot;, const 12]])<br>  ```</pre></dd></dl><br><b>Implementations</b>:<br><dl class="decls">  <dt id="$resolved6288"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HAp"><span class="name type">HAp</span></a>&ensp;<span class="boundvar">k</span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">k</span>)&ensp;(<a class="type" href="Data.SOP.NP.html#Data.SOP.NP.NP_"><span class="name type">NP_</span></a>&ensp;<span class="boundvar">k</span>)&ensp;(<a class="type" href="Data.SOP.NS.html#Data.SOP.NS.NS_"><span class="name type">NS_</span></a>&ensp;<span class="boundvar">k</span>)</code></dt>  <dt id="$resolved5968"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HAp"><span class="name type">HAp</span></a>&ensp;<span class="boundvar">k</span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">k</span>)&ensp;(<a class="type" href="Data.SOP.NP.html#Data.SOP.NP.NP_"><span class="name type">NP_</span></a>&ensp;<span class="boundvar">k</span>)&ensp;(<a class="type" href="Data.SOP.NP.html#Data.SOP.NP.NP_"><span class="name type">NP_</span></a>&ensp;<span class="boundvar">k</span>)</code></dt>  <dt id="$resolved5766"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HAp"><span class="name type">HAp</span></a>&ensp;<span class="boundvar">k</span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">k</span>))&ensp;(<a class="type" href="Data.SOP.POP.html#Data.SOP.POP.POP_"><span class="name type">POP_</span></a>&ensp;<span class="boundvar">k</span>)&ensp;(<a class="type" href="Data.SOP.POP.html#Data.SOP.POP.POP_"><span class="name type">POP_</span></a>&ensp;<span class="boundvar">k</span>)</code></dt>  <dt id="$resolved4937"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HAp"><span class="name type">HAp</span></a>&ensp;<span class="boundvar">k</span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">k</span>))&ensp;(<a class="type" href="Data.SOP.POP.html#Data.SOP.POP.POP_"><span class="name type">POP_</span></a>&ensp;<span class="boundvar">k</span>)&ensp;(<a class="type" href="Data.SOP.SOP.html#Data.SOP.SOP.SOP_"><span class="name type">SOP_</span></a>&ensp;<span class="boundvar">k</span>)</code></dt></dl></dd><dt id="Data.SOP.Interfaces.hap"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.hap"><span class="name function">hap</span></a>&ensp;:&ensp;<a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HAp"><span class="name type">HAp</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">q</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">q</span>&ensp;(\<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">g</span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="boundvar">ks</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">ks</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">g</span>&ensp;<span class="boundvar">ks</span></code></dt><dd><pre>  Higher kinded equivalent to `(&lt;*&gt;)`.<br>  <br>  Applies wrapped functions in the product<br>  container to the corresponding values in the<br>  second container.<br>  <br>  @ q product holding unary Rank-2 functions.<br>  <br>  @ p sum or product to whose values the functions in `q` should<br>      be applied<br>  <br>  ```idris example<br>  hapTest : SOP Maybe [[String,Int]] -&gt; SOP I [[String,Int]]<br>  hapTest = hap (MkPOP $ [[fromMaybe &quot;foo&quot;, const 12]])<br>  ```</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.SOP.Interfaces.hliftA2"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.hliftA2"><span class="name function">hliftA2</span></a>&ensp;:&ensp;<a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HAp"><span class="name type">HAp</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">q</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">g</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">h</span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">q</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">ks</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">g</span>&ensp;<span class="boundvar">ks</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">h</span>&ensp;<span class="boundvar">ks</span></code></dt><dd><pre>  Higher kinded version of `liftA2`.<br>  This is a generalization of `hliftA` to binary<br>  functions.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.SOP.Interfaces.hliftA3"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.hliftA3"><span class="name function">hliftA3</span></a>&ensp;:&ensp;<a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HAp"><span class="name type">HAp</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">q</span>&ensp;<span class="boundvar">q</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HAp"><span class="name type">HAp</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">q</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">g</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">h</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">i</span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">q</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">ks</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">q</span>&ensp;<span class="boundvar">g</span>&ensp;<span class="boundvar">ks</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">h</span>&ensp;<span class="boundvar">ks</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">i</span>&ensp;<span class="boundvar">ks</span></code></dt><dd><pre>  Higher kinded version of `liftA3`.<br>  This is a generalization of `hliftA` to ternary<br>  functions.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.SOP.Interfaces.hliftA4"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.hliftA4"><span class="name function">hliftA4</span></a>&ensp;:&ensp;<a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HAp"><span class="name type">HAp</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">q</span>&ensp;<span class="boundvar">q</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HAp"><span class="name type">HAp</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">q</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">g</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">h</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">i</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">j</span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">q</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">ks</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">q</span>&ensp;<span class="boundvar">g</span>&ensp;<span class="boundvar">ks</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">q</span>&ensp;<span class="boundvar">h</span>&ensp;<span class="boundvar">ks</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">i</span>&ensp;<span class="boundvar">ks</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">j</span>&ensp;<span class="boundvar">ks</span></code></dt><dd><pre>  Higher kinded version of `liftA4`.<br>  This is a generalization of `hliftA` to quartenary<br>  functions.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.SOP.Interfaces.hcmap"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.hcmap"><span class="name function">hcmap</span></a>&ensp;:&ensp;<a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HAp"><span class="name type">HAp</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">q</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="keyword">0</span>&ensp;<span class="boundvar">c</span>&ensp;:&ensp;(<span class="boundvar">k</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">q</span>&ensp;<span class="boundvar">c</span>&ensp;<span class="boundvar">ks</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">c</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">g</span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">ks</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">g</span>&ensp;<span class="boundvar">ks</span></code></dt><dd><pre>  Like `hmap` but uses a constrained function.<br>  <br>  @ c   constraint used to convert values<br>  <br>  @ fun constrained function for converting values to<br>        a new context<br>  <br>  ```idris example<br>  showValues : NP I [String,Int] -&gt; NP (K String) [String,Int]<br>  showValues = hcmap Show show<br>  ```</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.SOP.Interfaces.hcliftA"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.hcliftA"><span class="name function">hcliftA</span></a>&ensp;:&ensp;<a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HAp"><span class="name type">HAp</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">q</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="keyword">0</span>&ensp;<span class="boundvar">c</span>&ensp;:&ensp;(<span class="boundvar">k</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">q</span>&ensp;<span class="boundvar">c</span>&ensp;<span class="boundvar">ks</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">c</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">g</span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">ks</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">g</span>&ensp;<span class="boundvar">ks</span></code></dt><dd><pre>  Alias for `hcmap`</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.SOP.Interfaces.hcliftA2"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.hcliftA2"><span class="name function">hcliftA2</span></a>&ensp;:&ensp;<a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HAp"><span class="name type">HAp</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">q</span>&ensp;<span class="boundvar">q</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HAp"><span class="name type">HAp</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">q</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="keyword">0</span>&ensp;<span class="boundvar">c</span>&ensp;:&ensp;(<span class="boundvar">k</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">q</span>&ensp;<span class="boundvar">c</span>&ensp;<span class="boundvar">ks</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">c</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">g</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">h</span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">q</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">ks</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">g</span>&ensp;<span class="boundvar">ks</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">h</span>&ensp;<span class="boundvar">ks</span></code></dt><dd><pre>  Like `hliftA2` but with a constrained function.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.SOP.Interfaces.hcliftA3"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.hcliftA3"><span class="name function">hcliftA3</span></a>&ensp;:&ensp;<a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HAp"><span class="name type">HAp</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">q</span>&ensp;<span class="boundvar">q</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HAp"><span class="name type">HAp</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">q</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">c</span>&ensp;:&ensp;(<span class="boundvar">k</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">q</span>&ensp;<span class="boundvar">c</span>&ensp;<span class="boundvar">ks</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">c</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">g</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">h</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">i</span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">q</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">ks</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">q</span>&ensp;<span class="boundvar">g</span>&ensp;<span class="boundvar">ks</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">h</span>&ensp;<span class="boundvar">ks</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">i</span>&ensp;<span class="boundvar">ks</span></code></dt><dd><pre>  Like `hliftA3` but with a constrained function.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.SOP.Interfaces.HFold"><code><span class="keyword">interface</span>&ensp;<a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HFold"><span class="name type">HFold</span></a>&ensp;:&ensp;(<span class="boundvar">k</span>&ensp;:&ensp;<span class="name type">Type</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">l</span>&ensp;:&ensp;<span class="name type">Type</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HCont"><span class="name function">HCont</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd>  <b>Parameters</b>:&ensp;k,&ensp;l,&ensp;p<br><b>Methods</b>:<br><dl class="decls">  <dt id="Data.SOP.Interfaces.hfoldl"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.hfoldl"><span class="name function">hfoldl</span></a>&ensp;:&ensp;(<span class="boundvar">acc</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">el</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">acc</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">acc</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;(<a class="type" href="Data.SOP.Utils.html#Data.SOP.Utils.K"><span class="name function">K</span></a>&ensp;<span class="boundvar">el</span>)&ensp;<span class="boundvar">ks</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">acc</span></code></dt><dd><pre>  Strict fold over a heterogeneous sum or product<br>  parameterized by the constant functor (and thus being actually<br>  a homogeneous sum or product).</pre></dd>  <dt id="Data.SOP.Interfaces.hfoldr"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.hfoldr"><span class="name function">hfoldr</span></a>&ensp;:&ensp;(<span class="boundvar">el</span>&ensp;<span class="keyword">-&gt;</span>&ensp;Lazy&ensp;<span class="boundvar">acc</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">acc</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;Lazy&ensp;<span class="boundvar">acc</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;(<a class="type" href="Data.SOP.Utils.html#Data.SOP.Utils.K"><span class="name function">K</span></a>&ensp;<span class="boundvar">el</span>)&ensp;<span class="boundvar">ks</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">acc</span></code></dt><dd><pre>  Lazy fold over a heterogeneous sum or product<br>  parameterized by the constant functor (and thus being actually<br>  a homogeneous sum or product).</pre></dd></dl><br><b>Implementations</b>:<br><dl class="decls">  <dt id="$resolved6286"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HFold"><span class="name type">HFold</span></a>&ensp;<span class="boundvar">k</span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">k</span>)&ensp;(<a class="type" href="Data.SOP.NS.html#Data.SOP.NS.NS_"><span class="name type">NS_</span></a>&ensp;<span class="boundvar">k</span>)</code></dt>  <dt id="$resolved5966"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HFold"><span class="name type">HFold</span></a>&ensp;<span class="boundvar">k</span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">k</span>)&ensp;(<a class="type" href="Data.SOP.NP.html#Data.SOP.NP.NP_"><span class="name type">NP_</span></a>&ensp;<span class="boundvar">k</span>)</code></dt>  <dt id="$resolved5764"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HFold"><span class="name type">HFold</span></a>&ensp;<span class="boundvar">k</span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">k</span>))&ensp;(<a class="type" href="Data.SOP.POP.html#Data.SOP.POP.POP_"><span class="name type">POP_</span></a>&ensp;<span class="boundvar">k</span>)</code></dt>  <dt id="$resolved4935"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HFold"><span class="name type">HFold</span></a>&ensp;<span class="boundvar">k</span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">k</span>))&ensp;(<a class="type" href="Data.SOP.SOP.html#Data.SOP.SOP.SOP_"><span class="name type">SOP_</span></a>&ensp;<span class="boundvar">k</span>)</code></dt></dl></dd><dt id="Data.SOP.Interfaces.hfoldl"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.hfoldl"><span class="name function">hfoldl</span></a>&ensp;:&ensp;<a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HFold"><span class="name type">HFold</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">acc</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">el</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">acc</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">acc</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;(<a class="type" href="Data.SOP.Utils.html#Data.SOP.Utils.K"><span class="name function">K</span></a>&ensp;<span class="boundvar">el</span>)&ensp;<span class="boundvar">ks</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">acc</span></code></dt><dd><pre>  Strict fold over a heterogeneous sum or product<br>  parameterized by the constant functor (and thus being actually<br>  a homogeneous sum or product).</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.SOP.Interfaces.hfoldr"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.hfoldr"><span class="name function">hfoldr</span></a>&ensp;:&ensp;<a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HFold"><span class="name type">HFold</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">el</span>&ensp;<span class="keyword">-&gt;</span>&ensp;Lazy&ensp;<span class="boundvar">acc</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">acc</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;Lazy&ensp;<span class="boundvar">acc</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;(<a class="type" href="Data.SOP.Utils.html#Data.SOP.Utils.K"><span class="name function">K</span></a>&ensp;<span class="boundvar">el</span>)&ensp;<span class="boundvar">ks</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">acc</span></code></dt><dd><pre>  Lazy fold over a heterogeneous sum or product<br>  parameterized by the constant functor (and thus being actually<br>  a homogeneous sum or product).</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.SOP.Interfaces.hsize"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.hsize"><span class="name function">hsize</span></a>&ensp;:&ensp;(<a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HFunctor"><span class="name type">HFunctor</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">p</span>,&ensp;<a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HFold"><span class="name type">HFold</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">p</span>)&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">ks</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span></code></dt><dd><pre>  Calculates the size of a heterogeneous container</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.SOP.Interfaces.hconcat"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.hconcat"><span class="name function">hconcat</span></a>&ensp;:&ensp;(<span class="type resolved" title="Prelude.Interfaces.Monoid"><span class="name type">Monoid</span></span>&ensp;<span class="boundvar">m</span>,&ensp;<a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HFold"><span class="name type">HFold</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">p</span>)&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;(<a class="type" href="Data.SOP.Utils.html#Data.SOP.Utils.K"><span class="name function">K</span></a>&ensp;<span class="boundvar">m</span>)&ensp;<span class="boundvar">ks</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">m</span></code></dt><dd><pre>  Alias for `hfoldl (&lt;+&gt;) neutral`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.SOP.Interfaces.hconcatMap"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.hconcatMap"><span class="name function">hconcatMap</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Interfaces.Monoid"><span class="name type">Monoid</span></span>&ensp;<span class="boundvar">m</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HFunctor"><span class="name type">HFunctor</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HFold"><span class="name type">HFold</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">m</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">ks</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">m</span></code></dt><dd><pre>  Alias for `hconcat . hmap fun`</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.SOP.Interfaces.hcconcatMap"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.hcconcatMap"><span class="name function">hcconcatMap</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Interfaces.Monoid"><span class="name type">Monoid</span></span>&ensp;<span class="boundvar">m</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HAp"><span class="name type">HAp</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">q</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HFold"><span class="name type">HFold</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="keyword">0</span>&ensp;<span class="boundvar">c</span>&ensp;:&ensp;(<span class="boundvar">k</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">q</span>&ensp;<span class="boundvar">c</span>&ensp;<span class="boundvar">ks</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">c</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">m</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">ks</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">m</span></code></dt><dd><pre>  Alias for `hconcat . hcmap c fun`</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.SOP.Interfaces.hsequence_"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.hsequence_"><span class="name function">hsequence_</span></a>&ensp;:&ensp;(<span class="type resolved" title="Prelude.Interfaces.Applicative"><span class="name type">Applicative</span></span>&ensp;<span class="boundvar">g</span>,&ensp;<a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HFold"><span class="name type">HFold</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">p</span>)&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;(<a class="type" href="Data.SOP.Utils.html#Data.SOP.Utils.K"><span class="name function">K</span></a>&ensp;(<span class="boundvar">g</span>&ensp;()))&ensp;<span class="boundvar">ks</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">g</span>&ensp;()</code></dt><dd><pre>  Generalization of `sequence_` to heterogeneous containers.<br>  <br>  Alias for `hfoldl (*&gt;) (pure ())`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.SOP.Interfaces.htraverse_"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.htraverse_"><span class="name function">htraverse_</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Interfaces.Applicative"><span class="name type">Applicative</span></span>&ensp;<span class="boundvar">g</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HFunctor"><span class="name type">HFunctor</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HFold"><span class="name type">HFold</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">g</span>&ensp;())&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">ks</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">g</span>&ensp;()</code></dt><dd><pre>  Generalization of `traverse_` to heterogeneous containers.<br>  <br>  Alias for `hsequence_ . hmap fun`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.SOP.Interfaces.hfor_"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.hfor_"><span class="name function">hfor_</span></a>&ensp;:&ensp;(<span class="type resolved" title="Prelude.Interfaces.Applicative"><span class="name type">Applicative</span></span>&ensp;<span class="boundvar">g</span>,&ensp;(<a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HFold"><span class="name type">HFold</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">p</span>,&ensp;<a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HFunctor"><span class="name type">HFunctor</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">p</span>))&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">ks</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">g</span>&ensp;())&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">g</span>&ensp;()</code></dt><dd><pre>  Generalization of `for_` to heterogeneous containers.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.SOP.Interfaces.hand"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.hand"><span class="name function">hand</span></a>&ensp;:&ensp;<a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HFold"><span class="name type">HFold</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;(<a class="type" href="Data.SOP.Utils.html#Data.SOP.Utils.K"><span class="name function">K</span></a>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span>)&ensp;<span class="boundvar">ks</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span></code></dt><dd><pre>  Generalization of `and` to heterogeneous containers.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.SOP.Interfaces.htoList"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.htoList"><span class="name function">htoList</span></a>&ensp;:&ensp;(<a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HFunctor"><span class="name type">HFunctor</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">p</span>,&ensp;<a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HFold"><span class="name type">HFold</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">p</span>)&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;(<a class="type" href="Data.SOP.Utils.html#Data.SOP.Utils.K"><span class="name function">K</span></a>&ensp;<span class="boundvar">a</span>)&ensp;<span class="boundvar">ks</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Generalization of `toList` to heterogeneous containers.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.SOP.Interfaces.hor"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.hor"><span class="name function">hor</span></a>&ensp;:&ensp;<a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HFold"><span class="name type">HFold</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;(<a class="type" href="Data.SOP.Utils.html#Data.SOP.Utils.K"><span class="name function">K</span></a>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span>)&ensp;<span class="boundvar">ks</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span></code></dt><dd><pre>  Generalization of `or` to heterogeneous containers.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.SOP.Interfaces.hall"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.hall"><span class="name function">hall</span></a>&ensp;:&ensp;<a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HFunctor"><span class="name type">HFunctor</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HFold"><span class="name type">HFold</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">ks</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span></code></dt><dd><pre>  Generalization of `all` to heterogeneous containers.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.SOP.Interfaces.hany"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.hany"><span class="name function">hany</span></a>&ensp;:&ensp;<a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HFunctor"><span class="name type">HFunctor</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HFold"><span class="name type">HFold</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">ks</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span></code></dt><dd><pre>  Generalization of `any` to heterogeneous containers.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.SOP.Interfaces.hchoice"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.hchoice"><span class="name function">hchoice</span></a>&ensp;:&ensp;<a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HFold"><span class="name type">HFold</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.Interfaces.Alternative"><span class="name type">Alternative</span></span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;(<a class="type" href="Data.SOP.Utils.html#Data.SOP.Utils.K"><span class="name function">K</span></a>&ensp;(<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>))&ensp;<span class="boundvar">ks</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Generalization of `choice` to heterogeneous containers.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.SOP.Interfaces.HSequence"><code><span class="keyword">interface</span>&ensp;<a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HSequence"><span class="name type">HSequence</span></a>&ensp;:&ensp;(<span class="boundvar">k</span>&ensp;:&ensp;<span class="name type">Type</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">l</span>&ensp;:&ensp;<span class="name type">Type</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HCont"><span class="name function">HCont</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd><pre>  Sequencing of applicative effects over a heterogeneous<br>  container.</pre><br>  <b>Parameters</b>:&ensp;k,&ensp;l,&ensp;p<br><b>Methods</b>:<br><dl class="decls">  <dt id="Data.SOP.Interfaces.hsequence"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.hsequence"><span class="name function">hsequence</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Interfaces.Applicative"><span class="name type">Applicative</span></span>&ensp;<span class="boundvar">g</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;(\<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">g</span>&ensp;(<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>))&ensp;<span class="boundvar">ks</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">g</span>&ensp;(<span class="boundvar">p</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">ks</span>)</code></dt><dd><pre>  Given a heterogeneous containers holding values<br>  wrapped in effect `g`, sequences applications of<br>  `g` to the outside of the heterogeneous container.<br>  <br>  ```idris example<br>  seqMaybe : NP Maybe [Int,String] -&gt; Maybe (NP I [Int,String])<br>  seqMaybe = hsequence<br>  ```</pre></dd></dl><br><b>Implementations</b>:<br><dl class="decls">  <dt id="$resolved6284"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HSequence"><span class="name type">HSequence</span></a>&ensp;<span class="boundvar">k</span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">k</span>)&ensp;(<a class="type" href="Data.SOP.NS.html#Data.SOP.NS.NS_"><span class="name type">NS_</span></a>&ensp;<span class="boundvar">k</span>)</code></dt>  <dt id="$resolved5963"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HSequence"><span class="name type">HSequence</span></a>&ensp;<span class="boundvar">k</span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">k</span>)&ensp;(<a class="type" href="Data.SOP.NP.html#Data.SOP.NP.NP_"><span class="name type">NP_</span></a>&ensp;<span class="boundvar">k</span>)</code></dt>  <dt id="$resolved5761"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HSequence"><span class="name type">HSequence</span></a>&ensp;<span class="boundvar">k</span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">k</span>))&ensp;(<a class="type" href="Data.SOP.POP.html#Data.SOP.POP.POP_"><span class="name type">POP_</span></a>&ensp;<span class="boundvar">k</span>)</code></dt>  <dt id="$resolved4933"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HSequence"><span class="name type">HSequence</span></a>&ensp;<span class="boundvar">k</span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">k</span>))&ensp;(<a class="type" href="Data.SOP.SOP.html#Data.SOP.SOP.SOP_"><span class="name type">SOP_</span></a>&ensp;<span class="boundvar">k</span>)</code></dt></dl></dd><dt id="Data.SOP.Interfaces.hsequence"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.hsequence"><span class="name function">hsequence</span></a>&ensp;:&ensp;<a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HSequence"><span class="name type">HSequence</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.Interfaces.Applicative"><span class="name type">Applicative</span></span>&ensp;<span class="boundvar">g</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;(\<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">g</span>&ensp;(<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>))&ensp;<span class="boundvar">ks</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">g</span>&ensp;(<span class="boundvar">p</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">ks</span>)</code></dt><dd><pre>  Given a heterogeneous containers holding values<br>  wrapped in effect `g`, sequences applications of<br>  `g` to the outside of the heterogeneous container.<br>  <br>  ```idris example<br>  seqMaybe : NP Maybe [Int,String] -&gt; Maybe (NP I [Int,String])<br>  seqMaybe = hsequence<br>  ```</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.SOP.Interfaces.htraverse"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.htraverse"><span class="name function">htraverse</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Interfaces.Applicative"><span class="name type">Applicative</span></span>&ensp;<span class="boundvar">g</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HFunctor"><span class="name type">HFunctor</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HSequence"><span class="name type">HSequence</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">g</span>&ensp;(<span class="boundvar">f&apos;</span>&ensp;<span class="boundvar">a</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">ks</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">g</span>&ensp;(<span class="boundvar">p</span>&ensp;<span class="boundvar">f&apos;</span>&ensp;<span class="boundvar">ks</span>)</code></dt><dd><pre>  Traverses a heterogeneous container by applying effectful<br>  function `fun`.<br>  <br>  ```idris example<br>  htraverseEx : NP (Either String) [Int,String] -&gt; Maybe (NP I [Int,String])<br>  htraverseEx = htraverse (either (const Nothing) Just)<br>  ```</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.SOP.Interfaces.hfor"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.hfor"><span class="name function">hfor</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Interfaces.Applicative"><span class="name type">Applicative</span></span>&ensp;<span class="boundvar">g</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HFunctor"><span class="name type">HFunctor</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HSequence"><span class="name type">HSequence</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">ks</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">g</span>&ensp;(<span class="boundvar">f&apos;</span>&ensp;<span class="boundvar">a</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">g</span>&ensp;(<span class="boundvar">p</span>&ensp;<span class="boundvar">f&apos;</span>&ensp;<span class="boundvar">ks</span>)</code></dt><dd><pre>  Flipped version of `htraverse`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.SOP.Interfaces.hctraverse"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.hctraverse"><span class="name function">hctraverse</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Interfaces.Applicative"><span class="name type">Applicative</span></span>&ensp;<span class="boundvar">g</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HAp"><span class="name type">HAp</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">q</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HSequence"><span class="name type">HSequence</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="keyword">0</span>&ensp;<span class="boundvar">c</span>&ensp;:&ensp;(<span class="boundvar">k</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">q</span>&ensp;<span class="boundvar">c</span>&ensp;<span class="boundvar">ks</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">c</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">g</span>&ensp;(<span class="boundvar">f&apos;</span>&ensp;<span class="boundvar">a</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">ks</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">g</span>&ensp;(<span class="boundvar">p</span>&ensp;<span class="boundvar">f&apos;</span>&ensp;<span class="boundvar">ks</span>)</code></dt><dd><pre>  Constrained version of `htraverse`.<br>  <br>  ```idris example<br>  interface Read a where<br>    read : String -&gt; Maybe a<br>  <br>  hctraverseEx : NP Read [Int,String] =&gt;<br>                 NP (K String) [Int,String] -&gt; Maybe (NP I [Int,String])<br>  hctraverseEx = hctraverse Read read<br>  ```</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.SOP.Interfaces.hcfor"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.hcfor"><span class="name function">hcfor</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Interfaces.Applicative"><span class="name type">Applicative</span></span>&ensp;<span class="boundvar">g</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HAp"><span class="name type">HAp</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">q</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HSequence"><span class="name type">HSequence</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="keyword">0</span>&ensp;<span class="boundvar">c</span>&ensp;:&ensp;(<span class="boundvar">k</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">q</span>&ensp;<span class="boundvar">c</span>&ensp;<span class="boundvar">ks</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">ks</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">c</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">g</span>&ensp;(<span class="boundvar">f&apos;</span>&ensp;<span class="boundvar">a</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">g</span>&ensp;(<span class="boundvar">p</span>&ensp;<span class="boundvar">f&apos;</span>&ensp;<span class="boundvar">ks</span>)</code></dt><dd><pre>  Flipped version of `hctraverse`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.SOP.Interfaces.HCollapse"><code><span class="keyword">interface</span>&ensp;<a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HCollapse"><span class="name type">HCollapse</span></a>&ensp;:&ensp;(<span class="boundvar">k</span>&ensp;:&ensp;<span class="name type">Type</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">l</span>&ensp;:&ensp;<span class="name type">Type</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HCont"><span class="name function">HCont</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="name type">Type</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd><pre>  Collapsing a heterogeneous container to a homogeneous one<br>  of the same shape.</pre><br>  <b>Parameters</b>:&ensp;k,&ensp;l,&ensp;p,&ensp;collapseTo<br><b>Methods</b>:<br><dl class="decls">  <dt id="Data.SOP.Interfaces.hcollapse"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.hcollapse"><span class="name function">hcollapse</span></a>&ensp;:&ensp;<span class="boundvar">p</span>&ensp;(<a class="type" href="Data.SOP.Utils.html#Data.SOP.Utils.K"><span class="name function">K</span></a>&ensp;<span class="boundvar">a</span>)&ensp;<span class="boundvar">ks</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">collapseTo</span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  A heterogeneous container over constant functor `K a` is<br>  actually a homogeneous one holding only values of type `a`.<br>  This function extracts the wrapped values into a homogeneous<br>  one of the same size and shape.</pre></dd></dl><br><b>Implementations</b>:<br><dl class="decls">  <dt id="$resolved6287"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HCollapse"><span class="name type">HCollapse</span></a>&ensp;<span class="boundvar">k</span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">k</span>)&ensp;(<a class="type" href="Data.SOP.NS.html#Data.SOP.NS.NS_"><span class="name type">NS_</span></a>&ensp;<span class="boundvar">k</span>)&ensp;<a class="type" href="Data.SOP.Utils.html#Data.SOP.Utils.I"><span class="name function">I</span></a></code></dt>  <dt id="$resolved5967"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HCollapse"><span class="name type">HCollapse</span></a>&ensp;<span class="boundvar">k</span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">k</span>)&ensp;(<a class="type" href="Data.SOP.NP.html#Data.SOP.NP.NP_"><span class="name type">NP_</span></a>&ensp;<span class="boundvar">k</span>)&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span></code></dt>  <dt id="$resolved5765"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HCollapse"><span class="name type">HCollapse</span></a>&ensp;<span class="boundvar">k</span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">k</span>))&ensp;(<a class="type" href="Data.SOP.POP.html#Data.SOP.POP.POP_"><span class="name type">POP_</span></a>&ensp;<span class="boundvar">k</span>)&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="type resolved" title="Prelude.Basics.(.)"><span class="name function">.</span></span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>)</code></dt>  <dt id="$resolved4936"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HCollapse"><span class="name type">HCollapse</span></a>&ensp;<span class="boundvar">k</span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">k</span>))&ensp;(<a class="type" href="Data.SOP.SOP.html#Data.SOP.SOP.SOP_"><span class="name type">SOP_</span></a>&ensp;<span class="boundvar">k</span>)&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span></code></dt></dl></dd><dt id="Data.SOP.Interfaces.hcollapse"><code><a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.hcollapse"><span class="name function">hcollapse</span></a>&ensp;:&ensp;<a class="type" href="Data.SOP.Interfaces.html#Data.SOP.Interfaces.HCollapse"><span class="name type">HCollapse</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">collapseTo</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;(<a class="type" href="Data.SOP.Utils.html#Data.SOP.Utils.K"><span class="name function">K</span></a>&ensp;<span class="boundvar">a</span>)&ensp;<span class="boundvar">ks</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">collapseTo</span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  A heterogeneous container over constant functor `K a` is<br>  actually a homogeneous one holding only values of type `a`.<br>  This function extracts the wrapped values into a homogeneous<br>  one of the same size and shape.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd></dl></div><footer>Produced by Idris 2 version 0.7.0-da352d8ed</footer></body></html>
