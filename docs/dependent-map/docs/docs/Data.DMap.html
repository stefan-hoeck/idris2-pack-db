<!DOCTYPE html><html lang="en">

<head>
  <meta charset="utf-8">
  <title>Data.DMap</title>
  <link rel="stylesheet" type="text/css" id="preferredStyle" href="../default.css">
  <script>
    /* Updates the stylesheet to use the preferred one.
       Note that we set the link to root ++ sourceLoc because the config
       is shared across the whole website, so the root may differ from
       page to page.
    */
    function setStyleSource (sourceLoc) {
      document.getElementById("preferredStyle").href = "../" + sourceLoc + ".css";
      document.getElementById("selectPreferredStyle").value = sourceLoc;
    }
    /* Initialises the preferred style sheet:
       1. if there is a stored value then use that
          otherwise select the default
       2. set both the css link href & the drop down menu selected option
    */
    function initStyleSource () {
      var preferredStyle = localStorage.getItem("stylefile");
      if (preferredStyle !== null) {
        setStyleSource(preferredStyle);
      } else {
        setStyleSource("default");
      };
    }
    function saveStyleSource (preferredStyle) {
      localStorage.stylefile = preferredStyle;
    }
    </script>
</head>

<body class="namespace">
<header>
  <strong>Idris2Doc</strong> : Data.DMap
  <nav><a href="../index.html">Index</a>

  <select id="selectPreferredStyle">
    <option value="default">Default</option>
<option value="alternative">Alternative</option>
<option value="blackandwhite">Black & White</option>

  </select>
  </nav>

  <script>
  /* We start by initialising the style source */
  initStyleSource();

  /* This listens for changes on the drop down menu and updates the
     css used for the current page when a selection is made.
  */
  document.getElementById("selectPreferredStyle").addEventListener("change", function(){
    var selected = this.options[this.selectedIndex].value; /* the option chosen */
    setStyleSource (selected);
    saveStyleSource (selected);
  });
</script>

</header>
<div class="container"><div id="module-header"><h1>Data.DMap</h1><span style="float:right">(<a href="Data.DMap.src.html">source</a>)</span><pre>A module describing the dependent map (`DMap`).
Copied from haskell&apos;s &quot;dependent-map&quot; package.
</pre></div><h2>Reexports</h2><code><span class="keyword">import</span>&ensp;<span class="keyword">public</span>&ensp;Data.DFunctor<br><span class="keyword">import</span>&ensp;<span class="keyword">public</span>&ensp;Data.DFoldable<br><span class="keyword">import</span>&ensp;<span class="keyword">public</span>&ensp;Data.DSum<br><span class="keyword">import</span>&ensp;<span class="keyword">public</span>&ensp;Data.DOrd<br><span class="keyword">import</span>&ensp;<span class="keyword">public</span>&ensp;Data.DEq<br><span class="keyword">import</span>&ensp;<span class="keyword">public</span>&ensp;Data.Some</code><h2>Definitions</h2><dl class="decls"><dt id="Data.DMap.ShowS"><code><a class="type" href="Data.DMap.html#Data.DMap.ShowS"><span class="name function">ShowS</span></a>&ensp;:&ensp;<span class="name type">Type</span></code></dt><dd><pre>  A copy of Haskells `ShowS` type</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.DMap.DMap"><code><span class="keyword">data</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd><pre>  Dependent maps: &apos;k&apos; is a GADT-like thing with a facility for<br>  rediscovering its type parameter, elements of which function as identifiers<br>  tagged with the type of the thing they identify.  Real GADTs are one<br>  useful instantiation of `k`, as are &apos;Tag&apos;s from &quot;Data.Unique.Tag&quot; in the<br>  &apos;prim-uniq&apos; package.<br>  <br>  Semantically, `&apos;DMap&apos; k f` is equivalent to a set of `&apos;DSum&apos; k f` where no two<br>  elements have the same tag.<br>  <br>  More informally, &apos;DMap&apos; is to dependent products as &apos;M.Map&apos; is to `(-&gt;)`.<br>  Thus it could also be thought of as a partial (in the sense of \&quot;partial<br>  function\&quot;) dependent product.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Constructors</b>:<br><dl class="decls">  <dt id="Data.DMap.Tip"><code><a class="type" href="Data.DMap.html#Data.DMap.Tip"><span class="name constructor">Tip</span></a>&ensp;:&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span></code></dt>  <dt id="Data.DMap.Bin"><code><a class="type" href="Data.DMap.html#Data.DMap.Bin"><span class="name constructor">Bin</span></a>&ensp;:&ensp;<span class="name type">Int</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span></code></dt></dl><br>  <b>Hints</b>:<br><dl class="decls">  <dt id="$resolved544"><code><span class="type resolved" title="Data.DFoldable.DFoldable"><span class="name type">DFoldable</span></span>&ensp;(<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>)</code></dt>  <dt id="$resolved543"><code><span class="type resolved" title="Data.DFunctor.DFunctor"><span class="name type">DFunctor</span></span>&ensp;(<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>)</code></dt>  <dt id="$resolved542"><code><span class="type resolved" title="Data.DEq.DEq"><span class="name type">DEq</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Data.DEq.DEq"><span class="name type">DEq</span></span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.EqOrd.Eq"><span class="name type">Eq</span></span>&ensp;(<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>)</code></dt>  <dt id="$resolved541"><code><span class="type resolved" title="Data.DOrd.DOrd"><span class="name type">DOrd</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.Interfaces.Monoid"><span class="name type">Monoid</span></span>&ensp;(<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>)</code></dt>  <dt id="$resolved540"><code><span class="type resolved" title="Data.DOrd.DOrd"><span class="name type">DOrd</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Data.DOrd.DOrd"><span class="name type">DOrd</span></span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;(<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>)</code></dt>  <dt id="$resolved539"><code><span class="type resolved" title="Data.DOrd.DOrd"><span class="name type">DOrd</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.Interfaces.Semigroup"><span class="name type">Semigroup</span></span>&ensp;(<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>)</code></dt>  <dt id="$resolved538"><code><span class="type resolved" title="Data.DShow.DShow"><span class="name type">DShow</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Data.DShow.DShow"><span class="name type">DShow</span></span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.Show.Show"><span class="name type">Show</span></span>&ensp;(<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>)</code></dt></dl></dd><dt id="Data.DMap.empty"><code><a class="type" href="Data.DMap.html#Data.DMap.empty"><span class="name function">empty</span></a>&ensp;:&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span></code></dt><dd><pre>  *O(1)*. The empty map.<br>  <br>  ```<br>  empty      == fromList []<br>  size empty == 0<br>  ```</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.singleton"><code><a class="type" href="Data.DMap.html#Data.DMap.singleton"><span class="name function">singleton</span></a>&ensp;:&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span></code></dt><dd><pre>  *O(1)*. A map with a single element.<br>  <br>  ```<br>  singleton k v        == fromList [k :=&gt; v]<br>  size (singleton k v) == 1<br>  ```</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.null"><code><a class="type" href="Data.DMap.html#Data.DMap.null"><span class="name function">null</span></a>&ensp;:&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span></code></dt><dd><pre>  *O(1)*. Is the map empty?</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.size"><code><a class="type" href="Data.DMap.html#Data.DMap.size"><span class="name function">size</span></a>&ensp;:&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Int</span></code></dt><dd><pre>  *O(1)*. The number of elements in the map.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.lookup"><code><a class="type" href="Data.DMap.html#Data.DMap.lookup"><span class="name function">lookup</span></a>&ensp;:&ensp;<span class="type resolved" title="Data.DOrd.DOrd"><span class="name type">DOrd</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;(<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>)</code></dt><dd><pre>  *O(log n)*. Lookup the value at a key in the map.<br>  <br>  The function will return the corresponding value as `(&apos;Just&apos; value)`,<br>  or &apos;Nothing&apos; if the key isn&apos;t in the map.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.minViewWithKey"><code><a class="type" href="Data.DMap.html#Data.DMap.minViewWithKey"><span class="name function">minViewWithKey</span></a>&ensp;:&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;(<span class="type resolved" title="Data.DSum.DSum"><span class="name type">DSum</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>,&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>)</code></dt><dd><pre>  *O(log n)*. Retrieves the minimal (key :=&gt; value) entry of the map, and<br>  the map stripped of that element, or &apos;Nothing&apos; if passed an empty map.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.maxViewWithKey"><code><a class="type" href="Data.DMap.html#Data.DMap.maxViewWithKey"><span class="name function">maxViewWithKey</span></a>&ensp;:&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;(<span class="type resolved" title="Data.DSum.DSum"><span class="name type">DSum</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>,&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>)</code></dt><dd><pre>  *O(log n)*. Retrieves the maximal (key :=&gt; value) entry of the map, and<br>  the map stripped of that element, or &apos;Nothing&apos; if passed an empty map.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.deleteFindMax"><code><a class="type" href="Data.DMap.html#Data.DMap.deleteFindMax"><span class="name function">deleteFindMax</span></a>&ensp;:&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="type resolved" title="Data.DSum.DSum"><span class="name type">DSum</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>,&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>)</code></dt><dd><pre>  *O(log n)*. Delete and find the maximal element.<br>  <br>  Given `k1, k2 &lt; k3`<br>  ```<br>  deleteFindMax (fromList [k1 :=&gt; v1, k2 :=&gt; v2, k3 :=&gt; v3]) == (k3 :=&gt; v3, fromList [k1 :=&gt; v1, k2 :=&gt; v2])<br>  deleteFindMax empty                                            Error: can not return the maximal element of an empty map<br>  ```</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.deleteFindMin"><code><a class="type" href="Data.DMap.html#Data.DMap.deleteFindMin"><span class="name function">deleteFindMin</span></a>&ensp;:&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="type resolved" title="Data.DSum.DSum"><span class="name type">DSum</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>,&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>)</code></dt><dd><pre>  *O(log n)*. Delete and find the minimal element.<br>  <br>  Given `k2 &gt; k1, k3`<br>  ```<br>  deleteFindMin (fromList [k1 :=&gt; v1, k2 :=&gt; v2, k3 :=&gt; v3]) == (k2 :=&gt; v2, fromList [k1 :=&gt; v1, k3 :=&gt; v3])<br>  deleteFindMin                                                  Error: can not return the minimal element of an empty map<br>  ```</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.member"><code><a class="type" href="Data.DMap.html#Data.DMap.member"><span class="name function">member</span></a>&ensp;:&ensp;<span class="type resolved" title="Data.DOrd.DOrd"><span class="name type">DOrd</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span></code></dt><dd><pre>  *O(log n)*. Is the key a member of the map? See also &apos;notMember&apos;.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.notMember"><code><a class="type" href="Data.DMap.html#Data.DMap.notMember"><span class="name function">notMember</span></a>&ensp;:&ensp;<span class="type resolved" title="Data.DOrd.DOrd"><span class="name type">DOrd</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span></code></dt><dd><pre>  *O(log n)*. Is the key not a member of the map? See also &apos;member&apos;.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.findWithDefault"><code><a class="type" href="Data.DMap.html#Data.DMap.findWithDefault"><span class="name function">findWithDefault</span></a>&ensp;:&ensp;<span class="type resolved" title="Data.DOrd.DOrd"><span class="name type">DOrd</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span></code></dt><dd><pre>  *O(log n)*. The expression `(&apos;findWithDefault&apos; def k map)` returns<br>  the value at key `k` or returns default value `def`<br>  when the key is not in the map.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.insert"><code><a class="type" href="Data.DMap.html#Data.DMap.insert"><span class="name function">insert</span></a>&ensp;:&ensp;<span class="type resolved" title="Data.DOrd.DOrd"><span class="name type">DOrd</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span></code></dt><dd><pre>  *O(log n)*. Insert a new key and value in the map.<br>  If the key is already present in the map, the associated value is<br>  replaced with the supplied value. &apos;insert&apos; is equivalent to<br>  `&apos;insertWith&apos; &apos;const&apos;`.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.insertWithKey"><code><a class="type" href="Data.DMap.html#Data.DMap.insertWithKey"><span class="name function">insertWithKey</span></a>&ensp;:&ensp;<span class="type resolved" title="Data.DOrd.DOrd"><span class="name type">DOrd</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span></code></dt><dd><pre>  *O(log n)*. Insert with a function, combining key, new value and old value.<br>  `&apos;insertWithKey&apos; f key value mp`<br>  will insert the entry `key :=&gt; value` into `mp` if key does<br>  not exist in the map. If the key does exist, the function will<br>  insert the entry `key :=&gt; f key new_value old_value`.<br>  Note that the key passed to f is the same key passed to &apos;insertWithKey&apos;.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.insertWith"><code><a class="type" href="Data.DMap.html#Data.DMap.insertWith"><span class="name function">insertWith</span></a>&ensp;:&ensp;<span class="type resolved" title="Data.DOrd.DOrd"><span class="name type">DOrd</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span></code></dt><dd><pre>  *O(log n)*. Insert with a function, combining new value and old value.<br>  `&apos;insertWith&apos; f key value mp`<br>  will insert the entry `key :=&gt; value` into `mp` if key does<br>  not exist in the map. If the key does exist, the function will<br>  insert the entry `key :=&gt; f new_value old_value`.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.insertLookupWithKey"><code><a class="type" href="Data.DMap.html#Data.DMap.insertLookupWithKey"><span class="name function">insertLookupWithKey</span></a>&ensp;:&ensp;<span class="type resolved" title="Data.DOrd.DOrd"><span class="name type">DOrd</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;(<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>),&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>)</code></dt><dd><pre>  *O(log n)*. Combines insert operation with old value retrieval.<br>  The expression (`&apos;insertLookupWithKey&apos; f k x map`)<br>  is a pair where the first element is equal to (`&apos;lookup&apos; k map`)</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.delete"><code><a class="type" href="Data.DMap.html#Data.DMap.delete"><span class="name function">delete</span></a>&ensp;:&ensp;<span class="type resolved" title="Data.DOrd.DOrd"><span class="name type">DOrd</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span></code></dt><dd><pre>  *O(log n)*. Delete a key and its value from the map. When the key is not<br>  a member of the map, the original map is returned.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.updateWithKey"><code><a class="type" href="Data.DMap.html#Data.DMap.updateWithKey"><span class="name function">updateWithKey</span></a>&ensp;:&ensp;<span class="type resolved" title="Data.DOrd.DOrd"><span class="name type">DOrd</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;(<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span></code></dt><dd><pre>  *O(log n)*. The expression (`&apos;updateWithKey&apos; f k map`) updates the<br>  value `x` at `k` (if it is in the map). If (`f k x`) is &apos;Nothing&apos;,<br>  the element is deleted. If it is (`&apos;Just&apos; y`), the key `k` is bound<br>  to the new value `y`.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.update"><code><a class="type" href="Data.DMap.html#Data.DMap.update"><span class="name function">update</span></a>&ensp;:&ensp;<span class="type resolved" title="Data.DOrd.DOrd"><span class="name type">DOrd</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;(<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span></code></dt><dd><pre>  *O(log n)*. The expression (`&apos;update&apos; f k map`) updates the value `x`<br>  at `k` (if it is in the map). If (`f x`) is &apos;Nothing&apos;, the element is<br>  deleted. If it is (`&apos;Just&apos; y`), the key `k` is bound to the new value `y`.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.updateLookupWithKey"><code><a class="type" href="Data.DMap.html#Data.DMap.updateLookupWithKey"><span class="name function">updateLookupWithKey</span></a>&ensp;:&ensp;<span class="type resolved" title="Data.DOrd.DOrd"><span class="name type">DOrd</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;(<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;(<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>),&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>)</code></dt><dd><pre>  *O(log n)*. Lookup and update. See also &apos;updateWithKey&apos;.<br>  The function returns changed value, if it is updated.<br>  Returns the original key value if the map entry is deleted.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.alter"><code><a class="type" href="Data.DMap.html#Data.DMap.alter"><span class="name function">alter</span></a>&ensp;:&ensp;<span class="type resolved" title="Data.DOrd.DOrd"><span class="name type">DOrd</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;(<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;(<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span></code></dt><dd><pre>  *O(log n)*. The expression (`&apos;alter&apos; f k map`) alters the value `x` at `k`, or absence thereof.<br>  &apos;alter&apos; can be used to insert, delete, or update a value in a &apos;Map&apos;.<br>  In short : `&apos;lookup&apos; k (&apos;alter&apos; f k m) = f (&apos;lookup&apos; k m)`.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.alterF"><code><a class="type" href="Data.DMap.html#Data.DMap.alterF"><span class="name function">alterF</span></a>&ensp;:&ensp;<span class="type resolved" title="Data.DOrd.DOrd"><span class="name type">DOrd</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.Interfaces.Functor"><span class="name type">Functor</span></span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;(<span class="boundvar">g</span>&ensp;<span class="boundvar">v</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;(<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;(<span class="boundvar">g</span>&ensp;<span class="boundvar">v</span>)))&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">g</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;(<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">g</span>)</code></dt><dd><pre>  Works the same as &apos;alter&apos; except the new value is returned in some &apos;Functor&apos; `f`.<br>  In short : `(\v&apos; -&gt; alter (const v&apos;) k dm) &lt;$&gt; f (lookup k dm)`</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.lookupIndex"><code><a class="type" href="Data.DMap.html#Data.DMap.lookupIndex"><span class="name function">lookupIndex</span></a>&ensp;:&ensp;<span class="type resolved" title="Data.DOrd.DOrd"><span class="name type">DOrd</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;<span class="name type">Int</span></code></dt><dd><pre>  *O(log n)*. Lookup the *index* of a key. The index is a number from<br>  *0* up to, but not including, the &apos;size&apos; of the map.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.findIndex"><code><a class="type" href="Data.DMap.html#Data.DMap.findIndex"><span class="name function">findIndex</span></a>&ensp;:&ensp;<span class="type resolved" title="Data.DOrd.DOrd"><span class="name type">DOrd</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Int</span></code></dt><dd><pre>  *O(log n)*. Return the *index* of a key. The index is a number from<br>  *0* up to, but not including, the &apos;size&apos; of the map. Calls &apos;error&apos; when<br>  the key is not a &apos;member&apos; of the map.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.elemAt"><code><a class="type" href="Data.DMap.html#Data.DMap.elemAt"><span class="name function">elemAt</span></a>&ensp;:&ensp;<span class="name type">Int</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Data.DSum.DSum"><span class="name type">DSum</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span></code></dt><dd><pre>  *O(log n)*. Retrieve an element by *index*. Calls &apos;error&apos; when an<br>  invalid index is used.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.updateAt"><code><a class="type" href="Data.DMap.html#Data.DMap.updateAt"><span class="name function">updateAt</span></a>&ensp;:&ensp;(<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;(<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Int</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span></code></dt><dd><pre>  *O(log n)*. Update the element at *index*. Does nothing when an<br>  invalid index is used.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.deleteAt"><code><a class="type" href="Data.DMap.html#Data.DMap.deleteAt"><span class="name function">deleteAt</span></a>&ensp;:&ensp;<span class="name type">Int</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span></code></dt><dd><pre>  *O(log n)*. Delete the element at *index*.<br>  Defined as (`&apos;deleteAt&apos; i map = &apos;updateAt&apos; (\k x -&gt; &apos;Nothing&apos;) i map`).</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.lookupMin"><code><a class="type" href="Data.DMap.html#Data.DMap.lookupMin"><span class="name function">lookupMin</span></a>&ensp;:&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;(<span class="type resolved" title="Data.DSum.DSum"><span class="name type">DSum</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>)</code></dt><dd>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.findMin"><code><a class="type" href="Data.DMap.html#Data.DMap.findMin"><span class="name function">findMin</span></a>&ensp;:&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Data.DSum.DSum"><span class="name type">DSum</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span></code></dt><dd><pre>  *O(log n)*. The minimal key of the map. Calls &apos;error&apos; if the map is empty.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.lookupMax"><code><a class="type" href="Data.DMap.html#Data.DMap.lookupMax"><span class="name function">lookupMax</span></a>&ensp;:&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;(<span class="type resolved" title="Data.DSum.DSum"><span class="name type">DSum</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>)</code></dt><dd>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.findMax"><code><a class="type" href="Data.DMap.html#Data.DMap.findMax"><span class="name function">findMax</span></a>&ensp;:&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Data.DSum.DSum"><span class="name type">DSum</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span></code></dt><dd><pre>  *O(log n)*. The maximal key of the map. Calls &apos;error&apos; if the map is empty.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.deleteMin"><code><a class="type" href="Data.DMap.html#Data.DMap.deleteMin"><span class="name function">deleteMin</span></a>&ensp;:&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span></code></dt><dd><pre>  *O(log n)*. Delete the minimal key. Returns an empty map if the map is empty.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.deleteMax"><code><a class="type" href="Data.DMap.html#Data.DMap.deleteMax"><span class="name function">deleteMax</span></a>&ensp;:&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span></code></dt><dd><pre>  *O(log n)*. Delete the maximal key. Returns an empty map if the map is empty.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.updateMinWithKey"><code><a class="type" href="Data.DMap.html#Data.DMap.updateMinWithKey"><span class="name function">updateMinWithKey</span></a>&ensp;:&ensp;(<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;(<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span></code></dt><dd><pre>  *O(log n)*. Update the value at the minimal key.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.updateMaxWithKey"><code><a class="type" href="Data.DMap.html#Data.DMap.updateMaxWithKey"><span class="name function">updateMaxWithKey</span></a>&ensp;:&ensp;(<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;(<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span></code></dt><dd><pre>  *O(log n)*. Update the value at the maximal key.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.split"><code><a class="type" href="Data.DMap.html#Data.DMap.split"><span class="name function">split</span></a>&ensp;:&ensp;<span class="type resolved" title="Data.DOrd.DOrd"><span class="name type">DOrd</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>,&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>)</code></dt><dd><pre>  *O(log n)*. The expression (`&apos;split&apos; k map`) is a pair `(map1,map2)` where<br>  the keys in `map1` are smaller than `k` and the keys in `map2` larger than `k`.<br>  Any key equal to `k` is found in neither `map1` nor `map2`.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.splitLookup"><code><a class="type" href="Data.DMap.html#Data.DMap.splitLookup"><span class="name function">splitLookup</span></a>&ensp;:&ensp;<span class="type resolved" title="Data.DOrd.DOrd"><span class="name type">DOrd</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>,&ensp;(<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;(<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>),&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>))</code></dt><dd><pre>  *O(log n)*. The expression (`&apos;splitLookup&apos; k map`) splits a map just<br>  like &apos;split&apos; but also returns `&apos;lookup&apos; k map`.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.union"><code><a class="type" href="Data.DMap.html#Data.DMap.union"><span class="name function">union</span></a>&ensp;:&ensp;<span class="type resolved" title="Data.DOrd.DOrd"><span class="name type">DOrd</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span></code></dt><dd><pre>  *O(m*log(n/m + 1)), m &lt;= n*.<br>  The expression (`&apos;union&apos; t1 t2`) takes the left-biased union of `t1` and `t2`.<br>  It prefers `t1` when duplicate keys are encountered,<br>  i.e. (`&apos;union&apos; == &apos;unionWith&apos; &apos;const&apos;`).</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.unions"><code><a class="type" href="Data.DMap.html#Data.DMap.unions"><span class="name function">unions</span></a>&ensp;:&ensp;<span class="type resolved" title="Data.DOrd.DOrd"><span class="name type">DOrd</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;(<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span></code></dt><dd><pre>  The union of a list of maps:<br>    (`&apos;unions&apos; == &apos;Prelude.foldl&apos; &apos;union&apos; &apos;empty&apos;`).</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.unionWithKey"><code><a class="type" href="Data.DMap.html#Data.DMap.unionWithKey"><span class="name function">unionWithKey</span></a>&ensp;:&ensp;<span class="type resolved" title="Data.DOrd.DOrd"><span class="name type">DOrd</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span></code></dt><dd><pre>  *O(n+m)*.<br>  Union with a combining function.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.unionsWithKey"><code><a class="type" href="Data.DMap.html#Data.DMap.unionsWithKey"><span class="name function">unionsWithKey</span></a>&ensp;:&ensp;<span class="type resolved" title="Data.DOrd.DOrd"><span class="name type">DOrd</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;(<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span></code></dt><dd><pre>  The union of a list of maps, with a combining operation:<br>    (`&apos;unionsWithKey&apos; f == &apos;Prelude.foldl&apos; (&apos;unionWithKey&apos; f) &apos;empty&apos;`).</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.difference"><code><a class="type" href="Data.DMap.html#Data.DMap.difference"><span class="name function">difference</span></a>&ensp;:&ensp;<span class="type resolved" title="Data.DOrd.DOrd"><span class="name type">DOrd</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">g</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span></code></dt><dd><pre>  *O(m * log (n/m + 1)), m &lt;= n*. Difference of two maps.<br>  Return elements of the first map not existing in the second map.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.differenceWithKey"><code><a class="type" href="Data.DMap.html#Data.DMap.differenceWithKey"><span class="name function">differenceWithKey</span></a>&ensp;:&ensp;<span class="type resolved" title="Data.DOrd.DOrd"><span class="name type">DOrd</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">g</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;(<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">g</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span></code></dt><dd><pre>  *O(n+m)*. Difference with a combining function. When two equal keys are<br>  encountered, the combining function is applied to the key and both values.<br>  If it returns &apos;Nothing&apos;, the element is discarded (proper set difference). If<br>  it returns (`&apos;Just&apos; y`), the element is updated with a new value `y`.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.intersection"><code><a class="type" href="Data.DMap.html#Data.DMap.intersection"><span class="name function">intersection</span></a>&ensp;:&ensp;<span class="type resolved" title="Data.DOrd.DOrd"><span class="name type">DOrd</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span></code></dt><dd><pre>  *O(m * log (n/m + 1), m &lt;= n*. Intersection of two maps.<br>  Return data in the first map for the keys existing in both maps.<br>  (`&apos;intersection&apos; m1 m2 == &apos;intersectionWith&apos; &apos;const&apos; m1 m2`).</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.intersectionWithKey"><code><a class="type" href="Data.DMap.html#Data.DMap.intersectionWithKey"><span class="name function">intersectionWithKey</span></a>&ensp;:&ensp;<span class="type resolved" title="Data.DOrd.DOrd"><span class="name type">DOrd</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">g</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">h</span>&ensp;<span class="boundvar">v</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">g</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">h</span></code></dt><dd><pre>  *O(m * log (n/m + 1), m &lt;= n*. Intersection with a combining function.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.isSubmapOfBy"><code><a class="type" href="Data.DMap.html#Data.DMap.isSubmapOfBy"><span class="name function">isSubmapOfBy</span></a>&ensp;:&ensp;<span class="type resolved" title="Data.DOrd.DOrd"><span class="name type">DOrd</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">g</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">g</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span></code></dt><dd><pre>  *O(n+m)*.<br>  The expression (`&apos;isSubmapOfBy&apos; f t1 t2`) returns &apos;True&apos; if<br>  all keys in `t1` are in tree `t2`, and when `f` returns &apos;True&apos; when<br>  applied to their respective keys and values.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.isProperSubmapOfBy"><code><a class="type" href="Data.DMap.html#Data.DMap.isProperSubmapOfBy"><span class="name function">isProperSubmapOfBy</span></a>&ensp;:&ensp;<span class="type resolved" title="Data.DOrd.DOrd"><span class="name type">DOrd</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">g</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">g</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span></code></dt><dd><pre>  *O(n+m)*. Is this a proper submap? (ie. a submap but not equal).<br>  The expression (`&apos;isProperSubmapOfBy&apos; f m1 m2`) returns &apos;True&apos; when<br>  `m1` and `m2` are not equal,<br>  all keys in `m1` are in `m2`, and when `f` returns &apos;True&apos; when<br>  applied to their respective keys and values.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.filterWithKey"><code><a class="type" href="Data.DMap.html#Data.DMap.filterWithKey"><span class="name function">filterWithKey</span></a>&ensp;:&ensp;<span class="type resolved" title="Data.DOrd.DOrd"><span class="name type">DOrd</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span></code></dt><dd><pre>  *O(n)*. Filter all keys/values that satisfy the predicate.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.partitionWithKey"><code><a class="type" href="Data.DMap.html#Data.DMap.partitionWithKey"><span class="name function">partitionWithKey</span></a>&ensp;:&ensp;<span class="type resolved" title="Data.DOrd.DOrd"><span class="name type">DOrd</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>,&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>)</code></dt><dd><pre>  *O(n)*. Partition the map according to a predicate. The first<br>  map contains all elements that satisfy the predicate, the second all<br>  elements that fail the predicate. See also &apos;split&apos;.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.mapMaybe"><code><a class="type" href="Data.DMap.html#Data.DMap.mapMaybe"><span class="name function">mapMaybe</span></a>&ensp;:&ensp;<span class="type resolved" title="Data.DOrd.DOrd"><span class="name type">DOrd</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;(<span class="boundvar">g</span>&ensp;<span class="boundvar">v</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">g</span></code></dt><dd><pre>  *O(n)*. Map values and collect the &apos;Just&apos; results.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.mapEitherWithKey"><code><a class="type" href="Data.DMap.html#Data.DMap.mapEitherWithKey"><span class="name function">mapEitherWithKey</span></a>&ensp;:&ensp;<span class="type resolved" title="Data.DOrd.DOrd"><span class="name type">DOrd</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Either"><span class="name type">Either</span></span>&ensp;(<span class="boundvar">g</span>&ensp;<span class="boundvar">v</span>)&ensp;(<span class="boundvar">h</span>&ensp;<span class="boundvar">v</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">g</span>,&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">h</span>)</code></dt><dd><pre>  *O(n)*. Map keys/values and separate the &apos;Left&apos; and &apos;Right&apos; results.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.foldrWithKey"><code><a class="type" href="Data.DMap.html#Data.DMap.foldrWithKey"><span class="name function">foldrWithKey</span></a>&ensp;:&ensp;(<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">b</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">b</span></code></dt><dd><pre>  *O(n)*. Post-order fold.  The function will be applied from the lowest<br>  value to the highest.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.foldlWithKey"><code><a class="type" href="Data.DMap.html#Data.DMap.foldlWithKey"><span class="name function">foldlWithKey</span></a>&ensp;:&ensp;(<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">b</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">b</span></code></dt><dd><pre>  *O(n)*. Pre-order fold.  The function will be applied from the highest<br>  value to the lowest.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.fromList"><code><a class="type" href="Data.DMap.html#Data.DMap.fromList"><span class="name function">fromList</span></a>&ensp;:&ensp;<span class="type resolved" title="Data.DOrd.DOrd"><span class="name type">DOrd</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;(<span class="type resolved" title="Data.DSum.DSum"><span class="name type">DSum</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span></code></dt><dd><pre>  *O(n*log n)*. Build a map from a list of key/value pairs. See also &apos;fromAscList&apos;.<br>  If the list contains more than one value for the same key, the last value<br>  for the key is retained.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.fromListWithKey"><code><a class="type" href="Data.DMap.html#Data.DMap.fromListWithKey"><span class="name function">fromListWithKey</span></a>&ensp;:&ensp;<span class="type resolved" title="Data.DOrd.DOrd"><span class="name type">DOrd</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;(<span class="type resolved" title="Data.DSum.DSum"><span class="name type">DSum</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span></code></dt><dd><pre>  *O(n*log n)*. Build a map from a list of key/value pairs with a combining function. See also &apos;fromAscListWithKey&apos;.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.toAscList"><code><a class="type" href="Data.DMap.html#Data.DMap.toAscList"><span class="name function">toAscList</span></a>&ensp;:&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;(<span class="type resolved" title="Data.DSum.DSum"><span class="name type">DSum</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>)</code></dt><dd><pre>  *O(n)*. Convert to an ascending list.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.toList"><code><a class="type" href="Data.DMap.html#Data.DMap.toList"><span class="name function">toList</span></a>&ensp;:&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;(<span class="type resolved" title="Data.DSum.DSum"><span class="name type">DSum</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>)</code></dt><dd><pre>  *O(n)*. Convert to a list of key/value pairs.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.toDescList"><code><a class="type" href="Data.DMap.html#Data.DMap.toDescList"><span class="name function">toDescList</span></a>&ensp;:&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;(<span class="type resolved" title="Data.DSum.DSum"><span class="name type">DSum</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>)</code></dt><dd><pre>  *O(n)*. Convert to a descending list.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.fromDistinctAscList"><code><a class="type" href="Data.DMap.html#Data.DMap.fromDistinctAscList"><span class="name function">fromDistinctAscList</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;(<span class="type resolved" title="Data.DSum.DSum"><span class="name type">DSum</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span></code></dt><dd><pre>  *O(n)*. Build a map from an ascending list of distinct elements in linear time.<br>  *The precondition is not checked.*</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.fromAscListWithKey"><code><a class="type" href="Data.DMap.html#Data.DMap.fromAscListWithKey"><span class="name function">fromAscListWithKey</span></a>&ensp;:&ensp;<span class="type resolved" title="Data.DEq.DEq"><span class="name type">DEq</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;(<span class="type resolved" title="Data.DSum.DSum"><span class="name type">DSum</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span></code></dt><dd><pre>  *O(n)*. Build a map from an ascending list in linear time with a<br>  combining function for equal keys.<br>  *The precondition (input list is ascending) is not checked.*</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.fromAscList"><code><a class="type" href="Data.DMap.html#Data.DMap.fromAscList"><span class="name function">fromAscList</span></a>&ensp;:&ensp;<span class="type resolved" title="Data.DEq.DEq"><span class="name type">DEq</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;(<span class="type resolved" title="Data.DSum.DSum"><span class="name type">DSum</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span></code></dt><dd><pre>  *O(n)*. Build a map from an ascending list in linear time.<br>  *The precondition (input list is ascending) is not checked.*</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.assocs"><code><a class="type" href="Data.DMap.html#Data.DMap.assocs"><span class="name function">assocs</span></a>&ensp;:&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;(<span class="type resolved" title="Data.DSum.DSum"><span class="name type">DSum</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>)</code></dt><dd><pre>  *O(n)*. Return all key/value pairs in the map in ascending key order.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.keys"><code><a class="type" href="Data.DMap.html#Data.DMap.keys"><span class="name function">keys</span></a>&ensp;:&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;(<span class="type resolved" title="Data.Some.Some"><span class="name type">Some</span></span>&ensp;<span class="boundvar">k</span>)</code></dt><dd><pre>  *O(n)*. Return all keys of the map in ascending order.<br>  <br>  ```<br>  keys (fromList [k1 :=&gt; v1, k2 :=&gt; v2]) == [k1, k2]<br>  keys empty == []<br>  ```</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.map"><code><a class="type" href="Data.DMap.html#Data.DMap.map"><span class="name function">map</span></a>&ensp;:&ensp;(<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">g</span>&ensp;<span class="boundvar">v</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">g</span></code></dt><dd><pre>  *O(n)*. Map a function over all values in the map.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.ffor"><code><a class="type" href="Data.DMap.html#Data.DMap.ffor"><span class="name function">ffor</span></a>&ensp;:&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">g</span>&ensp;<span class="boundvar">v</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">g</span></code></dt><dd><pre>  *O(n)*.<br>  `&apos;ffor&apos; == &apos;flip&apos; &apos;map&apos;` except we cannot actually use<br>  &apos;flip&apos; because of the lack of impredicative types.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.mapWithKey"><code><a class="type" href="Data.DMap.html#Data.DMap.mapWithKey"><span class="name function">mapWithKey</span></a>&ensp;:&ensp;(<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">g</span>&ensp;<span class="boundvar">v</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">g</span></code></dt><dd><pre>  *O(n)*. Map a function over all values in the map.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.fforWithKey"><code><a class="type" href="Data.DMap.html#Data.DMap.fforWithKey"><span class="name function">fforWithKey</span></a>&ensp;:&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">g</span>&ensp;<span class="boundvar">v</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">g</span></code></dt><dd><pre>  *O(n)*.<br>  `&apos;fforWithKey&apos; == &apos;flip&apos; &apos;mapWithKey&apos;` except we cannot actually use<br>  &apos;flip&apos; because of the lack of impredicative types.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.traverseWithKey_"><code><a class="type" href="Data.DMap.html#Data.DMap.traverseWithKey_"><span class="name function">traverseWithKey_</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Interfaces.Applicative"><span class="name type">Applicative</span></span>&ensp;<span class="boundvar">t</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">t</span>&ensp;())&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">t</span>&ensp;()</code></dt><dd><pre>  *O(n)*.<br>  `&apos;traverseWithKey&apos; f m == &apos;fromList&apos; &lt;$&gt; &apos;traverse&apos; (\(k, v) -&gt; (,) k &lt;$&gt; f k v) (&apos;toList&apos; m)`<br>  That is, behaves exactly like a regular &apos;traverse&apos; except that the traversing<br>  function also has access to the key associated with a value.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.forWithKey_"><code><a class="type" href="Data.DMap.html#Data.DMap.forWithKey_"><span class="name function">forWithKey_</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Interfaces.Applicative"><span class="name type">Applicative</span></span>&ensp;<span class="boundvar">t</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">t</span>&ensp;())&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">t</span>&ensp;()</code></dt><dd><pre>  *O(n)*.<br>  `&apos;forWithKey&apos; == &apos;flip&apos; &apos;traverseWithKey&apos;` except we cannot actually use<br>  &apos;flip&apos; because of the lack of impredicative types.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.traverseWithKey"><code><a class="type" href="Data.DMap.html#Data.DMap.traverseWithKey"><span class="name function">traverseWithKey</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Interfaces.Applicative"><span class="name type">Applicative</span></span>&ensp;<span class="boundvar">t</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">t</span>&ensp;(<span class="boundvar">g</span>&ensp;<span class="boundvar">v</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">t</span>&ensp;(<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">g</span>)</code></dt><dd><pre>  *O(n)*.<br>  `&apos;traverseWithKey&apos; f m == &apos;fromList&apos; &lt;$&gt; &apos;traverse&apos; (\(k, v) -&gt; (,) k &lt;$&gt; f k v) (&apos;toList&apos; m)`<br>  That is, behaves exactly like a regular &apos;traverse&apos; except that the traversing<br>  function also has access to the key associated with a value.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.forWithKey"><code><a class="type" href="Data.DMap.html#Data.DMap.forWithKey"><span class="name function">forWithKey</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Interfaces.Applicative"><span class="name type">Applicative</span></span>&ensp;<span class="boundvar">t</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">t</span>&ensp;(<span class="boundvar">g</span>&ensp;<span class="boundvar">v</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">t</span>&ensp;(<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">g</span>)</code></dt><dd><pre>  *O(n)*.<br>  `&apos;forWithKey&apos; == &apos;flip&apos; &apos;traverseWithKey&apos;` except we cannot actually use<br>  &apos;flip&apos; because of the lack of impredicative types.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.mapAccumLWithKey"><code><a class="type" href="Data.DMap.html#Data.DMap.mapAccumLWithKey"><span class="name function">mapAccumLWithKey</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">a</span>,&ensp;<span class="boundvar">g</span>&ensp;<span class="boundvar">v</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">a</span>,&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">g</span>)</code></dt><dd><pre>  *O(n)*. The function &apos;mapAccumLWithKey&apos; threads an accumulating<br>  argument through the map in ascending order of keys.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.mapAccumRWithKey"><code><a class="type" href="Data.DMap.html#Data.DMap.mapAccumRWithKey"><span class="name function">mapAccumRWithKey</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">a</span>,&ensp;<span class="boundvar">g</span>&ensp;<span class="boundvar">v</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">a</span>,&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">g</span>)</code></dt><dd><pre>  *O(n)*. The function &apos;mapAccumRWithKey&apos; threads an accumulating<br>  argument through the map in descending order of keys.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.mapKeysWith"><code><a class="type" href="Data.DMap.html#Data.DMap.mapKeysWith"><span class="name function">mapKeysWith</span></a>&ensp;:&ensp;<span class="type resolved" title="Data.DOrd.DOrd"><span class="name type">DOrd</span></span>&ensp;<span class="boundvar">k2</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">k2</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">k1</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">k2</span>&ensp;<span class="boundvar">v</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k1</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k2</span>&ensp;<span class="boundvar">f</span></code></dt><dd><pre>  *O(n*log n)*.<br>  `&apos;mapKeysWith&apos; c f s` is the map obtained by applying `f` to each key of `s`.<br>  <br>  The size of the result may be smaller if `f` maps two or more distinct<br>  keys to the same new key.  In this case the associated values will be<br>  combined using `c`.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.mapKeysMonotonic"><code><a class="type" href="Data.DMap.html#Data.DMap.mapKeysMonotonic"><span class="name function">mapKeysMonotonic</span></a>&ensp;:&ensp;(<span class="boundvar">k1</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">k2</span>&ensp;<span class="boundvar">v</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k1</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k2</span>&ensp;<span class="boundvar">f</span></code></dt><dd><pre>  *O(n)*.<br>  `&apos;mapKeysMonotonic&apos; f s == &apos;mapKeys&apos; f s`, but works only when `f`<br>  is strictly monotonic.<br>  That is, for any values `x` and `y`, if `x` &lt; `y` then `f x` &lt; `f y`.<br>  *The precondition is not checked.*<br>  Semi-formally, we have:<br>  <br>  ```<br>  and [x &lt; y ==&gt; f x &lt; f y | x &lt;- ls, y &lt;- ls]<br>                      ==&gt; mapKeysMonotonic f s == mapKeys f s<br>      where ls = keys s<br>  ```<br>  <br>  This means that `f` maps distinct original keys to distinct resulting keys.<br>  This function has better performance than &apos;mapKeys&apos;.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.showTreeWith"><code><a class="type" href="Data.DMap.html#Data.DMap.showTreeWith"><span class="name function">showTreeWith</span></a>&ensp;:&ensp;(<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">String</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">String</span></code></dt><dd><pre>  *O(n)*. The expression (`&apos;showTreeWith&apos; showelem hang wide map`) shows<br>  the tree that implements the map. Elements are shown using the `showElem` function. If `hang` is<br>  &apos;True&apos;, a *hanging* tree is shown otherwise a rotated tree is shown. If<br>  `wide` is &apos;True&apos;, an extra wide version is shown.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.showTree"><code><a class="type" href="Data.DMap.html#Data.DMap.showTree"><span class="name function">showTree</span></a>&ensp;:&ensp;<span class="type resolved" title="Data.DShow.DShow"><span class="name type">DShow</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Data.DShow.DShow"><span class="name type">DShow</span></span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">String</span></code></dt><dd><pre>  *O(n)*. Show the tree that implements the map. The tree is shown<br>  in a compressed, hanging format. See &apos;showTreeWith&apos;.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.valid"><code><a class="type" href="Data.DMap.html#Data.DMap.valid"><span class="name function">valid</span></a>&ensp;:&ensp;<span class="type resolved" title="Data.DOrd.DOrd"><span class="name type">DOrd</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span></code></dt><dd><pre>  *O(n)*. Test if the internal map structure is valid.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.DMap.genDMap"><code><a class="type" href="Data.DMap.html#Data.DMap.genDMap"><span class="name function">genDMap</span></a>&ensp;:&ensp;<span class="type resolved" title="Data.DOrd.DOrd"><span class="name type">DOrd</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Hedgehog.Internal.Range.Range"><span class="name type">Range</span></span>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Hedgehog.Internal.Gen.Gen"><span class="name type">Gen</span></span>&ensp;(<span class="type resolved" title="Data.DSum.DSum"><span class="name type">DSum</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Hedgehog.Internal.Gen.Gen"><span class="name type">Gen</span></span>&ensp;(<a class="type" href="Data.DMap.html#Data.DMap.DMap"><span class="name type">DMap</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>)</code></dt><dd><pre>  Generates a map using a &apos;Range&apos; to determine the size.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd></dl></div><footer>Produced by Idris 2 version 0.7.0-da352d8ed</footer></body></html>
