<!DOCTYPE html><html lang="en">

<head>
  <meta charset="utf-8">
  <title>Multiplate</title>
  <link rel="stylesheet" type="text/css" id="preferredStyle" href="../default.css">
  <script>
    /* Updates the stylesheet to use the preferred one.
       Note that we set the link to root ++ sourceLoc because the config
       is shared across the whole website, so the root may differ from
       page to page.
    */
    function setStyleSource (sourceLoc) {
      document.getElementById("preferredStyle").href = "../" + sourceLoc + ".css";
      document.getElementById("selectPreferredStyle").value = sourceLoc;
    }
    /* Initialises the preferred style sheet:
       1. if there is a stored value then use that
          otherwise select the default
       2. set both the css link href & the drop down menu selected option
    */
    function initStyleSource () {
      var preferredStyle = localStorage.getItem("stylefile");
      if (preferredStyle !== null) {
        setStyleSource(preferredStyle);
      } else {
        setStyleSource("default");
      };
    }
    function saveStyleSource (preferredStyle) {
      localStorage.stylefile = preferredStyle;
    }
    </script>
</head>

<body class="namespace">
<header>
  <strong>Idris2Doc</strong> : Multiplate
  <nav><a href="../index.html">Index</a>

  <select id="selectPreferredStyle">
    <option value="default">Default</option>
<option value="alternative">Alternative</option>
<option value="blackandwhite">Black & White</option>

  </select>
  </nav>

  <script>
  /* We start by initialising the style source */
  initStyleSource();

  /* This listens for changes on the drop down menu and updates the
     css used for the current page when a selection is made.
  */
  document.getElementById("selectPreferredStyle").addEventListener("change", function(){
    var selected = this.options[this.selectedIndex].value; /* the option chosen */
    setStyleSource (selected);
    saveStyleSource (selected);
  });
</script>

</header>
<div class="container"><div id="module-header"><h1>Multiplate</h1><span style="float:right">(<a href="Multiplate.src.html">source</a>)</span><pre>Multiplate allows for traversals over mutually recursive data types,
while removing a lot of the boilerplate.

After writting some initial boilerplate, you can write much shorter
and clearer transformations, as you don&apos;t need to manually recurse on each subterm.
</pre></div><code></code><h2>Definitions</h2><dl class="decls"><dt id="Multiplate.Projector"><code><span class="keyword">0</span>&ensp;<a class="type" href="Multiplate.html#Multiplate.Projector"><span class="name function">Projector</span></a>&ensp;:&ensp;((<span class="name type">Type</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd><pre>  A projector represents a field of a plate</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Multiplate.Multiplate"><code><span class="keyword">interface</span>&ensp;<a class="type" href="Multiplate.html#Multiplate.Multiplate"><span class="name type">Multiplate</span></a>&ensp;:&ensp;((<span class="name type">Type</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd><pre>  A plate is represents a set of applicative transforms over a type<br>  where each transform can be applied to sub-nodes of the type.<br>  <br>  Additionally new plates can be built from a function<br>  which is generic over the type of nodes.<br>  <br>  This works fine with indexed data types -<br>  see `tests/Multiplate/Tests/DeBruijn.idr` for an expression using De Bruijn indexes.<br>  You may need to beta-expand in the definition of `mkPlate` (ie change `build expr` to `build (\p =&gt; expr p)`)<br>  <br>  @ p a plate parametised by an applicative functor</pre><br>  <b>Parameters</b>:&ensp;p<br><b>Methods</b>:<br><dl class="decls">  <dt id="Multiplate.multiplate"><code><a class="type" href="Multiplate.html#Multiplate.multiplate"><span class="name function">multiplate</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Interfaces.Applicative"><span class="name type">Applicative</span></span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">f</span></code></dt><dd><pre>  Take a plate and return a new plate,<br>  which applies each transform in the old plate<br>  to the direct children of each node.</pre></dd>  <dt id="Multiplate.mkPlate"><code><a class="type" href="Multiplate.html#Multiplate.mkPlate"><span class="name function">mkPlate</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Interfaces.Applicative"><span class="name type">Applicative</span></span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<a class="type" href="Multiplate.html#Multiplate.Projector"><span class="name function">Projector</span></a>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">f</span></code></dt><dd><pre>  Create a plate using a generic projector function</pre></dd></dl><br><b>Implementation</b>:&ensp;<dl class="decls"><dt id="$resolved360"><code><a class="type" href="Multiplate.html#Multiplate.HasProjection"><span class="name type">HasProjection</span></a>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Multiplate.html#Multiplate.Multiplate"><span class="name type">Multiplate</span></a>&ensp;<span class="boundvar">p</span></code></dt></dl></dd><dt id="Multiplate.multiplate"><code><a class="type" href="Multiplate.html#Multiplate.multiplate"><span class="name function">multiplate</span></a>&ensp;:&ensp;<a class="type" href="Multiplate.html#Multiplate.Multiplate"><span class="name type">Multiplate</span></a>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.Interfaces.Applicative"><span class="name type">Applicative</span></span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">f</span></code></dt><dd><pre>  Take a plate and return a new plate,<br>  which applies each transform in the old plate<br>  to the direct children of each node.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Multiplate.mkPlate"><code><a class="type" href="Multiplate.html#Multiplate.mkPlate"><span class="name function">mkPlate</span></a>&ensp;:&ensp;<a class="type" href="Multiplate.html#Multiplate.Multiplate"><span class="name type">Multiplate</span></a>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.Interfaces.Applicative"><span class="name type">Applicative</span></span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<a class="type" href="Multiplate.html#Multiplate.Projector"><span class="name function">Projector</span></a>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">f</span></code></dt><dd><pre>  Create a plate using a generic projector function</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Multiplate.purePlate"><code><a class="type" href="Multiplate.html#Multiplate.purePlate"><span class="name function">purePlate</span></a>&ensp;:&ensp;<a class="type" href="Multiplate.html#Multiplate.Multiplate"><span class="name type">Multiplate</span></a>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.Interfaces.Applicative"><span class="name type">Applicative</span></span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">f</span></code></dt><dd><pre>  A plate which &apos;does nothing&apos; ie applies `pure` to each node.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Multiplate.applyNaturalTransform"><code><a class="type" href="Multiplate.html#Multiplate.applyNaturalTransform"><span class="name function">applyNaturalTransform</span></a>&ensp;:&ensp;<a class="type" href="Multiplate.html#Multiplate.Multiplate"><span class="name type">Multiplate</span></a>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.Interfaces.Applicative"><span class="name type">Applicative</span></span>&ensp;<span class="boundvar">g</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">g</span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">g</span></code></dt><dd><pre>  Apply a natural transform to a plate</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Multiplate.fromIdentity"><code><a class="type" href="Multiplate.html#Multiplate.fromIdentity"><span class="name function">fromIdentity</span></a>&ensp;:&ensp;<a class="type" href="Multiplate.html#Multiplate.Multiplate"><span class="name type">Multiplate</span></a>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.Interfaces.Applicative"><span class="name type">Applicative</span></span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="type resolved" title="Control.Monad.Identity.Identity"><span class="name type">Identity</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">f</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Multiplate.andThenM"><code><a class="type" href="Multiplate.html#Multiplate.andThenM"><span class="name function">andThenM</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Interfaces.Monad"><span class="name type">Monad</span></span>&ensp;<span class="boundvar">m</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Multiplate.html#Multiplate.Multiplate"><span class="name type">Multiplate</span></a>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=&gt;</span>&ensp;Lazy&ensp;(<span class="boundvar">p</span>&ensp;<span class="boundvar">m</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;Lazy&ensp;(<span class="boundvar">p</span>&ensp;<span class="boundvar">m</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">m</span></code></dt><dd><pre>  Compose 2 plates, by applying them from left to right.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span><br>  <b>Fixity Declaration</b>:&ensp;infixl&ensp;operator,&ensp;level&ensp;5</dd><dt id="Multiplate.andThenId"><code><a class="type" href="Multiplate.html#Multiplate.andThenId"><span class="name function">andThenId</span></a>&ensp;:&ensp;<a class="type" href="Multiplate.html#Multiplate.Multiplate"><span class="name type">Multiplate</span></a>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.Interfaces.Applicative"><span class="name type">Applicative</span></span>&ensp;<span class="boundvar">m</span>&ensp;<span class="keyword">=&gt;</span>&ensp;Lazy&ensp;(<span class="boundvar">p</span>&ensp;<span class="boundvar">m</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;Lazy&ensp;(<span class="boundvar">p</span>&ensp;<span class="type resolved" title="Control.Monad.Identity.Identity"><span class="name type">Identity</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">m</span></code></dt><dd><pre>  Compose 2 plates, where the second is based on the identity functor</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span><br>  <b>Fixity Declaration</b>:&ensp;infixl&ensp;operator,&ensp;level&ensp;5</dd><dt id="Multiplate.idAndThen"><code><a class="type" href="Multiplate.html#Multiplate.idAndThen"><span class="name function">idAndThen</span></a>&ensp;:&ensp;<a class="type" href="Multiplate.html#Multiplate.Multiplate"><span class="name type">Multiplate</span></a>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.Interfaces.Applicative"><span class="name type">Applicative</span></span>&ensp;<span class="boundvar">m</span>&ensp;<span class="keyword">=&gt;</span>&ensp;Lazy&ensp;(<span class="boundvar">p</span>&ensp;<span class="type resolved" title="Control.Monad.Identity.Identity"><span class="name type">Identity</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;Lazy&ensp;(<span class="boundvar">p</span>&ensp;<span class="boundvar">m</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">m</span></code></dt><dd><pre>  Compose 2 plates, where the first is based on the identity functor</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Multiplate.orElse"><code><a class="type" href="Multiplate.html#Multiplate.orElse"><span class="name function">orElse</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Interfaces.Alternative"><span class="name type">Alternative</span></span>&ensp;<span class="boundvar">m</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Multiplate.html#Multiplate.Multiplate"><span class="name type">Multiplate</span></a>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=&gt;</span>&ensp;Lazy&ensp;(<span class="boundvar">p</span>&ensp;<span class="boundvar">m</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;Lazy&ensp;(<span class="boundvar">p</span>&ensp;<span class="boundvar">m</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">m</span></code></dt><dd><pre>  Compose 2 plates, by trying the first and then the second</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span><br>  <b>Fixity Declaration</b>:&ensp;infixr&ensp;operator,&ensp;level&ensp;4</dd><dt id="Multiplate.postorderMap"><code><a class="type" href="Multiplate.html#Multiplate.postorderMap"><span class="name function">postorderMap</span></a>&ensp;:&ensp;<a class="type" href="Multiplate.html#Multiplate.Multiplate"><span class="name type">Multiplate</span></a>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.Interfaces.Monad"><span class="name type">Monad</span></span>&ensp;<span class="boundvar">m</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">m</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">m</span></code></dt><dd><pre>  Apply a transformation to the whole family of a node.<br>  This happens in a post-order, ie children are mapped before parents.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Multiplate.preorderMap"><code><a class="type" href="Multiplate.html#Multiplate.preorderMap"><span class="name function">preorderMap</span></a>&ensp;:&ensp;<a class="type" href="Multiplate.html#Multiplate.Multiplate"><span class="name type">Multiplate</span></a>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.Interfaces.Monad"><span class="name type">Monad</span></span>&ensp;<span class="boundvar">m</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">m</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">m</span></code></dt><dd><pre>  Apply a transformation to the whole family of a node.<br>  This happens in a pre-order, ie parents are mapped before children.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Multiplate.append"><code><a class="type" href="Multiplate.html#Multiplate.append"><span class="name function">append</span></a>&ensp;:&ensp;<a class="type" href="Multiplate.html#Multiplate.Multiplate"><span class="name type">Multiplate</span></a>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.Interfaces.Monoid"><span class="name type">Monoid</span></span>&ensp;<span class="boundvar">o</span>&ensp;<span class="keyword">=&gt;</span>&ensp;Lazy&ensp;(<span class="boundvar">p</span>&ensp;(<span class="type resolved" title="Control.Applicative.Const.Const"><span class="name type">Const</span></span>&ensp;<span class="boundvar">o</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;Lazy&ensp;(<span class="boundvar">p</span>&ensp;(<span class="type resolved" title="Control.Applicative.Const.Const"><span class="name type">Const</span></span>&ensp;<span class="boundvar">o</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;(<span class="type resolved" title="Control.Applicative.Const.Const"><span class="name type">Const</span></span>&ensp;<span class="boundvar">o</span>)</code></dt><dd><pre>  Append the result of 2 plates which each return `Const`</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Multiplate.preorderFold"><code><a class="type" href="Multiplate.html#Multiplate.preorderFold"><span class="name function">preorderFold</span></a>&ensp;:&ensp;<a class="type" href="Multiplate.html#Multiplate.Multiplate"><span class="name type">Multiplate</span></a>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.Interfaces.Monoid"><span class="name type">Monoid</span></span>&ensp;<span class="boundvar">o</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;(<span class="type resolved" title="Control.Applicative.Const.Const"><span class="name type">Const</span></span>&ensp;<span class="boundvar">o</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;(<span class="type resolved" title="Control.Applicative.Const.Const"><span class="name type">Const</span></span>&ensp;<span class="boundvar">o</span>)</code></dt><dd><pre>  Apply a fold to the whole family of a node.<br>  This applies to the parent node, followed by children.<br>  <br>  The result, when applied to `x` looks like:<br>  ```<br>  x<br>      &lt;+&gt; children x<br>      &lt;+&gt; grandchildren x<br>      ...<br>  ```</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Multiplate.postorderFold"><code><a class="type" href="Multiplate.html#Multiplate.postorderFold"><span class="name function">postorderFold</span></a>&ensp;:&ensp;<a class="type" href="Multiplate.html#Multiplate.Multiplate"><span class="name type">Multiplate</span></a>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.Interfaces.Monoid"><span class="name type">Monoid</span></span>&ensp;<span class="boundvar">o</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;(<span class="type resolved" title="Control.Applicative.Const.Const"><span class="name type">Const</span></span>&ensp;<span class="boundvar">o</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;(<span class="type resolved" title="Control.Applicative.Const.Const"><span class="name type">Const</span></span>&ensp;<span class="boundvar">o</span>)</code></dt><dd><pre>  Apply a fold to the whole family of a node.<br>  This applies to the children, followed by the parent node.<br>  <br>  The result when applied to `x` looks like:<br>  ```<br>  ...<br>      &lt;+&gt; grandchildren x<br>      &lt;+&gt; children x<br>      &lt;+&gt; x</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Multiplate.catchWith"><code><a class="type" href="Multiplate.html#Multiplate.catchWith"><span class="name function">catchWith</span></a>&ensp;:&ensp;<a class="type" href="Multiplate.html#Multiplate.Multiplate"><span class="name type">Multiplate</span></a>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.Interfaces.Applicative"><span class="name type">Applicative</span></span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">f</span></code></dt><dd><pre>  Remove a `Maybe` from a transformation by providing a plate which generates a default value.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Multiplate.catch"><code><a class="type" href="Multiplate.html#Multiplate.catch"><span class="name function">catch</span></a>&ensp;:&ensp;<a class="type" href="Multiplate.html#Multiplate.Multiplate"><span class="name type">Multiplate</span></a>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.Interfaces.Applicative"><span class="name type">Applicative</span></span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">f</span></code></dt><dd><pre>  Remove a `Maybe` from a transformation by returning the original value unaltered.<br>  <br>  This is equivalent to `catchWith purePlate`</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Multiplate.HasProjection"><code><span class="keyword">interface</span>&ensp;<a class="type" href="Multiplate.html#Multiplate.HasProjection"><span class="name type">HasProjection</span></a>&ensp;:&ensp;((<span class="name type">Type</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd><pre>  Plates tend to consist of a fixed set of fields.<br>  This interface allows for projecting the transform of @ a.<br>  <br>  @ p the plate<br>  @ a the field</pre><br>  <b>Parameters</b>:&ensp;p,&ensp;a<br><b>Constraints</b>:&ensp;Multiplate&ensp;p<br><b>Methods</b>:<br><dl class="decls">  <dt id="Multiplate.project"><code><a class="type" href="Multiplate.html#Multiplate.project"><span class="name function">project</span></a>&ensp;:&ensp;<a class="type" href="Multiplate.html#Multiplate.Projector"><span class="name function">Projector</span></a>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Project a transform of a specific field out of a plate.</pre></dd></dl><br><b>Implementation</b>:&ensp;<dl class="decls"><dt id="$resolved361"><code><a class="type" href="Multiplate.html#Multiplate.HasField"><span class="name type">HasField</span></a>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Multiplate.html#Multiplate.HasProjection"><span class="name type">HasProjection</span></a>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">a</span></code></dt></dl></dd><dt id="Multiplate.project"><code><a class="type" href="Multiplate.html#Multiplate.project"><span class="name function">project</span></a>&ensp;:&ensp;<a class="type" href="Multiplate.html#Multiplate.HasProjection"><span class="name type">HasProjection</span></a>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Multiplate.html#Multiplate.Projector"><span class="name function">Projector</span></a>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Project a transform of a specific field out of a plate.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Multiplate.traverseFor"><code><a class="type" href="Multiplate.html#Multiplate.traverseFor"><span class="name function">traverseFor</span></a>&ensp;:&ensp;<a class="type" href="Multiplate.html#Multiplate.HasProjection"><span class="name type">HasProjection</span></a>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="type resolved" title="Control.Monad.Identity.Identity"><span class="name type">Identity</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Run a transformation in the identity monad.<br>  <br>  To run transforms in a different Monad use `project`</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Multiplate.foldFor"><code><a class="type" href="Multiplate.html#Multiplate.foldFor"><span class="name function">foldFor</span></a>&ensp;:&ensp;<a class="type" href="Multiplate.html#Multiplate.HasProjection"><span class="name type">HasProjection</span></a>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;(<span class="type resolved" title="Control.Applicative.Const.Const"><span class="name type">Const</span></span>&ensp;<span class="boundvar">o</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">o</span></code></dt><dd><pre>  Run a fold</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Multiplate.HasField"><code><span class="keyword">interface</span>&ensp;<a class="type" href="Multiplate.html#Multiplate.HasField"><span class="name type">HasField</span></a>&ensp;:&ensp;((<span class="name type">Type</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd><pre>  Plates tend to consist of a fixed set of fields.<br>  In addition to being able to project a field,<br>  this interface allows for creating a plate from a transform.<br>  <br>  This is seperate from `HasProjection` as it is typically not<br>  possible to implement for plates with indexed data types.<br>  <br>  @ p the plate<br>  @ a the field</pre><br>  <b>Parameters</b>:&ensp;p,&ensp;a<br><b>Constraints</b>:&ensp;HasProjection&ensp;p&ensp;a<br><b>Methods</b>:<br><dl class="decls">  <dt id="Multiplate.inject"><code><a class="type" href="Multiplate.html#Multiplate.inject"><span class="name function">inject</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Interfaces.Applicative"><span class="name type">Applicative</span></span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">f</span></code></dt><dd><pre>  Inject a transform to create a new plate,<br>  by filling in other transforms with `pure`.</pre></dd>  <dt id="Multiplate.update"><code><a class="type" href="Multiplate.html#Multiplate.update"><span class="name function">update</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">f</span></code></dt><dd><pre>  Update the transform of a given field,<br>  by replacing it with a new transform.</pre></dd></dl></dd><dt id="Multiplate.inject"><code><a class="type" href="Multiplate.html#Multiplate.inject"><span class="name function">inject</span></a>&ensp;:&ensp;<a class="type" href="Multiplate.html#Multiplate.HasField"><span class="name type">HasField</span></a>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.Interfaces.Applicative"><span class="name type">Applicative</span></span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">f</span></code></dt><dd><pre>  Inject a transform to create a new plate,<br>  by filling in other transforms with `pure`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Multiplate.update"><code><a class="type" href="Multiplate.html#Multiplate.update"><span class="name function">update</span></a>&ensp;:&ensp;<a class="type" href="Multiplate.html#Multiplate.HasField"><span class="name type">HasField</span></a>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">f</span></code></dt><dd><pre>  Update the transform of a given field,<br>  by replacing it with a new transform.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Multiplate.injectPure"><code><a class="type" href="Multiplate.html#Multiplate.injectPure"><span class="name function">injectPure</span></a>&ensp;:&ensp;<a class="type" href="Multiplate.html#Multiplate.HasField"><span class="name type">HasField</span></a>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.Interfaces.Applicative"><span class="name type">Applicative</span></span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">f</span></code></dt><dd><pre>  Inject a pure transformation into a plate.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd></dl></div><footer>Produced by Idris 2 version 0.7.0-da352d8ed</footer></body></html>
