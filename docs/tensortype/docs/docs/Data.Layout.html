<!DOCTYPE html><html lang="en">

<head>
  <meta charset="utf-8">
  <title>Data.Layout</title>
  <link rel="stylesheet" type="text/css" id="preferredStyle" href="../default.css">
  <script>
    /* Updates the stylesheet to use the preferred one.
       Note that we set the link to root ++ sourceLoc because the config
       is shared across the whole website, so the root may differ from
       page to page.
    */
    function setStyleSource (sourceLoc) {
      document.getElementById("preferredStyle").href = "../" + sourceLoc + ".css";
      document.getElementById("selectPreferredStyle").value = sourceLoc;
    }
    /* Initialises the preferred style sheet:
       1. if there is a stored value then use that
          otherwise select the default
       2. set both the css link href & the drop down menu selected option
    */
    function initStyleSource () {
      var preferredStyle = localStorage.getItem("stylefile");
      if (preferredStyle !== null) {
        setStyleSource(preferredStyle);
      } else {
        setStyleSource("default");
      };
    }
    function saveStyleSource (preferredStyle) {
      localStorage.stylefile = preferredStyle;
    }
    </script>
</head>

<body class="namespace">
<header>
  <strong>Idris2Doc</strong> : Data.Layout
  <nav><a href="../index.html">Index</a>

  <select id="selectPreferredStyle">
    <option value="default">Default</option>
<option value="alternative">Alternative</option>
<option value="blackandwhite">Black & White</option>

  </select>
  </nav>

  <script>
  /* We start by initialising the style source */
  initStyleSource();

  /* This listens for changes on the drop down menu and updates the
     css used for the current page when a selection is made.
  */
  document.getElementById("selectPreferredStyle").addEventListener("change", function(){
    var selected = this.options[this.selectedIndex].value; /* the option chosen */
    setStyleSource (selected);
    saveStyleSource (selected);
  });
</script>

</header>
<div class="container"><div id="module-header"><h1>Data.Layout</h1><span style="float:right">(<a href="Data.Layout.src.html">source</a>)</span><pre></pre></div><code></code><h2>Definitions</h2><dl class="decls"><dt id="Data.Layout.LayoutOrder"><code><span class="keyword">data</span>&ensp;<a class="type" href="Data.Layout.html#Data.Layout.LayoutOrder"><span class="name type">LayoutOrder</span></a>&ensp;:&ensp;<span class="name type">Type</span></code></dt><dd><pre>  We often deal with the &apos;logical&apos; representation of tensors, but for<br>  performance characteristics we need to be cognisant of how these tensors<br>  are stored in the physical memory, which is in 1D linear order.<br>  There are two options: row-major and column-major format<br>  NumPy, PyTorch, TensorFlow and JAX use row-major indexing<br>  The idea is that once linearised:<br>  - row-major the last index of the array varies fastest<br>  - column-major the first index of the array varies fastest</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span><br>  <b>Constructors</b>:<br><dl class="decls">  <dt id="Data.Layout.RowMajor"><code><a class="type" href="Data.Layout.html#Data.Layout.RowMajor"><span class="name constructor">RowMajor</span></a>&ensp;:&ensp;<a class="type" href="Data.Layout.html#Data.Layout.LayoutOrder"><span class="name type">LayoutOrder</span></a></code></dt>  <dt id="Data.Layout.ColumnMajor"><code><a class="type" href="Data.Layout.html#Data.Layout.ColumnMajor"><span class="name constructor">ColumnMajor</span></a>&ensp;:&ensp;<a class="type" href="Data.Layout.html#Data.Layout.LayoutOrder"><span class="name type">LayoutOrder</span></a></code></dt></dl><br>  <b>Hints</b>:<br><dl class="decls">  <dt id="$resolved8831"><code><span class="type resolved" title="Prelude.EqOrd.Eq"><span class="name type">Eq</span></span>&ensp;<a class="type" href="Data.Layout.html#Data.Layout.LayoutOrder"><span class="name type">LayoutOrder</span></a></code></dt>  <dt id="$resolved8830"><code><span class="type resolved" title="Prelude.Show.Show"><span class="name type">Show</span></span>&ensp;<a class="type" href="Data.Layout.html#Data.Layout.LayoutOrder"><span class="name type">LayoutOrder</span></a></code></dt></dl></dd><dt id="Data.Layout.DefaultLayoutOrder"><code><a class="type" href="Data.Layout.html#Data.Layout.DefaultLayoutOrder"><span class="name function">DefaultLayoutOrder</span></a>&ensp;:&ensp;<a class="type" href="Data.Layout.html#Data.Layout.LayoutOrder"><span class="name type">LayoutOrder</span></a></code></dt><dd><pre>  Following most popular conventions, we use row-major ordering by default</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.Layout.splitFinProd"><code><a class="type" href="Data.Layout.html#Data.Layout.splitFinProd"><span class="name function">splitFinProd</span></a>&ensp;:&ensp;<a class="type" href="Data.Layout.html#Data.Layout.LayoutOrder"><span class="name type">LayoutOrder</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Data.Fin.Fin"><span class="name type">Fin</span></span>&ensp;(<span class="boundvar">m</span>&ensp;<span class="type resolved" title="Prelude.Num.(*)"><span class="name function">*</span></span>&ensp;<span class="boundvar">n</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="type resolved" title="Data.Fin.Fin"><span class="name type">Fin</span></span>&ensp;<span class="boundvar">m</span>,&ensp;<span class="type resolved" title="Data.Fin.Fin"><span class="name type">Fin</span></span>&ensp;<span class="boundvar">n</span>)</code></dt><dd><pre>  Layout-aware version of splitProd from Data.Fin.Split.<br>  <br>  Row-major (splitProd): index k in a m&#215;n matrix maps to (k/n, k%n)<br>    - goes through all columns before moving to next row<br>  Column-major (splitProdColumnMajor): index k maps to (k%m, k/m)  <br>    - goes through all rows before moving to next column<br>  <br>  For a 2&#215;3 matrix:<br>    Row-major order:    (0,0), (0,1), (0,2), (1,0), (1,1), (1,2)<br>    Column-major order: (0,0), (1,0), (0,1), (1,1), (0,2), (1,2)</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.Layout.indexFinProd"><code><a class="type" href="Data.Layout.html#Data.Layout.indexFinProd"><span class="name function">indexFinProd</span></a>&ensp;:&ensp;<a class="type" href="Data.Layout.html#Data.Layout.LayoutOrder"><span class="name type">LayoutOrder</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Data.Fin.Fin"><span class="name type">Fin</span></span>&ensp;<span class="boundvar">m</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Data.Fin.Fin"><span class="name type">Fin</span></span>&ensp;<span class="boundvar">n</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Data.Fin.Fin"><span class="name type">Fin</span></span>&ensp;(<span class="boundvar">m</span>&ensp;<span class="type resolved" title="Prelude.Num.(*)"><span class="name function">*</span></span>&ensp;<span class="boundvar">n</span>)</code></dt><dd><pre>  Layout-aware version of indexProd from Data.Fin.Split.<br>  Inverse of splitFinProd: given (row, col) indices, compute linear index.<br>  <br>  Row-major: linear index = row * n + col<br>  Column-major: linear index = col * m + row<br>  <br>  For a 2&#215;3 matrix with (row=1, col=2):<br>    Row-major:    1 * 3 + 2 = 5<br>    Column-major: 2 * 2 + 1 = 5</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.Layout.splitShape"><code><a class="type" href="Data.Layout.html#Data.Layout.splitShape"><span class="name function">splitShape</span></a>&ensp;:&ensp;<a class="type" href="Data.Layout.html#Data.Layout.LayoutOrder"><span class="name type">LayoutOrder</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Data.Fin.Fin"><span class="name type">Fin</span></span>&ensp;(<span class="type resolved" title="Prelude.Interfaces.foldr"><span class="name function">foldr</span></span>&ensp;<span class="type resolved" title="Prelude.Num.(*)"><span class="name function">(*)</span></span>&ensp;<span class="name constructor">1</span>&ensp;<span class="boundvar">shape</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Data.List.Quantifiers.All.All"><span class="name type">All</span></span>&ensp;<span class="type resolved" title="Data.Fin.Fin"><span class="name type">Fin</span></span>&ensp;<span class="boundvar">shape</span></code></dt><dd><pre>  Possibly not needed anymore?<br>  Convert a linear index into a multi-dimensional index.<br>  Generalizes splitFinProd to arbitrary dimensions.<br>  <br>  For a tensor of shape [2, 3, 4] with 24 elements:<br>    - Row-major: last dimension varies fastest<br>    - Column-major: first dimension varies fastest<br>  <br>  @ shape the shape of the tensor<br>  @ lo    the memory layout order<br>  @ idx   a linear index into the flattened tensor</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd></dl></div><footer>Produced by Idris 2 version 0.8.0-501346182</footer></body></html>
