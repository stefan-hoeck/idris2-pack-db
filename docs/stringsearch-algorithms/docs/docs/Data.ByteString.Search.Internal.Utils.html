<!DOCTYPE html><html lang="en">

<head>
  <meta charset="utf-8">
  <title>Data.ByteString.Search.Internal.Utils</title>
  <link rel="stylesheet" type="text/css" id="preferredStyle" href="../default.css">
  <script>
    /* Updates the stylesheet to use the preferred one.
       Note that we set the link to root ++ sourceLoc because the config
       is shared across the whole website, so the root may differ from
       page to page.
    */
    function setStyleSource (sourceLoc) {
      document.getElementById("preferredStyle").href = "../" + sourceLoc + ".css";
      document.getElementById("selectPreferredStyle").value = sourceLoc;
    }
    /* Initialises the preferred style sheet:
       1. if there is a stored value then use that
          otherwise select the default
       2. set both the css link href & the drop down menu selected option
    */
    function initStyleSource () {
      var preferredStyle = localStorage.getItem("stylefile");
      if (preferredStyle !== null) {
        setStyleSource(preferredStyle);
      } else {
        setStyleSource("default");
      };
    }
    function saveStyleSource (preferredStyle) {
      localStorage.stylefile = preferredStyle;
    }
    </script>
</head>

<body class="namespace">
<header>
  <strong>Idris2Doc</strong> : Data.ByteString.Search.Internal.Utils
  <nav><a href="../index.html">Index</a>

  <select id="selectPreferredStyle">
    <option value="default">Default</option>
<option value="alternative">Alternative</option>
<option value="blackandwhite">Black & White</option>

  </select>
  </nav>

  <script>
  /* We start by initialising the style source */
  initStyleSource();

  /* This listens for changes on the drop down menu and updates the
     css used for the current page when a selection is made.
  */
  document.getElementById("selectPreferredStyle").addEventListener("change", function(){
    var selected = this.options[this.selectedIndex].value; /* the option chosen */
    setStyleSource (selected);
    saveStyleSource (selected);
  });
</script>

</header>
<div class="container"><div id="module-header"><h1>Data.ByteString.Search.Internal.Utils</h1><span style="float:right">(<a href="Data.ByteString.Search.Internal.Utils.src.html">source</a>)</span><pre>Utilities for string searching algorithms
</pre></div><code></code><h2>Definitions</h2><dl class="decls"><dt id="Data.ByteString.Search.Internal.Utils.kmpBorders"><code><a class="type" href="Data.ByteString.Search.Internal.Utils.html#Data.ByteString.Search.Internal.Utils.kmpBorders"><span class="name function">kmpBorders</span></a>&ensp;:&ensp;(<span class="boundvar">bs</span>&ensp;:&ensp;<span class="type resolved" title="Data.ByteVect.ByteString"><span class="name type">ByteString</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Data.Linear.Token.F1"><span class="name function">F1</span></span>&ensp;<span class="boundvar">s</span>&ensp;(<span class="type resolved" title="Data.Array.Core.MArray"><span class="name type">MArray</span></span>&ensp;<span class="boundvar">s</span>&ensp;(<span class="type resolved" title="Prelude.Types.S"><span class="name constructor">S</span></span>&ensp;(<span class="type resolved" title="Data.ByteString.length"><span class="name function">length</span></span>&ensp;<span class="boundvar">bs</span>))&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)</code></dt><dd><pre>  Computes the suffix-oriented KMP border table for a given pattern.<br>  <br>  Each entry at index i (0 &#8804; i &#8804; length pattern) stores the length of the<br>  longest proper prefix of the prefix pattern[0..i-1] that is also a<br>  suffix. This &#8220;border&#8221; is used to determine how far to backtrack in<br>  pattern matching when a mismatch occurs.<br>  <br>  Unlike the standard KMP table, this table is suffix-oriented and<br>  built in a descending, structurally recursive manner.<br>  <br>  The table helps efficiently skip positions in the pattern during<br>  substring search, while descending from longer prefixes to shorter ones.<br>  <br>  Example: ANPANMAN&quot;<br>  <br>  Indices: 0..8<br>  <br>  Prefixes: &quot;&quot;   &quot;A&quot;   &quot;AN&quot;   &quot;ANP&quot;  &quot;ANPA&quot;  &quot;ANPAN&quot;  &quot;ANPANM&quot;  &quot;ANPANMA&quot;  &quot;ANPANMAN&quot;<br>  Borders:  0    0     0      0      1       2        0         1          2<br>  </pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.ByteString.Search.Internal.Utils.automaton"><code><a class="type" href="Data.ByteString.Search.Internal.Utils.html#Data.ByteString.Search.Internal.Utils.automaton"><span class="name function">automaton</span></a>&ensp;:&ensp;(<span class="boundvar">bs</span>&ensp;:&ensp;<span class="type resolved" title="Data.ByteVect.ByteString"><span class="name type">ByteString</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Data.Linear.Token.F1"><span class="name function">F1</span></span>&ensp;<span class="boundvar">s</span>&ensp;(<span class="type resolved" title="Data.Array.Core.MArray"><span class="name type">MArray</span></span>&ensp;<span class="boundvar">s</span>&ensp;(<span class="type resolved" title="Prelude.Types.mult"><span class="name function">mult</span></span>&ensp;(<span class="type resolved" title="Prelude.Types.plus"><span class="name function">plus</span></span>&ensp;(<span class="type resolved" title="Data.ByteString.length"><span class="name function">length</span></span>&ensp;<span class="boundvar">bs</span>)&ensp;<span class="name constructor">1</span>)&ensp;<span class="name constructor">256</span>)&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)</code></dt><dd><pre>  Builds a deterministic finite automaton (DFA) for pattern matching over a `ByteString`.<br>  <br>  The automaton encodes transitions from (state, input byte) &#8594; next state,<br>  allowing efficient streaming search for the pattern within input data.<br>  <br>  It produces a flattened transition table of size `((length pattern) + 1) * 256`,<br>  where 256 corresponds to all possible byte values (0&#8211;255).<br>  <br>  States correspond to pattern prefixes:<br>  - State 0: no match (empty prefix)<br>  - State i: matched the first i bytes of the pattern<br>  - State (length pattern): full match<br>  <br>  Transition behavior is derived from the KMP border table (`kmpBorders`),<br>  ensuring correct fallback transitions and eliminating redundant backtracking.<br>  <br>  Example: &quot;ANPANMAN&quot;<br>  <br>  These following equation is used to determine the &quot;flat&quot; index to build the automaton:<br>  <br>  flatindex = (state &#8727; alphabetsize) + charcode<br>  <br>  Where:<br>  <br>  state : Range from 0 to length of the input pattern<br>  <br>  alphabetsize : All possible input characters (in this case extended ASCII, 8-bit range from 0 to 255)<br>  <br>  charcode : Characters are interpreted via its ASCII code (&apos;A&apos; = 65, &apos;M&apos; = 77, &apos;N&apos; = 78, &apos;P&apos; = 80, and so on)<br>  <br>  | Flat index | State | Char code | Char | Meaning       |<br>  | ---------- | ----- | --------- | ---- | ------------- |<br>  | 65         | 0     | 65        | &apos;A&apos;  | &#948;(0, &apos;A&apos;) = 1 |<br>  | 321        | 1     | 65        | &apos;A&apos;  | &#948;(1, &apos;A&apos;) = 1 |<br>  | 334        | 1     | 78        | &apos;N&apos;  | &#948;(1, &apos;N&apos;) = 2 |<br>  | 577        | 2     | 65        | &apos;A&apos;  | &#948;(2, &apos;A&apos;) = 1 |<br>  | 592        | 2     | 80        | &apos;P&apos;  | &#948;(2, &apos;P&apos;) = 3 |<br>  | 833        | 3     | 65        | &apos;A&apos;  | &#948;(3, &apos;A&apos;) = 4 |<br>  | 1089       | 4     | 65        | &apos;A&apos;  | &#948;(4, &apos;A&apos;) = 1 |<br>  | 1102       | 4     | 78        | &apos;N&apos;  | &#948;(4, &apos;N&apos;) = 5 |<br>  | 1345       | 5     | 65        | &apos;A&apos;  | &#948;(5, &apos;A&apos;) = 1 |<br>  | 1357       | 5     | 77        | &apos;M&apos;  | &#948;(5, &apos;M&apos;) = 6 |<br>  | 1601       | 6     | 65        | &apos;A&apos;  | &#948;(6, &apos;A&apos;) = 7 |<br>  | 1857       | 7     | 65        | &apos;A&apos;  | &#948;(7, &apos;A&apos;) = 1 |<br>  | 1870       | 7     | 78        | &apos;N&apos;  | &#948;(7, &apos;N&apos;) = 8 |<br>  | 2113       | 8     | 65        | &apos;A&apos;  | &#948;(8, &apos;A&apos;) = 1 |<br>  </pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.ByteString.Search.Internal.Utils.occurrences"><code><a class="type" href="Data.ByteString.Search.Internal.Utils.html#Data.ByteString.Search.Internal.Utils.occurrences"><span class="name function">occurrences</span></a>&ensp;:&ensp;(<span class="boundvar">bs</span>&ensp;:&ensp;<span class="type resolved" title="Data.ByteVect.ByteString"><span class="name type">ByteString</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Data.Linear.Token.F1"><span class="name function">F1</span></span>&ensp;<span class="boundvar">s</span>&ensp;(<span class="type resolved" title="Data.Array.Core.MArray"><span class="name type">MArray</span></span>&ensp;<span class="boundvar">s</span>&ensp;<span class="name constructor">256</span>&ensp;<span class="name type">Int</span>)</code></dt><dd><pre>  Constructs a lookup table recording the last occurrence of each byte<br>  in the given pattern.<br>  <br>  For every byte value, the table stores the index of its last<br>  occurrence within the pattern, excluding the final position.  <br>  <br>  This information allows for efficient computation of how far the search<br>  window can safely shift after a mismatch.<br>  <br>  When a mismatch occurs at pattern position (position in pattern) on byte (b),<br>  the pattern can be shifted right by at least:<br>  <br>  (position in pattern) - (last occurrence of b in initial pattern)<br>  <br>  If the byte b does not appear anywhere in the pattern, the search<br>  window can shift so that the pattern starts immediately after the<br>  mismatched byte, resulting in a default shift of 1.<br>  <br>  This table is typically used in Boyer&#8211;Moore&#8211;style pattern matching<br>  algorithms to determine optimal skip distances after mismatches.<br>  <br>  O((length of pattern) + (alphabet size))<br>  <br>  Example: &quot;ANPANMAN&quot;<br>  <br>  | Flat index / ASCII | char | value |<br>  | ------------------ | ---- | ----- |<br>  |        65          | &apos;A&apos;  |    -6 |<br>  |        77          | &apos;M&apos;  |    -5 |<br>  |        78          | &apos;N&apos;  |    -4 |<br>  |        80          | &apos;P&apos;  |    -2 |<br>  </pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.ByteString.Search.Internal.Utils.suffixLengths"><code><a class="type" href="Data.ByteString.Search.Internal.Utils.html#Data.ByteString.Search.Internal.Utils.suffixLengths"><span class="name function">suffixLengths</span></a>&ensp;:&ensp;(<span class="boundvar">bs</span>&ensp;:&ensp;<span class="type resolved" title="Data.ByteVect.ByteString"><span class="name type">ByteString</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Data.Linear.Token.F1"><span class="name function">F1</span></span>&ensp;<span class="boundvar">s</span>&ensp;(<span class="type resolved" title="Data.Array.Core.MArray"><span class="name type">MArray</span></span>&ensp;<span class="boundvar">s</span>&ensp;(<span class="type resolved" title="Data.ByteString.length"><span class="name function">length</span></span>&ensp;<span class="boundvar">bs</span>)&ensp;<span class="name type">Int</span>)</code></dt><dd><pre>  Builds the table of suffix lengths for the given pattern.<br>  <br>  The value at index `i` is the length of the longest common suffix<br>  between the entire pattern and the prefix of the pattern ending at `i`.<br>  <br>  Typically, most entries are 0. Only when the byte at position `i`<br>  matches the final byte of the pattern can the value be positive.<br>  <br>  The final entry (at `patEnd`) equals the pattern length, since the<br>  pattern is identical to itself. In general, `0 &lt;= ar[i] &lt;= i + 1`.<br>  <br>  To ensure linear preprocessing, the algorithm avoids the naive<br>  quadratic approach by reusing information from previously identified<br>  suffixes.<br>  <br>  When the current index lies within an already known suffix, we align<br>  that suffix with the end of the pattern and check whether it extends<br>  beyond the current position. If so, we reuse the stored suffix length;<br>  otherwise, we extend the suffix explicitly.<br>  <br>  If the current index lies outside any known suffix, we compare against<br>  the final byte of the pattern. If this yields a suffix of length &gt; 1,<br>  we enter the &#8220;known suffix&#8221; case for subsequent indices; otherwise,<br>  we continue scanning normally.<br>  <br>  Example : &quot;ANPANMAN&quot;<br>  <br>  Raw suffix-lengths array used to compute the good suffix shift table<br>  <br>  | i | pat[i] | matches pattern end? | diff = patEnd - i | nextI = i-1 | prevI (dec diff nextI) | ar[i] |<br>  | - | ------ | -------------------- | ----------------- | ----------- | ---------------------- | ----- |<br>  | 0 |    A   |          No          |         -         |      -      |            -           |   0   |<br>  | 1 |    N   |          Yes         |         6         |      0      |           -1           |   2   |<br>  | 2 |    P   |          No          |         -         |      -      |            -           |   0   |<br>  | 3 |    A   |          No          |         -         |      -      |            -           |   0   |<br>  | 4 |    N   |          Yes         |         3         |      3      |            2           |   2   |<br>  | 5 |    M   |          No          |         -         |      -      |            -           |   0   |<br>  | 6 |    A   |          No          |         -         |      -      |            -           |   0   |<br>  | 7 |    N   |          -           |         -         |      -      |            -           |   8   |<br>  </pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.ByteString.Search.Internal.Utils.suffixShifts"><code><a class="type" href="Data.ByteString.Search.Internal.Utils.html#Data.ByteString.Search.Internal.Utils.suffixShifts"><span class="name function">suffixShifts</span></a>&ensp;:&ensp;(<span class="boundvar">bs</span>&ensp;:&ensp;<span class="type resolved" title="Data.ByteVect.ByteString"><span class="name type">ByteString</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Data.Linear.Token.F1"><span class="name function">F1</span></span>&ensp;<span class="boundvar">s</span>&ensp;(<span class="type resolved" title="Data.Array.Core.MArray"><span class="name type">MArray</span></span>&ensp;<span class="boundvar">s</span>&ensp;(<span class="type resolved" title="Data.ByteString.length"><span class="name function">length</span></span>&ensp;<span class="boundvar">bs</span>)&ensp;<span class="name type">Int</span>)</code></dt><dd><pre>  Table of suffix-shifts<br>  <br>  When a mismatch occurs at pattern position patpos, assumed to be not the<br>  last position in the pattern, the suffix u of length (patend - patpos)<br>  has been successfully matched.<br>  Let c be the byte in the pattern at position patpos.<br>  <br>  If the sub-pattern u also occurs in the pattern somewhere *not* preceded<br>  by c, let upos be the position of the last byte in u for the last of<br>  all such occurrences. Then there can be no match if the window is shifted<br>  less than (patend - upos) places, because either the part of the string<br>  which matched the suffix u is not aligned with an occurrence of u in the<br>  pattern, or it is aligned with an occurrence of u which is preceded by<br>  the same byte c as the originally matched suffix.<br>  <br>  If the complete sub-pattern u does not occur again in the pattern, or all<br>  of its occurrences are preceded by the byte c, then we can align the<br>  pattern with the string so that a suffix v of u matches a prefix of the<br>  pattern. If v is chosen maximal, no smaller shift can give a match, so<br>  we can shift by at least (patlen - length v).<br>  <br>  If a complete match is encountered, we can shift by at least the same<br>  amount as if the first byte of the pattern was a mismatch, no complete<br>  match is possible between these positions.<br>  <br>  For non-periodic patterns, only very short suffixes will usually occur<br>  again in the pattern, so if a longer suffix has been matched before a<br>  mismatch, the window can then be shifted entirely past the partial<br>  match, so that part of the string will not be re-compared.<br>  For periodic patterns, the suffix shifts will be shorter in general,<br>  leading to an O(strlen * patlen) worst-case performance.<br>  <br>  To compute the suffix-shifts, we use an array containing the lengths of<br>  the longest common suffixes of the entire pattern and its prefix ending<br>  with position pos.<br>  <br>  Example: &quot;ANPANMAN&quot;<br>  <br>  | idx | suff[idx] | target = patEnd - suff[idx] | value = patEnd - idx |    ar after write |<br>  | --- | --------- | --------------------------- | -------------------- | ----------------- |<br>  |   0 |         0 |                   7 - 0 = 7 |            7 - 0 = 7 | [6,6,6,6,6,6,8,7] |<br>  |   1 |         2 |                   7 - 2 = 5 |            7 - 1 = 6 | [6,6,6,6,6,6,8,7] |<br>  |   2 |         0 |                           7 |            7 - 2 = 5 | [6,6,6,6,6,6,8,5] |<br>  |   3 |         0 |                           7 |            7 - 3 = 4 | [6,6,6,6,6,6,8,4] |<br>  |   4 |         2 |                   7 - 2 = 5 |            7 - 4 = 3 | [6,6,6,6,6,3,8,4] |<br>  |   5 |         0 |                           7 |            7 - 5 = 2 | [6,6,6,6,6,3,8,2] |<br>  |   6 |         0 |                           7 |            7 - 6 = 1 | [6,6,6,6,6,3,8,1] |<br>  </pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd></dl></div><footer>Produced by Idris 2 version 0.8.0-6837b47a8</footer></body></html>
