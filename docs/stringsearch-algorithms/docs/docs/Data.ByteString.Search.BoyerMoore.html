<!DOCTYPE html><html lang="en">

<head>
  <meta charset="utf-8">
  <title>Data.ByteString.Search.BoyerMoore</title>
  <link rel="stylesheet" type="text/css" id="preferredStyle" href="../default.css">
  <script>
    /* Updates the stylesheet to use the preferred one.
       Note that we set the link to root ++ sourceLoc because the config
       is shared across the whole website, so the root may differ from
       page to page.
    */
    function setStyleSource (sourceLoc) {
      document.getElementById("preferredStyle").href = "../" + sourceLoc + ".css";
      document.getElementById("selectPreferredStyle").value = sourceLoc;
    }
    /* Initialises the preferred style sheet:
       1. if there is a stored value then use that
          otherwise select the default
       2. set both the css link href & the drop down menu selected option
    */
    function initStyleSource () {
      var preferredStyle = localStorage.getItem("stylefile");
      if (preferredStyle !== null) {
        setStyleSource(preferredStyle);
      } else {
        setStyleSource("default");
      };
    }
    function saveStyleSource (preferredStyle) {
      localStorage.stylefile = preferredStyle;
    }
    </script>
</head>

<body class="namespace">
<header>
  <strong>Idris2Doc</strong> : Data.ByteString.Search.BoyerMoore
  <nav><a href="../index.html">Index</a>

  <select id="selectPreferredStyle">
    <option value="default">Default</option>
<option value="alternative">Alternative</option>
<option value="blackandwhite">Black & White</option>

  </select>
  </nav>

  <script>
  /* We start by initialising the style source */
  initStyleSource();

  /* This listens for changes on the drop down menu and updates the
     css used for the current page when a selection is made.
  */
  document.getElementById("selectPreferredStyle").addEventListener("change", function(){
    var selected = this.options[this.selectedIndex].value; /* the option chosen */
    setStyleSource (selected);
    saveStyleSource (selected);
  });
</script>

</header>
<div class="container"><div id="module-header"><h1>Data.ByteString.Search.BoyerMoore</h1><span style="float:right">(<a href="Data.ByteString.Search.BoyerMoore.src.html">source</a>)</span><pre>Boyer-Moore search of ByteStrings
</pre></div><code></code><h2>Definitions</h2><dl class="decls"><dt id="Data.ByteString.Search.BoyerMoore.matchBM"><code><a class="type" href="Data.ByteString.Search.BoyerMoore.html#Data.ByteString.Search.BoyerMoore.matchBM"><span class="name function">matchBM</span></a>&ensp;:&ensp;(<span class="boundvar">pat</span>&ensp;:&ensp;<span class="type resolved" title="Data.ByteVect.ByteString"><span class="name type">ByteString</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">target</span>&ensp;:&ensp;<span class="type resolved" title="Data.ByteVect.ByteString"><span class="name type">ByteString</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Data.Linear.Token.F1"><span class="name function">F1</span></span>&ensp;<span class="boundvar">s</span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="name type">Int</span>)</code></dt><dd><pre>  Performs a string search on a `ByteString` utilizing a Boyer-Moore algorithm.<br>  <br>  This function finds all (0-based) starting indices of the non-empty pattern `ByteString`<br>  pat within the non-empty target `ByteString`.<br>  <br>  Example:<br>  <br>  | pat  | target     |<br>  | ---- | ---------- |<br>  | &quot;AN&quot; | &quot;ANPANMAN&quot; |<br>  <br>  | s | window T[s..s+1] | comparisons (right&#8594;left)      | result    |                  bad-char |     good-suffix | chosen shift | next s |<br>  | - | ---------------- | ----------------------------- | --------- | ------------------------- | --------------- | ------------ | ------ |<br>  | 0 | **AN**           | j=1: N==N &#10003; &#8594; j=0: A==A &#10003;     | **MATCH** |                         &#8212; | (after match) 2 |            2 |      2 |<br>  | 1 | N**P**           | j=1: N vs P &#8594; mismatch at j=1 | mismatch  | lastOcc(&apos;P&apos;)=-1 &#8594; bad = 2 | suffShifts[1]=1 |        **2** |      3 |<br>  | 2 | P**A**           | j=1: N vs A &#8594; mismatch at j=1 | mismatch  |  lastOcc(&apos;A&apos;)=0 &#8594; bad = 1 |        good = 1 |        **1** |      3 |<br>  | 3 | **AN**           | j=1: N==N &#10003; &#8594; j=0: A==A &#10003;     | **MATCH** |                         &#8212; | (after match) 2 |            2 |      5 |<br>  | 4 | N**M**           | j=1: N vs M &#8594; mismatch at j=1 | mismatch  | lastOcc(&apos;M&apos;)=-1 &#8594; bad = 2 |        good = 1 |        **2** |      6 |<br>  | 5 | M**A**           | j=1: N vs A &#8594; mismatch at j=1 | mismatch  |  lastOcc(&apos;A&apos;)=0 &#8594; bad = 1 |        good = 1 |        **1** |      6 |<br>  | 6 | **AN**           | j=1: N==N &#10003; &#8594; j=0: A==A &#10003;     | **MATCH** |                         &#8212; | (after match) 2 |            2 |      &#8212; |<br>  <br>  matchBM &quot;AN&quot; &quot;ANPANMAN&quot; =&gt; [0, 3, 6]<br>  </pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.ByteString.Search.BoyerMoore.indicesBM"><code><a class="type" href="Data.ByteString.Search.BoyerMoore.html#Data.ByteString.Search.BoyerMoore.indicesBM"><span class="name function">indicesBM</span></a>&ensp;:&ensp;(<span class="boundvar">pat</span>&ensp;:&ensp;<span class="type resolved" title="Data.ByteVect.ByteString"><span class="name type">ByteString</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">target</span>&ensp;:&ensp;<span class="type resolved" title="Data.ByteVect.ByteString"><span class="name type">ByteString</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Data.Linear.Token.F1"><span class="name function">F1</span></span>&ensp;<span class="boundvar">s</span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="name type">Int</span>)</code></dt><dd><pre>  Performs a string search on a `ByteString` utilizing a Boyer-Moore algorithm.<br>  <br>  This function finds all (0-based) indices (possibly overlapping)<br>  of the non-empty pattern `ByteString` pat<br>  within the non-empty target `ByteString`.<br>  <br>  Example:<br>  <br>  | pat   | target      |<br>  | ----- | ----------- |<br>  | &quot;ABC&quot; | &quot;ABCABCABC&quot; |<br>  <br>  | Align s   | Window       | Comparison Result                  | Chosen Shift                         | Next s   |<br>  | --------- | ------------ | ---------------------------------- | ------------------------------------ | -------- |<br>  |     0     | **ABCABC**   | MATCH                              | good-suffix after full match = 3     |     3    |<br>  |     1     | A**BCABCA**  | MISMATCH on last char (`C` vs `A`) | max(bad=2, good=1) = 2               |     3    |<br>  |     2     | AB**CABCAA** | MISMATCH on last char (`C` vs `B`) | max(bad=1, good=1) = 1               |     3    |<br>  |     3     | ABC**ABC**   | MATCH                              | (would shift 3 again)                |     &#8212;    |<br>  <br>  indicesBM &quot;ABCABC&quot; &quot;ABCABCABC&quot; =&gt; [0, 3]<br>  </pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.ByteString.Search.BoyerMoore.breakBM"><code><a class="type" href="Data.ByteString.Search.BoyerMoore.html#Data.ByteString.Search.BoyerMoore.breakBM"><span class="name function">breakBM</span></a>&ensp;:&ensp;(<span class="boundvar">pat</span>&ensp;:&ensp;<span class="type resolved" title="Data.ByteVect.ByteString"><span class="name type">ByteString</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">target</span>&ensp;:&ensp;<span class="type resolved" title="Data.ByteVect.ByteString"><span class="name type">ByteString</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Data.Linear.Token.F1"><span class="name function">F1</span></span>&ensp;<span class="boundvar">s</span>&ensp;(<span class="type resolved" title="Data.ByteVect.ByteString"><span class="name type">ByteString</span></span>,&ensp;<span class="type resolved" title="Data.ByteVect.ByteString"><span class="name type">ByteString</span></span>)</code></dt><dd><pre>  Splits a ByteString at the first match of pat in target.<br>  <br>  This function uses the Boyer&#8211;Moore matcher (with overlap = False) to<br>  locate the earliest occurrence of pat in target.  If the pattern is<br>  found at index i, the pattern ByteString pat is split at that index,<br>  returning the prefix and suffix as a pair (before, after).<br>  <br>  If the pattern does not occur in the target, (pat, empty) is returned.<br>  In other words, the entire pattern becomes the &#8220;before&#8221; part and the<br>  &#8220;after&#8221; part is an empty ByteString.<br>  </pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.ByteString.Search.BoyerMoore.breakAfterBM"><code><a class="type" href="Data.ByteString.Search.BoyerMoore.html#Data.ByteString.Search.BoyerMoore.breakAfterBM"><span class="name function">breakAfterBM</span></a>&ensp;:&ensp;(<span class="boundvar">pat</span>&ensp;:&ensp;<span class="type resolved" title="Data.ByteVect.ByteString"><span class="name type">ByteString</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">target</span>&ensp;:&ensp;<span class="type resolved" title="Data.ByteVect.ByteString"><span class="name type">ByteString</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Data.Linear.Token.F1"><span class="name function">F1</span></span>&ensp;<span class="boundvar">s</span>&ensp;(<span class="type resolved" title="Data.ByteVect.ByteString"><span class="name type">ByteString</span></span>,&ensp;<span class="type resolved" title="Data.ByteVect.ByteString"><span class="name type">ByteString</span></span>)</code></dt><dd><pre>  Splits a ByteString after the first match of pat in target.<br>  <br>  This function uses the Boyer&#8211;Moore matcher (with overlap = False) to<br>  find the earliest occurrence of pat in target.  If the pattern is<br>  found at index i, this function splits pat at position i + length pat,<br>  producing a pair (before, after) that places the entire matched region<br>  into the prefix.<br>  <br>  If the pattern does not occur in target, the function returns<br>  (pat, empty), the entire pattern is the &#8220;before&#8221; substring, and the<br>  suffix is empty.<br>  </pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.ByteString.Search.BoyerMoore.splitKeepFrontBM"><code><a class="type" href="Data.ByteString.Search.BoyerMoore.html#Data.ByteString.Search.BoyerMoore.splitKeepFrontBM"><span class="name function">splitKeepFrontBM</span></a>&ensp;:&ensp;(<span class="boundvar">pat</span>&ensp;:&ensp;<span class="type resolved" title="Data.ByteVect.ByteString"><span class="name type">ByteString</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">target</span>&ensp;:&ensp;<span class="type resolved" title="Data.ByteVect.ByteString"><span class="name type">ByteString</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Data.Linear.Token.F1"><span class="name function">F1</span></span>&ensp;<span class="boundvar">s</span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="type resolved" title="Data.ByteVect.ByteString"><span class="name type">ByteString</span></span>)</code></dt><dd><pre>  Splits a ByteString into a list of pieces according to repeated<br>  matches of target, keeping the matching prefix of pat<br>  at the front of each produced chunk.<br>  <br>  This function repeatedly searches target for occurrences of pat<br>  (using the Boyer&#8211;Moore matcher with overlap = False).  Each time a<br>  match is found at index i, the prefix of pat up to i + length pat<br>  is emitted as the next chunk, and the function continues processing the<br>  remaining suffix of pat.<br>  <br>  Unlike breakBM or breakAfterBM, this function performs repeated<br>  splitting until the entire pattern has been consumed, producing a<br>  list of ByteStrings.<br>  </pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.ByteString.Search.BoyerMoore.splitKeepEndBM"><code><a class="type" href="Data.ByteString.Search.BoyerMoore.html#Data.ByteString.Search.BoyerMoore.splitKeepEndBM"><span class="name function">splitKeepEndBM</span></a>&ensp;:&ensp;(<span class="boundvar">pat</span>&ensp;:&ensp;<span class="type resolved" title="Data.ByteVect.ByteString"><span class="name type">ByteString</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">target</span>&ensp;:&ensp;<span class="type resolved" title="Data.ByteVect.ByteString"><span class="name type">ByteString</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Data.Linear.Token.F1"><span class="name function">F1</span></span>&ensp;<span class="boundvar">s</span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="type resolved" title="Data.ByteVect.ByteString"><span class="name type">ByteString</span></span>)</code></dt><dd><pre>  Splits a ByteString into a list of pieces according to repeated<br>  matches of pat inside target, keeping the matching<br>  suffix of pat at the end of each produced chunk.<br>  <br>  This function repeatedly searches target for occurrences of pat<br>  (using the Boyer&#8211;Moore matcher with overlap = False).  Each time a<br>  match is found at index i, the next chunk emitted is the prefix of<br>  target of length i + length pat, which includes the entire matched<br>  occurrence of pat at its end.<br>  <br>  After emitting this chunk, the function continues splitting the<br>  remainder of target until all input has been consumed.<br>  <br>  Unlike splitKeepFrontBM, which keeps the matched prefix of pat<br>  at the front of each chunk, splitKeepEndBM ensures the match<br>  appears at the end of each chunk.<br>  <br>  If pat does not occur in target, the result is a singleton list<br>  containing the original target.<br>  </pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.ByteString.Search.BoyerMoore.splitDropBM"><code><a class="type" href="Data.ByteString.Search.BoyerMoore.html#Data.ByteString.Search.BoyerMoore.splitDropBM"><span class="name function">splitDropBM</span></a>&ensp;:&ensp;(<span class="boundvar">pat</span>&ensp;:&ensp;<span class="type resolved" title="Data.ByteVect.ByteString"><span class="name type">ByteString</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">target</span>&ensp;:&ensp;<span class="type resolved" title="Data.ByteVect.ByteString"><span class="name type">ByteString</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Data.Linear.Token.F1"><span class="name function">F1</span></span>&ensp;<span class="boundvar">s</span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="type resolved" title="Data.ByteVect.ByteString"><span class="name type">ByteString</span></span>)</code></dt><dd><pre>  Splits a ByteString into a list of pieces according to repeated<br>  matches of pat inside target, dropping each matched<br>  occurrence from the output entirely.<br>  <br>  This function repeatedly searches target for occurrences of pat<br>  (using the Boyer&#8211;Moore matcher with overlap = False).  Each time a<br>  match is found at index i, the prefix of target of length i<br>  (that is, the portion preceding the match) is emitted as the next<br>  chunk.  The matched substring itself is not included.<br>  <br>  After emitting this prefix, the function continues splitting the<br>  remainder of target, skipping over the full match of length<br>  i + length pat.  This process continues until the entire target<br>  has been consumed.<br>  <br>  Unlike splitKeepFrontBM and splitKeepEndBM, which include the<br>  matched pattern in each emitted chunk, splitDropBM removes all<br>  occurrences of pat from the output.<br>  <br>  If pat does not occur in target, the result is a singleton list<br>  containing the original target.<br>  </pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.ByteString.Search.BoyerMoore.replaceBM"><code><a class="type" href="Data.ByteString.Search.BoyerMoore.html#Data.ByteString.Search.BoyerMoore.replaceBM"><span class="name function">replaceBM</span></a>&ensp;:&ensp;(<span class="boundvar">pat</span>&ensp;:&ensp;<span class="type resolved" title="Data.ByteVect.ByteString"><span class="name type">ByteString</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Data.ByteVect.ByteString"><span class="name type">ByteString</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">target</span>&ensp;:&ensp;<span class="type resolved" title="Data.ByteVect.ByteString"><span class="name type">ByteString</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Data.Linear.Token.F1"><span class="name function">F1</span></span>&ensp;<span class="boundvar">s</span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="type resolved" title="Data.ByteVect.ByteString"><span class="name type">ByteString</span></span>)</code></dt><dd><pre>  Replaces all non-overlapping occurrences of a pattern in a ByteString<br>  using the Boyer&#8211;Moore matcher.<br>  <br>  This function repeatedly searches target for occurrences of pat<br>  (using matcher False). Each time a match is found at index i:<br>  <br>  * If i == 0, the match is at the current position. The matched<br>    segment is dropped and sub is appended to the result (unless<br>    sub is empty, in which case nothing is appended).<br>  <br>  * If i &gt; 0, the prefix take i target is appended to the result,<br>    followed by sub (unless sub is empty). The matched segment is<br>    then dropped and processing continues on the remaining suffix.<br>  <br>  If no further matches are found, the remaining target is appended<br>  unchanged and the result is returned.<br>  <br>  The result is accumulated via a `SnocList` and returned as a `List<br>  ByteString`, preserving left-to-right order of the produced chunks.<br>  </pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd></dl></div><footer>Produced by Idris 2 version 0.8.0-7928774fa</footer></body></html>
