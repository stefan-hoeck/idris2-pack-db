<!DOCTYPE html><html lang="en">

<head>
  <meta charset="utf-8">
  <title>Data.ByteString.Search.KnuthMorrisPratt</title>
  <link rel="stylesheet" type="text/css" id="preferredStyle" href="../default.css">
  <script>
    /* Updates the stylesheet to use the preferred one.
       Note that we set the link to root ++ sourceLoc because the config
       is shared across the whole website, so the root may differ from
       page to page.
    */
    function setStyleSource (sourceLoc) {
      document.getElementById("preferredStyle").href = "../" + sourceLoc + ".css";
      document.getElementById("selectPreferredStyle").value = sourceLoc;
    }
    /* Initialises the preferred style sheet:
       1. if there is a stored value then use that
          otherwise select the default
       2. set both the css link href & the drop down menu selected option
    */
    function initStyleSource () {
      var preferredStyle = localStorage.getItem("stylefile");
      if (preferredStyle !== null) {
        setStyleSource(preferredStyle);
      } else {
        setStyleSource("default");
      };
    }
    function saveStyleSource (preferredStyle) {
      localStorage.stylefile = preferredStyle;
    }
    </script>
</head>

<body class="namespace">
<header>
  <strong>Idris2Doc</strong> : Data.ByteString.Search.KnuthMorrisPratt
  <nav><a href="../index.html">Index</a>

  <select id="selectPreferredStyle">
    <option value="default">Default</option>
<option value="alternative">Alternative</option>
<option value="blackandwhite">Black & White</option>

  </select>
  </nav>

  <script>
  /* We start by initialising the style source */
  initStyleSource();

  /* This listens for changes on the drop down menu and updates the
     css used for the current page when a selection is made.
  */
  document.getElementById("selectPreferredStyle").addEventListener("change", function(){
    var selected = this.options[this.selectedIndex].value; /* the option chosen */
    setStyleSource (selected);
    saveStyleSource (selected);
  });
</script>

</header>
<div class="container"><div id="module-header"><h1>Data.ByteString.Search.KnuthMorrisPratt</h1><span style="float:right">(<a href="Data.ByteString.Search.KnuthMorrisPratt.src.html">source</a>)</span><pre>Fast Knuth-Morris-Pratt search of ByteStrings
</pre></div><code></code><h2>Definitions</h2><dl class="decls"><dt id="Data.ByteString.Search.KnuthMorrisPratt.matchKMP"><code><a class="type" href="Data.ByteString.Search.KnuthMorrisPratt.html#Data.ByteString.Search.KnuthMorrisPratt.matchKMP"><span class="name function">matchKMP</span></a>&ensp;:&ensp;(<span class="boundvar">pat</span>&ensp;:&ensp;<span class="type resolved" title="Data.ByteVect.ByteString"><span class="name type">ByteString</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">target</span>&ensp;:&ensp;<span class="type resolved" title="Data.ByteVect.ByteString"><span class="name type">ByteString</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Data.Linear.Token.F1"><span class="name function">F1</span></span>&ensp;<span class="boundvar">s</span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)</code></dt><dd><pre>  Performs a Knuth&#8211;Morris&#8211;Pratt string search on a `ByteString`.<br>  <br>  This function finds all (0-based) starting indices of the non-empty pattern `ByteString`<br>  pat within the non-empty target `ByteString`, using the KMP border table<br>  computed by `kmpBorders`.<br>  <br>  Example:<br>  <br>  | pat  | target     |<br>  | ---- | ---------- |<br>  | &quot;AN&quot; | &quot;ANPANMAN&quot; |<br>  <br>  | Start | Substring      | Match? | Explanation                                      |<br>  | ----- | -------------- | ------ | ------------------------------------------------ |<br>  | 0     | **&quot;AN&quot;**PANMAN | Yes    | Full pattern `&quot;AN&quot;` matches starting at index 0. |<br>  | 1     | A**&quot;NP&quot;**ANMAN | No     | Mismatch after the first character.              |<br>  | 2     | AN**&quot;PA&quot;**NMAN | No     | No match &#8212; next candidate after suffix shift.    |<br>  | 3     | ANP**&quot;AN&quot;**MAN | Yes    | Match found at index 3.                          |<br>  | 4     | ANPA**&quot;NM&quot;**AN | No     | Mismatch.                                        |<br>  | 5     | ANPAN**&quot;MA&quot;**N | No     | Mismatch.                                        |<br>  | 6     | ANPANM**&quot;AN&quot;** | Yes    | Final match found at index 6.                    |<br>  <br>  <br>  matchKMP &quot;AN&quot; &quot;ANPANMAN&quot; =&gt; [0, 3, 6]<br>  </pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.ByteString.Search.KnuthMorrisPratt.indicesKMP"><code><a class="type" href="Data.ByteString.Search.KnuthMorrisPratt.html#Data.ByteString.Search.KnuthMorrisPratt.indicesKMP"><span class="name function">indicesKMP</span></a>&ensp;:&ensp;(<span class="boundvar">pat</span>&ensp;:&ensp;<span class="type resolved" title="Data.ByteVect.ByteString"><span class="name type">ByteString</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">target</span>&ensp;:&ensp;<span class="type resolved" title="Data.ByteVect.ByteString"><span class="name type">ByteString</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Data.Linear.Token.F1"><span class="name function">F1</span></span>&ensp;<span class="boundvar">s</span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)</code></dt><dd><pre>  Performs a Knuth&#8211;Morris&#8211;Pratt string search on a `ByteString`.<br>  <br>  This function finds all (0-based) indices (possibly overlapping)<br>  of the non-empty pattern `ByteString` pat<br>  within the non-empty target `ByteString`, using the KMP border table<br>  computed by `kmpBorders`.<br>  <br>  Example:<br>  <br>  | pat   | target      |<br>  | ----- | ----------- |<br>  | &quot;ABC&quot; | &quot;ABCABCABC&quot; |<br>  <br>  | Start | Substring       | Match? | Explanation                                                      |<br>  | ----- | --------------- | ------ | ---------------------------------------------------------------- |<br>  | 0     | **&quot;ABCABC&quot;**ABC | Yes    | Full pattern matches starting at index 0.                        |<br>  | 1     | A**&quot;BCABCA&quot;**BC | No     | Mismatch starts immediately after first letter.                  |<br>  | 2     | AB**&quot;CABCAA&quot;**C | No     | Shift by suffix table &#8594; mismatch on 2nd char.                    |<br>  | 3     | ABC**&quot;ABC&quot;**    | Yes    | Overlapping match starting at index 3 (because `&quot;ABC&quot;` repeats). |<br>  <br>  indicesKMP &quot;ABCABC&quot; &quot;ABCABCABC&quot; =&gt; [0, 3]<br>  </pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.ByteString.Search.KnuthMorrisPratt.breakKMP"><code><a class="type" href="Data.ByteString.Search.KnuthMorrisPratt.html#Data.ByteString.Search.KnuthMorrisPratt.breakKMP"><span class="name function">breakKMP</span></a>&ensp;:&ensp;(<span class="boundvar">pat</span>&ensp;:&ensp;<span class="type resolved" title="Data.ByteVect.ByteString"><span class="name type">ByteString</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">target</span>&ensp;:&ensp;<span class="type resolved" title="Data.ByteVect.ByteString"><span class="name type">ByteString</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Data.Linear.Token.F1"><span class="name function">F1</span></span>&ensp;<span class="boundvar">s</span>&ensp;(<span class="type resolved" title="Data.ByteVect.ByteString"><span class="name type">ByteString</span></span>,&ensp;<span class="type resolved" title="Data.ByteVect.ByteString"><span class="name type">ByteString</span></span>)</code></dt><dd><pre>  Splits a ByteString at the first match of pat in target.<br>  <br>  This function uses the Knuth-Morris-Pratt matcher (with overlap = False) to<br>  locate the earliest occurrence of pat in target.  If the pattern is<br>  found at index i, the pattern ByteString pat is split at that index,<br>  returning the prefix and suffix as a pair (before, after).<br>  <br>  If the pattern does not occur in the target, (pat, empty) is returned.<br>  In other words, the entire pattern becomes the &#8220;before&#8221; part and the<br>  &#8220;after&#8221; part is an empty ByteString.<br>  </pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.ByteString.Search.KnuthMorrisPratt.breakAfterKMP"><code><a class="type" href="Data.ByteString.Search.KnuthMorrisPratt.html#Data.ByteString.Search.KnuthMorrisPratt.breakAfterKMP"><span class="name function">breakAfterKMP</span></a>&ensp;:&ensp;(<span class="boundvar">pat</span>&ensp;:&ensp;<span class="type resolved" title="Data.ByteVect.ByteString"><span class="name type">ByteString</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">target</span>&ensp;:&ensp;<span class="type resolved" title="Data.ByteVect.ByteString"><span class="name type">ByteString</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Data.Linear.Token.F1"><span class="name function">F1</span></span>&ensp;<span class="boundvar">s</span>&ensp;(<span class="type resolved" title="Data.ByteVect.ByteString"><span class="name type">ByteString</span></span>,&ensp;<span class="type resolved" title="Data.ByteVect.ByteString"><span class="name type">ByteString</span></span>)</code></dt><dd><pre>  Splits a ByteString after the first match of pat in target.<br>  <br>  This function uses the Knuth-Morris-Pratt matcher (with overlap = False) to<br>  find the earliest occurrence of pat in target.  If the pattern is<br>  found at index i, this function splits pat at position i + length pat,<br>  producing a pair (before, after) that places the entire matched region<br>  into the prefix.<br>  <br>  If the pattern does not occur in target, the function returns<br>  (pat, empty), the entire pattern is the &#8220;before&#8221; substring, and the<br>  suffix is empty.<br>  </pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.ByteString.Search.KnuthMorrisPratt.splitKeepFrontKMP"><code><a class="type" href="Data.ByteString.Search.KnuthMorrisPratt.html#Data.ByteString.Search.KnuthMorrisPratt.splitKeepFrontKMP"><span class="name function">splitKeepFrontKMP</span></a>&ensp;:&ensp;(<span class="boundvar">pat</span>&ensp;:&ensp;<span class="type resolved" title="Data.ByteVect.ByteString"><span class="name type">ByteString</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">target</span>&ensp;:&ensp;<span class="type resolved" title="Data.ByteVect.ByteString"><span class="name type">ByteString</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Data.Linear.Token.F1"><span class="name function">F1</span></span>&ensp;<span class="boundvar">s</span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="type resolved" title="Data.ByteVect.ByteString"><span class="name type">ByteString</span></span>)</code></dt><dd><pre>  Splits a ByteString into a list of pieces according to repeated<br>  matches of target, keeping the matching prefix of pat<br>  at the front of each produced chunk.<br>  <br>  This function repeatedly searches target for occurrences of pat<br>  (using the Knuth-Morris-Pratt matcher with overlap = False).  Each time a<br>  match is found at index i, the prefix of pat up to i + length pat<br>  is emitted as the next chunk, and the function continues processing the<br>  remaining suffix of pat.<br>  <br>  Unlike breakKMP or breakAfterKMP, this function performs repeated<br>  splitting until the entire pattern has been consumed, producing a<br>  list of ByteStrings.<br>  </pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.ByteString.Search.KnuthMorrisPratt.splitKeepEndKMP"><code><a class="type" href="Data.ByteString.Search.KnuthMorrisPratt.html#Data.ByteString.Search.KnuthMorrisPratt.splitKeepEndKMP"><span class="name function">splitKeepEndKMP</span></a>&ensp;:&ensp;(<span class="boundvar">pat</span>&ensp;:&ensp;<span class="type resolved" title="Data.ByteVect.ByteString"><span class="name type">ByteString</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">target</span>&ensp;:&ensp;<span class="type resolved" title="Data.ByteVect.ByteString"><span class="name type">ByteString</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Data.Linear.Token.F1"><span class="name function">F1</span></span>&ensp;<span class="boundvar">s</span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="type resolved" title="Data.ByteVect.ByteString"><span class="name type">ByteString</span></span>)</code></dt><dd><pre>  Splits a ByteString into a list of pieces according to repeated<br>  matches of pat inside target, keeping the matching<br>  suffix of pat at the end of each produced chunk.<br>  <br>  This function repeatedly searches target for occurrences of pat<br>  (using the Knuth-Morris-Pratt matcher with overlap = False).  Each time a<br>  match is found at index i, the next chunk emitted is the prefix of<br>  target of length i + length pat, which includes the entire matched<br>  occurrence of pat at its end.<br>  <br>  After emitting this chunk, the function continues splitting the<br>  remainder of target until all input has been consumed.<br>  <br>  Unlike splitKeepFrontKMP, which keeps the matched prefix of pat<br>  at the front of each chunk, splitKeepEndKMP ensures the match<br>  appears at the end of each chunk.<br>  <br>  If pat does not occur in target, the result is a singleton list<br>  containing the original target.<br>  </pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.ByteString.Search.KnuthMorrisPratt.splitDropKMP"><code><a class="type" href="Data.ByteString.Search.KnuthMorrisPratt.html#Data.ByteString.Search.KnuthMorrisPratt.splitDropKMP"><span class="name function">splitDropKMP</span></a>&ensp;:&ensp;(<span class="boundvar">pat</span>&ensp;:&ensp;<span class="type resolved" title="Data.ByteVect.ByteString"><span class="name type">ByteString</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">target</span>&ensp;:&ensp;<span class="type resolved" title="Data.ByteVect.ByteString"><span class="name type">ByteString</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Data.Linear.Token.F1"><span class="name function">F1</span></span>&ensp;<span class="boundvar">s</span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="type resolved" title="Data.ByteVect.ByteString"><span class="name type">ByteString</span></span>)</code></dt><dd><pre>  Splits a ByteString into a list of pieces according to repeated<br>  matches of pat inside target, dropping each matched<br>  occurrence from the output entirely.<br>  <br>  This function repeatedly searches target for occurrences of pat<br>  (using the Knuth-Morris-Pratt matcher with overlap = False).  Each time a<br>  match is found at index i, the prefix of target of length i<br>  (that is, the portion preceding the match) is emitted as the next<br>  chunk.  The matched substring itself is not included.<br>  <br>  After emitting this prefix, the function continues splitting the<br>  remainder of target, skipping over the full match of length<br>  i + length pat.  This process continues until the entire target<br>  has been consumed.<br>  <br>  Unlike splitKeepFrontKMP and splitKeepEndKMP, which include the<br>  matched pattern in each emitted chunk, splitDropKMP removes all<br>  occurrences of pat from the output.<br>  <br>  If pat does not occur in target, the result is a singleton list<br>  containing the original target.<br>  </pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.ByteString.Search.KnuthMorrisPratt.replaceKMP"><code><a class="type" href="Data.ByteString.Search.KnuthMorrisPratt.html#Data.ByteString.Search.KnuthMorrisPratt.replaceKMP"><span class="name function">replaceKMP</span></a>&ensp;:&ensp;(<span class="boundvar">pat</span>&ensp;:&ensp;<span class="type resolved" title="Data.ByteVect.ByteString"><span class="name type">ByteString</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Data.ByteVect.ByteString"><span class="name type">ByteString</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">target</span>&ensp;:&ensp;<span class="type resolved" title="Data.ByteVect.ByteString"><span class="name type">ByteString</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Data.Linear.Token.F1"><span class="name function">F1</span></span>&ensp;<span class="boundvar">s</span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="type resolved" title="Data.ByteVect.ByteString"><span class="name type">ByteString</span></span>)</code></dt><dd><pre>  Replaces all non-overlapping occurrences of a pattern in a ByteString<br>  using the Knuth-Morris-Pratt matcher.<br>  <br>  This function repeatedly searches target for occurrences of pat<br>  (using matcher False). Each time a match is found at index i:<br>  <br>  * If i == 0, the match is at the current position. The matched<br>    segment is dropped and sub is appended to the result (unless<br>    sub is empty, in which case nothing is appended).<br>  <br>  * If i &gt; 0, the prefix take i target is appended to the result,<br>    followed by sub (unless sub is empty). The matched segment is<br>    then dropped and processing continues on the remaining suffix.<br>  <br>  If no further matches are found, the remaining target is appended<br>  unchanged and the result is returned.<br>  <br>  The result is accumulated via a `SnocList` and returned as a `List<br>  ByteString`, preserving left-to-right order of the produced chunks.<br>  </pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd></dl></div><footer>Produced by Idris 2 version 0.8.0-10743f0ff</footer></body></html>
