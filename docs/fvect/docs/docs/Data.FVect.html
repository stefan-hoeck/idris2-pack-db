<!DOCTYPE html><html lang="en">

<head>
  <meta charset="utf-8">
  <title>Data.FVect</title>
  <link rel="stylesheet" type="text/css" id="preferredStyle" href="../default.css">
  <script>
    /* Updates the stylesheet to use the preferred one.
       Note that we set the link to root ++ sourceLoc because the config
       is shared across the whole website, so the root may differ from
       page to page.
    */
    function setStyleSource (sourceLoc) {
      document.getElementById("preferredStyle").href = "../" + sourceLoc + ".css";
      document.getElementById("selectPreferredStyle").value = sourceLoc;
    }
    /* Initialises the preferred style sheet:
       1. if there is a stored value then use that
          otherwise select the default
       2. set both the css link href & the drop down menu selected option
    */
    function initStyleSource () {
      var preferredStyle = localStorage.getItem("stylefile");
      if (preferredStyle !== null) {
        setStyleSource(preferredStyle);
      } else {
        setStyleSource("default");
      };
    }
    function saveStyleSource (preferredStyle) {
      localStorage.stylefile = preferredStyle;
    }
    </script>
</head>

<body class="namespace">
<header>
  <strong>Idris2Doc</strong> : Data.FVect
  <nav><a href="../index.html">Index</a>

  <select id="selectPreferredStyle">
    <option value="default">Default</option>
<option value="alternative">Alternative</option>
<option value="blackandwhite">Black & White</option>

  </select>
  </nav>

  <script>
  /* We start by initialising the style source */
  initStyleSource();

  /* This listens for changes on the drop down menu and updates the
     css used for the current page when a selection is made.
  */
  document.getElementById("selectPreferredStyle").addEventListener("change", function(){
    var selected = this.options[this.selectedIndex].value; /* the option chosen */
    setStyleSource (selected);
    saveStyleSource (selected);
  });
</script>

</header>
<div class="container"><div id="module-header"><h1>Data.FVect</h1><span style="float:right">(<a href="Data.FVect.src.html">source</a>)</span><pre>Fin-based vects encode not just their current size but also their
largest size. See also Data.FVect.Capacity for a view that is
useful when determining if you want to add to an FVect depending
on whether or not it is full.
</pre></div><h2>Reexports</h2><code><span class="keyword">import</span>&ensp;<span class="keyword">public</span>&ensp;Data.Fin</code><h2>Definitions</h2><dl class="decls"><dt id="Data.FVect.FVect"><code><span class="keyword">data</span>&ensp;<a class="type" href="Data.FVect.html#Data.FVect.FVect"><span class="name type">FVect</span></a>&ensp;:&ensp;(<span class="boundvar">capacity</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Data.Fin.Fin"><span class="name type">Fin</span></span>&ensp;(<span class="type resolved" title="Prelude.Types.S"><span class="name constructor">S</span></span>&ensp;<span class="boundvar">capacity</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd><pre>  A Fin-based Vect. Can be thought of as a Vect with both a length<br>  and a maximum capacity. Operations like filtering can reduce the<br>  length without affecting maximum capacity which provides proof<br>  that a Vect&apos;s length has not increased over the course of a series<br>  of operations.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span><br>  <b>Constructors</b>:<br><dl class="decls">  <dt id="Data.FVect.Nil"><code><a class="type" href="Data.FVect.html#Data.FVect.Nil"><span class="name constructor">Nil</span></a>&ensp;:&ensp;<a class="type" href="Data.FVect.html#Data.FVect.FVect"><span class="name type">FVect</span></a>&ensp;<span class="boundvar">capacity</span>&ensp;<span class="type resolved" title="Data.Fin.FZ"><span class="name constructor">FZ</span></span>&ensp;<span class="boundvar">elem</span></code></dt>  <dt id="Data.FVect.(::)"><code><a class="type" href="Data.FVect.html#Data.FVect.(::)"><span class="name constructor">(::)</span></a>&ensp;:&ensp;<span class="boundvar">elem</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.FVect.html#Data.FVect.FVect"><span class="name type">FVect</span></a>&ensp;<span class="boundvar">capacity</span>&ensp;<span class="boundvar">len</span>&ensp;<span class="boundvar">elem</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.FVect.html#Data.FVect.FVect"><span class="name type">FVect</span></a>&ensp;(<span class="type resolved" title="Prelude.Types.S"><span class="name constructor">S</span></span>&ensp;<span class="boundvar">capacity</span>)&ensp;(<span class="type resolved" title="Data.Fin.FS"><span class="name constructor">FS</span></span>&ensp;<span class="boundvar">len</span>)&ensp;<span class="boundvar">elem</span></code></dt><dd><pre>  Cons an element to the FVect, increasing its capacity.<br>  See (:::) for an operator that conses an element without<br>  increasing capacity.</pre></dd></dl><br>  <b>Hints</b>:<br><dl class="decls">  <dt id="$resolved380"><code><span class="type resolved" title="Prelude.Interfaces.Applicative"><span class="name type">Applicative</span></span>&ensp;(<a class="type" href="Data.FVect.html#Data.FVect.FVect"><span class="name type">FVect</span></a>&ensp;<span class="boundvar">capacity</span>&ensp;<span class="boundvar">l</span>)</code></dt>  <dt id="$resolved379"><code><span class="type resolved" title="Decidable.Equality.Core.DecEq"><span class="name type">DecEq</span></span>&ensp;<span class="boundvar">elem</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Decidable.Equality.Core.DecEq"><span class="name type">DecEq</span></span>&ensp;(<a class="type" href="Data.FVect.html#Data.FVect.FVect"><span class="name type">FVect</span></a>&ensp;<span class="boundvar">c</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">elem</span>)</code></dt>  <dt id="$resolved378"><code><span class="type resolved" title="Prelude.EqOrd.Eq"><span class="name type">Eq</span></span>&ensp;<span class="boundvar">elem</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.EqOrd.Eq"><span class="name type">Eq</span></span>&ensp;(<a class="type" href="Data.FVect.html#Data.FVect.FVect"><span class="name type">FVect</span></a>&ensp;<span class="boundvar">c</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">elem</span>)</code></dt>  <dt id="$resolved377"><code><span class="type resolved" title="Prelude.Interfaces.Foldable"><span class="name type">Foldable</span></span>&ensp;(<a class="type" href="Data.FVect.html#Data.FVect.FVect"><span class="name type">FVect</span></a>&ensp;<span class="boundvar">c</span>&ensp;<span class="boundvar">l</span>)</code></dt>  <dt id="$resolved376"><code><span class="type resolved" title="Prelude.Interfaces.Functor"><span class="name type">Functor</span></span>&ensp;(<a class="type" href="Data.FVect.html#Data.FVect.FVect"><span class="name type">FVect</span></a>&ensp;<span class="boundvar">c</span>&ensp;<span class="boundvar">l</span>)</code></dt>  <dt id="$resolved375"><code><span class="type resolved" title="Prelude.Uninhabited.Uninhabited"><span class="name type">Uninhabited</span></span>&ensp;(<a class="type" href="Data.FVect.html#Data.FVect.FVect"><span class="name type">FVect</span></a>&ensp;<span class="name constructor">0</span>&ensp;(<span class="type resolved" title="Data.Fin.FS"><span class="name constructor">FS</span></span>&ensp;<span class="boundvar">l</span>)&ensp;<span class="boundvar">e</span>)</code></dt></dl></dd><dt id="Data.FVect.consWeaker"><code><a class="type" href="Data.FVect.html#Data.FVect.consWeaker"><span class="name function">consWeaker</span></a>&ensp;:&ensp;<span class="boundvar">elem</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.FVect.html#Data.FVect.FVect"><span class="name type">FVect</span></a>&ensp;(<span class="type resolved" title="Prelude.Types.S"><span class="name constructor">S</span></span>&ensp;<span class="boundvar">n</span>)&ensp;(<span class="type resolved" title="Data.Fin.weaken"><span class="name function">weaken</span></span>&ensp;<span class="boundvar">len&apos;</span>)&ensp;<span class="boundvar">elem</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.FVect.html#Data.FVect.FVect"><span class="name type">FVect</span></a>&ensp;(<span class="type resolved" title="Prelude.Types.S"><span class="name constructor">S</span></span>&ensp;<span class="boundvar">n</span>)&ensp;(<span class="type resolved" title="Data.Fin.FS"><span class="name constructor">FS</span></span>&ensp;<span class="boundvar">len&apos;</span>)&ensp;<span class="boundvar">elem</span></code></dt><dd><pre>  Cons an element without increasing the capacity of the FVect. You<br>  must make sure the capacity and length of the FVect being consed<br>  onto are accessible in the context where you call this.<br>  <br>  The function signature is a bit tricky because it needs to ensure<br>  you are going from length of type Fin n to length of type Fin n<br>  but calling Fin&apos;s FS constructor increments n. To increment the<br>  value stored without weakening the bounds of the Fin, we go from<br>  (weaken (Fin (S n))) to (FS (Fin (S n))).<br>  <br>  In other words, we go from a weaker input Fin to the succesor of a<br>  stronger bounded Fin.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.FVect.strengthenLT"><code><a class="type" href="Data.FVect.html#Data.FVect.strengthenLT"><span class="name function">strengthenLT</span></a>&ensp;:&ensp;(<span class="boundvar">j</span>&ensp;:&ensp;<span class="type resolved" title="Data.Fin.Fin"><span class="name type">Fin</span></span>&ensp;(<span class="type resolved" title="Prelude.Types.S"><span class="name constructor">S</span></span>&ensp;<span class="boundvar">n</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Data.Nat.LT"><span class="name function">LT</span></span>&ensp;(<span class="type resolved" title="Data.Fin.finToNat"><span class="name function">finToNat</span></span>&ensp;<span class="boundvar">j</span>)&ensp;<span class="boundvar">n</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Data.Fin.Fin"><span class="name type">Fin</span></span>&ensp;<span class="boundvar">n</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.FVect.consLT"><code><a class="type" href="Data.FVect.html#Data.FVect.consLT"><span class="name function">consLT</span></a>&ensp;:&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">ltPrf</span>&ensp;:&ensp;<span class="type resolved" title="Data.Nat.LT"><span class="name function">LT</span></span>&ensp;(<span class="type resolved" title="Data.Fin.finToNat"><span class="name function">finToNat</span></span>&ensp;<span class="boundvar">len</span>)&ensp;(<span class="type resolved" title="Prelude.Types.S"><span class="name constructor">S</span></span>&ensp;<span class="boundvar">n</span>)}&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">elem</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.FVect.html#Data.FVect.FVect"><span class="name type">FVect</span></a>&ensp;(<span class="type resolved" title="Prelude.Types.S"><span class="name constructor">S</span></span>&ensp;<span class="boundvar">n</span>)&ensp;<span class="boundvar">len</span>&ensp;<span class="boundvar">elem</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.FVect.html#Data.FVect.FVect"><span class="name type">FVect</span></a>&ensp;(<span class="type resolved" title="Prelude.Types.S"><span class="name constructor">S</span></span>&ensp;<span class="boundvar">n</span>)&ensp;(<span class="type resolved" title="Data.Fin.FS"><span class="name constructor">FS</span></span>&ensp;(<a class="type" href="Data.FVect.html#Data.FVect.strengthenLT"><span class="name function">strengthenLT</span></a>&ensp;<span class="boundvar">len</span>))&ensp;<span class="boundvar">elem</span></code></dt><dd><pre>  Like `consWeaker`, cons an element onto an FVect without changing<br>  its capacity.<br>  <br>  You need only know that the existing FVect is not at capacity to<br>  know that an element can be consed onto it without increasing the<br>  capacity.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.FVect.(:::)"><code><a class="type" href="Data.FVect.html#Data.FVect.(:::)"><span class="name function">(:::)</span></a>&ensp;:&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">ltPrf</span>&ensp;:&ensp;<span class="type resolved" title="Data.Nat.LT"><span class="name function">LT</span></span>&ensp;(<span class="type resolved" title="Data.Fin.finToNat"><span class="name function">finToNat</span></span>&ensp;<span class="boundvar">len</span>)&ensp;(<span class="type resolved" title="Prelude.Types.S"><span class="name constructor">S</span></span>&ensp;<span class="boundvar">n</span>)}&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">elem</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.FVect.html#Data.FVect.FVect"><span class="name type">FVect</span></a>&ensp;(<span class="type resolved" title="Prelude.Types.S"><span class="name constructor">S</span></span>&ensp;<span class="boundvar">n</span>)&ensp;<span class="boundvar">len</span>&ensp;<span class="boundvar">elem</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.FVect.html#Data.FVect.FVect"><span class="name type">FVect</span></a>&ensp;(<span class="type resolved" title="Prelude.Types.S"><span class="name constructor">S</span></span>&ensp;<span class="boundvar">n</span>)&ensp;(<span class="type resolved" title="Data.Fin.FS"><span class="name constructor">FS</span></span>&ensp;(<a class="type" href="Data.FVect.html#Data.FVect.strengthenLT"><span class="name function">strengthenLT</span></a>&ensp;<span class="boundvar">len</span>))&ensp;<span class="boundvar">elem</span></code></dt><dd><pre>  Like `consWeaker`, cons an element onto an FVect without changing<br>  its capacity.<br>  <br>  You need only know that the existing FVect is not at capacity to<br>  know that an element can be consed onto it without increasing the<br>  capacity.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span><br>  <b>Fixity Declaration</b>:&ensp;infixr&ensp;operator,&ensp;level&ensp;7</dd><dt id="Data.FVect.empty"><code><a class="type" href="Data.FVect.html#Data.FVect.empty"><span class="name function">empty</span></a>&ensp;:&ensp;(<span class="boundvar">capacity</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.FVect.html#Data.FVect.FVect"><span class="name type">FVect</span></a>&ensp;<span class="boundvar">capacity</span>&ensp;<span class="type resolved" title="Data.Fin.FZ"><span class="name constructor">FZ</span></span>&ensp;<span class="boundvar">elem</span></code></dt><dd><pre>  Create an empty FVect with the given capacity.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.FVect.replicate"><code><a class="type" href="Data.FVect.html#Data.FVect.replicate"><span class="name function">replicate</span></a>&ensp;:&ensp;(<span class="boundvar">l</span>&ensp;:&ensp;<span class="type resolved" title="Data.Fin.Fin"><span class="name type">Fin</span></span>&ensp;(<span class="type resolved" title="Prelude.Types.S"><span class="name constructor">S</span></span>&ensp;<span class="boundvar">capacity</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">elem</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.FVect.html#Data.FVect.FVect"><span class="name type">FVect</span></a>&ensp;<span class="boundvar">capacity</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">elem</span></code></dt><dd><pre>  Create an FVect by replicating the given element enough to fill<br>  the needed length.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.FVect.addCapacity"><code><a class="type" href="Data.FVect.html#Data.FVect.addCapacity"><span class="name function">addCapacity</span></a>&ensp;:&ensp;<a class="type" href="Data.FVect.html#Data.FVect.FVect"><span class="name type">FVect</span></a>&ensp;<span class="boundvar">c</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.FVect.html#Data.FVect.FVect"><span class="name type">FVect</span></a>&ensp;(<span class="type resolved" title="Prelude.Types.S"><span class="name constructor">S</span></span>&ensp;<span class="boundvar">c</span>)&ensp;(<span class="type resolved" title="Data.Fin.weaken"><span class="name function">weaken</span></span>&ensp;<span class="boundvar">l</span>)&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Allow FVect to hold one more element. <br>  Do not change the elements currently in the FVect.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.FVect.addCapacityN"><code><a class="type" href="Data.FVect.html#Data.FVect.addCapacityN"><span class="name function">addCapacityN</span></a>&ensp;:&ensp;(<span class="boundvar">n</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.FVect.html#Data.FVect.FVect"><span class="name type">FVect</span></a>&ensp;<span class="boundvar">capacity</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.FVect.html#Data.FVect.FVect"><span class="name type">FVect</span></a>&ensp;(<span class="boundvar">capacity</span>&ensp;<span class="type resolved" title="Prelude.Num.(+)"><span class="name function">+</span></span>&ensp;<span class="boundvar">n</span>)&ensp;(<span class="type resolved" title="Data.Fin.weakenN"><span class="name function">weakenN</span></span>&ensp;<span class="boundvar">n</span>&ensp;<span class="boundvar">l</span>)&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Allow FVect to hold n more elements. <br>  Do not change the elements currently in the FVect.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.FVect.removeCapacity"><code><a class="type" href="Data.FVect.html#Data.FVect.removeCapacity"><span class="name function">removeCapacity</span></a>&ensp;:&ensp;<a class="type" href="Data.FVect.html#Data.FVect.FVect"><span class="name type">FVect</span></a>&ensp;(<span class="type resolved" title="Prelude.Types.S"><span class="name constructor">S</span></span>&ensp;<span class="boundvar">n</span>)&ensp;(<span class="type resolved" title="Data.Fin.weaken"><span class="name function">weaken</span></span>&ensp;<span class="boundvar">len&apos;</span>)&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.FVect.html#Data.FVect.FVect"><span class="name type">FVect</span></a>&ensp;<span class="boundvar">n</span>&ensp;<span class="boundvar">len&apos;</span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Reduce the FVect&apos;s capacity to hold elements.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.FVect.length"><code><a class="type" href="Data.FVect.html#Data.FVect.length"><span class="name function">length</span></a>&ensp;:&ensp;<a class="type" href="Data.FVect.html#Data.FVect.FVect"><span class="name type">FVect</span></a>&ensp;<span class="boundvar">capacity</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span></code></dt><dd><pre>  Calculate the length of the FVect.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.FVect.fromVect"><code><a class="type" href="Data.FVect.html#Data.FVect.fromVect"><span class="name function">fromVect</span></a>&ensp;:&ensp;<span class="type resolved" title="Data.Vect.Vect"><span class="name type">Vect</span></span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.FVect.html#Data.FVect.FVect"><span class="name type">FVect</span></a>&ensp;<span class="boundvar">l</span>&ensp;<span class="type resolved" title="Data.Fin.last"><span class="name function">last</span></span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Get the smallest FVect that can contain the given Vect.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.FVect.toVect"><code><a class="type" href="Data.FVect.html#Data.FVect.toVect"><span class="name function">toVect</span></a>&ensp;:&ensp;<a class="type" href="Data.FVect.html#Data.FVect.FVect"><span class="name type">FVect</span></a>&ensp;<span class="boundvar">c</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">elem</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Data.Vect.Vect"><span class="name type">Vect</span></span>&ensp;(<span class="type resolved" title="Data.Fin.finToNat"><span class="name function">finToNat</span></span>&ensp;<span class="boundvar">l</span>)&ensp;<span class="boundvar">elem</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.FVect.tail"><code><a class="type" href="Data.FVect.html#Data.FVect.tail"><span class="name function">tail</span></a>&ensp;:&ensp;<a class="type" href="Data.FVect.html#Data.FVect.FVect"><span class="name type">FVect</span></a>&ensp;<span class="boundvar">c</span>&ensp;(<span class="type resolved" title="Data.Fin.FS"><span class="name constructor">FS</span></span>&ensp;<span class="boundvar">l</span>)&ensp;<span class="boundvar">elem</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.FVect.html#Data.FVect.FVect"><span class="name type">FVect</span></a>&ensp;<span class="boundvar">c</span>&ensp;(<span class="type resolved" title="Data.Fin.weaken"><span class="name function">weaken</span></span>&ensp;<span class="boundvar">l</span>)&ensp;<span class="boundvar">elem</span></code></dt><dd><pre>  All but the first element of the FVect.<br>  This operation does not change capacity. This means you can carry<br>  out this operation and retain proof that the new FVect length is<br>  less than or equal to the original FVect (although in this case<br>  the length is exactly one less than before the call to tail).</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.FVect.dropFirst"><code><a class="type" href="Data.FVect.html#Data.FVect.dropFirst"><span class="name function">dropFirst</span></a>&ensp;:&ensp;<a class="type" href="Data.FVect.html#Data.FVect.FVect"><span class="name type">FVect</span></a>&ensp;(<span class="type resolved" title="Prelude.Types.S"><span class="name constructor">S</span></span>&ensp;<span class="boundvar">c</span>)&ensp;(<span class="type resolved" title="Data.Fin.FS"><span class="name constructor">FS</span></span>&ensp;<span class="boundvar">l</span>)&ensp;<span class="boundvar">elem</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.FVect.html#Data.FVect.FVect"><span class="name type">FVect</span></a>&ensp;<span class="boundvar">c</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">elem</span></code></dt><dd><pre>  Like tail but reduces the capacity by 1 in addition<br>  to dropping the first element.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.FVect.head"><code><a class="type" href="Data.FVect.html#Data.FVect.head"><span class="name function">head</span></a>&ensp;:&ensp;<a class="type" href="Data.FVect.html#Data.FVect.FVect"><span class="name type">FVect</span></a>&ensp;<span class="boundvar">c</span>&ensp;(<span class="type resolved" title="Data.Fin.FS"><span class="name constructor">FS</span></span>&ensp;<span class="boundvar">l</span>)&ensp;<span class="boundvar">elem</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">elem</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.FVect.last"><code><a class="type" href="Data.FVect.html#Data.FVect.last"><span class="name function">last</span></a>&ensp;:&ensp;<a class="type" href="Data.FVect.html#Data.FVect.FVect"><span class="name type">FVect</span></a>&ensp;<span class="boundvar">c</span>&ensp;(<span class="type resolved" title="Data.Fin.FS"><span class="name constructor">FS</span></span>&ensp;<span class="boundvar">l</span>)&ensp;<span class="boundvar">elem</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">elem</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.FVect.init"><code><a class="type" href="Data.FVect.html#Data.FVect.init"><span class="name function">init</span></a>&ensp;:&ensp;<a class="type" href="Data.FVect.html#Data.FVect.FVect"><span class="name type">FVect</span></a>&ensp;<span class="boundvar">c</span>&ensp;(<span class="type resolved" title="Data.Fin.FS"><span class="name constructor">FS</span></span>&ensp;<span class="boundvar">l</span>)&ensp;<span class="boundvar">elem</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.FVect.html#Data.FVect.FVect"><span class="name type">FVect</span></a>&ensp;<span class="boundvar">c</span>&ensp;(<span class="type resolved" title="Data.Fin.weaken"><span class="name function">weaken</span></span>&ensp;<span class="boundvar">l</span>)&ensp;<span class="boundvar">elem</span></code></dt><dd><pre>  All but the last element of the FVect.<br>  This operation does not change capacity. This means you can carry<br>  out this operation and retain proof that the new FVect length is<br>  less than or equal to the original FVect (although in this case<br>  the length is exactly one less than before the call to tail).</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.FVect.dropLast"><code><a class="type" href="Data.FVect.html#Data.FVect.dropLast"><span class="name function">dropLast</span></a>&ensp;:&ensp;<a class="type" href="Data.FVect.html#Data.FVect.FVect"><span class="name type">FVect</span></a>&ensp;(<span class="type resolved" title="Prelude.Types.S"><span class="name constructor">S</span></span>&ensp;<span class="boundvar">c</span>)&ensp;(<span class="type resolved" title="Data.Fin.FS"><span class="name constructor">FS</span></span>&ensp;<span class="boundvar">l</span>)&ensp;<span class="boundvar">elem</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.FVect.html#Data.FVect.FVect"><span class="name type">FVect</span></a>&ensp;<span class="boundvar">c</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">elem</span></code></dt><dd><pre>  Like init but reduces the capacity by 1 in addition to removing<br>  the last element.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Data.FVect.fVectInjective"><code><a class="type" href="Data.FVect.html#Data.FVect.fVectInjective"><span class="name function">fVectInjective</span></a>&ensp;:&ensp;<span class="boundvar">x</span>&ensp;<a class="type" href="Data.FVect.html#Data.FVect.(::)"><span class="name constructor">::</span></a>&ensp;<span class="boundvar">xs</span>&ensp;<span class="keyword">=</span>&ensp;<span class="boundvar">y</span>&ensp;<a class="type" href="Data.FVect.html#Data.FVect.(::)"><span class="name constructor">::</span></a>&ensp;<span class="boundvar">ys</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">x</span>&ensp;<span class="keyword">=</span>&ensp;<span class="boundvar">y</span>,&ensp;<span class="boundvar">xs</span>&ensp;<span class="keyword">=</span>&ensp;<span class="boundvar">ys</span>)</code></dt><dd><pre>  If two FVects are equal, their heads and tails are equal.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.FVect.addRemoveCapacityInverse"><code><a class="type" href="Data.FVect.html#Data.FVect.addRemoveCapacityInverse"><span class="name function">addRemoveCapacityInverse</span></a>&ensp;:&ensp;(<span class="boundvar">xs</span>&ensp;:&ensp;<a class="type" href="Data.FVect.html#Data.FVect.FVect"><span class="name type">FVect</span></a>&ensp;<span class="boundvar">c</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">elem</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.FVect.html#Data.FVect.removeCapacity"><span class="name function">removeCapacity</span></a>&ensp;(<a class="type" href="Data.FVect.html#Data.FVect.addCapacity"><span class="name function">addCapacity</span></a>&ensp;<span class="boundvar">xs</span>)&ensp;<span class="keyword">=</span>&ensp;<span class="boundvar">xs</span></code></dt><dd><pre>  If you add and then remove capacity, you are left with the<br>  original capacity.<br>  In fact, you are left with exactly the original FVect.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.FVect.lengthReifies"><code><a class="type" href="Data.FVect.html#Data.FVect.lengthReifies"><span class="name function">lengthReifies</span></a>&ensp;:&ensp;(<span class="boundvar">v</span>&ensp;:&ensp;<a class="type" href="Data.FVect.html#Data.FVect.FVect"><span class="name type">FVect</span></a>&ensp;<span class="boundvar">c</span>&ensp;<span class="boundvar">l</span>&ensp;<span class="boundvar">elem</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.FVect.html#Data.FVect.length"><span class="name function">length</span></a>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">=</span>&ensp;<span class="type resolved" title="Data.Fin.finToNat"><span class="name function">finToNat</span></span>&ensp;<span class="boundvar">l</span></code></dt><dd><pre>  The calculated length of an FVect reifies the erased length of the<br>  FVect.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.FVect.catMaybes"><code><a class="type" href="Data.FVect.html#Data.FVect.catMaybes"><span class="name function">catMaybes</span></a>&ensp;:&ensp;<a class="type" href="Data.FVect.html#Data.FVect.FVect"><span class="name type">FVect</span></a>&ensp;<span class="boundvar">capacity</span>&ensp;<span class="boundvar">len</span>&ensp;(<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;<span class="boundvar">elem</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">len&apos;</span>&ensp;:&ensp;<span class="type resolved" title="Data.Fin.Fin"><span class="name type">Fin</span></span>&ensp;(<span class="type resolved" title="Prelude.Types.S"><span class="name constructor">S</span></span>&ensp;<span class="boundvar">capacity</span>)&ensp;<span class="keyword">**</span>&ensp;<a class="type" href="Data.FVect.html#Data.FVect.FVect"><span class="name type">FVect</span></a>&ensp;<span class="boundvar">capacity</span>&ensp;<span class="boundvar">len&apos;</span>&ensp;<span class="boundvar">elem</span>)</code></dt><dd><pre>  Remove all Nothings from the FVect.<br>  This operation does not change capacity. That means you can carry<br>  out this operation and retain proof that the new FVect length is<br>  less than or equal to that of the original FVect.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.FVect.mapMaybes"><code><a class="type" href="Data.FVect.html#Data.FVect.mapMaybes"><span class="name function">mapMaybes</span></a>&ensp;:&ensp;(<span class="boundvar">elem</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;<span class="boundvar">elem&apos;</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.FVect.html#Data.FVect.FVect"><span class="name type">FVect</span></a>&ensp;<span class="boundvar">capacity</span>&ensp;<span class="boundvar">len</span>&ensp;<span class="boundvar">elem</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">len&apos;</span>&ensp;:&ensp;<span class="type resolved" title="Data.Fin.Fin"><span class="name type">Fin</span></span>&ensp;(<span class="type resolved" title="Prelude.Types.S"><span class="name constructor">S</span></span>&ensp;<span class="boundvar">capacity</span>)&ensp;<span class="keyword">**</span>&ensp;<a class="type" href="Data.FVect.html#Data.FVect.FVect"><span class="name type">FVect</span></a>&ensp;<span class="boundvar">capacity</span>&ensp;<span class="boundvar">len&apos;</span>&ensp;<span class="boundvar">elem&apos;</span>)</code></dt><dd><pre>  Map all elements, removing any Nothings along the way.<br>  This operation does not change capacity. That means you can carry<br>  out this operation and retain proof that the new FVect length is<br>  less than or equal to that of the original FVect.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.FVect.filter"><code><a class="type" href="Data.FVect.html#Data.FVect.filter"><span class="name function">filter</span></a>&ensp;:&ensp;(<span class="boundvar">elem</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.FVect.html#Data.FVect.FVect"><span class="name type">FVect</span></a>&ensp;<span class="boundvar">capacity</span>&ensp;<span class="boundvar">len</span>&ensp;<span class="boundvar">elem</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">len&apos;</span>&ensp;:&ensp;<span class="type resolved" title="Data.Fin.Fin"><span class="name type">Fin</span></span>&ensp;(<span class="type resolved" title="Prelude.Types.S"><span class="name constructor">S</span></span>&ensp;<span class="boundvar">capacity</span>)&ensp;<span class="keyword">**</span>&ensp;<a class="type" href="Data.FVect.html#Data.FVect.FVect"><span class="name type">FVect</span></a>&ensp;<span class="boundvar">capacity</span>&ensp;<span class="boundvar">len&apos;</span>&ensp;<span class="boundvar">elem</span>)</code></dt><dd><pre>  Filter down to only elements matching the predicate.<br>  This operation does not change capacity. That means you can carry<br>  out this operation and retain proof that the new FVect length is<br>  less than or equal to that of the original FVect.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd></dl></div><footer>Produced by Idris 2 version 0.7.0-da352d8ed</footer></body></html>
