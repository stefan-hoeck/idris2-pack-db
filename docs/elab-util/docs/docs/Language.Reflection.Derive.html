<!DOCTYPE html><html lang="en">

<head>
  <meta charset="utf-8">
  <title>Language.Reflection.Derive</title>
  <link rel="stylesheet" type="text/css" id="preferredStyle" href="../default.css">
  <script>
    /* Updates the stylesheet to use the preferred one.
       Note that we set the link to root ++ sourceLoc because the config
       is shared across the whole website, so the root may differ from
       page to page.
    */
    function setStyleSource (sourceLoc) {
      document.getElementById("preferredStyle").href = "../" + sourceLoc + ".css";
      document.getElementById("selectPreferredStyle").value = sourceLoc;
    }
    /* Initialises the preferred style sheet:
       1. if there is a stored value then use that
          otherwise select the default
       2. set both the css link href & the drop down menu selected option
    */
    function initStyleSource () {
      var preferredStyle = localStorage.getItem("stylefile");
      if (preferredStyle !== null) {
        setStyleSource(preferredStyle);
      } else {
        setStyleSource("default");
      };
    }
    function saveStyleSource (preferredStyle) {
      localStorage.stylefile = preferredStyle;
    }
    </script>
</head>

<body class="namespace">
<header>
  <strong>Idris2Doc</strong> : Language.Reflection.Derive
  <nav><a href="../index.html">Index</a>

  <select id="selectPreferredStyle">
    <option value="default">Default</option>
<option value="alternative">Alternative</option>
<option value="blackandwhite">Black & White</option>

  </select>
  </nav>

  <script>
  /* We start by initialising the style source */
  initStyleSource();

  /* This listens for changes on the drop down menu and updates the
     css used for the current page when a selection is made.
  */
  document.getElementById("selectPreferredStyle").addEventListener("change", function(){
    var selected = this.options[this.selectedIndex].value; /* the option chosen */
    setStyleSource (selected);
    saveStyleSource (selected);
  });
</script>

</header>
<div class="container"><div id="module-header"><h1>Language.Reflection.Derive</h1><span style="float:right">(<a href="Language.Reflection.Derive.src.html">source</a>)</span><pre>Utility types and functions for automatically deriving
interface instances. So far, this module does not provide
deriving functions for existing interfaces. See
Doc.Generic4 for examples, how this could be done
using the functionality provided here.
</pre></div><code></code><h2>Definitions</h2><dl class="decls"><dt id="Language.Reflection.Derive.Elaborateable"><code><span class="keyword">interface</span>&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.Elaborateable"><span class="name type">Elaborateable</span></a>&ensp;:&ensp;<span class="name type">Type</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd><pre>  Interface for named things that can be looked up by name using<br>  elaborator reflection.</pre><br>  <b>Parameters</b>:&ensp;a<br><b>Constraints</b>:&ensp;Named&ensp;a<br><b>Methods</b>:<br><dl class="decls">  <dt id="Language.Reflection.Derive.find_"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.find_"><span class="name function">find_</span></a>&ensp;:&ensp;<span class="type resolved" title="Language.Reflection.Elaboration"><span class="name type">Elaboration</span></span>&ensp;<span class="boundvar">m</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TT.Name"><span class="name type">Name</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">m</span>&ensp;<span class="boundvar">a</span></code></dt></dl><br><b>Implementation</b>:&ensp;<dl class="decls"><dt id="$resolved3247"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.Elaborateable"><span class="name type">Elaborateable</span></a>&ensp;<a class="type" href="Language.Reflection.Types.html#Language.Reflection.Types.TypeInfo"><span class="name type">TypeInfo</span></a></code></dt></dl></dd><dt id="Language.Reflection.Derive.find_"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.find_"><span class="name function">find_</span></a>&ensp;:&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.Elaborateable"><span class="name type">Elaborateable</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.Elaboration"><span class="name type">Elaboration</span></span>&ensp;<span class="boundvar">m</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TT.Name"><span class="name type">Name</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">m</span>&ensp;<span class="boundvar">a</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Language.Reflection.Derive.find"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.find"><span class="name function">find</span></a>&ensp;:&ensp;(<span class="keyword">0</span>&ensp;<span class="boundvar">a</span>&ensp;:&ensp;<span class="name type">Type</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.Elaborateable"><span class="name type">Elaborateable</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.Elaboration"><span class="name type">Elaboration</span></span>&ensp;<span class="boundvar">m</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TT.Name"><span class="name type">Name</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">m</span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Utility version of `find_` taking an explicit type argument.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Language.Reflection.Derive.funName"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.funName"><span class="name function">funName</span></a>&ensp;:&ensp;<a class="type" href="Language.Reflection.Syntax.html#Language.Reflection.Syntax.Named"><span class="name type">Named</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">String</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TT.Name"><span class="name type">Name</span></span></code></dt><dd><pre>  Generates the name of a function implementing some functionality<br>  for the given type.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Derive.implName"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.implName"><span class="name function">implName</span></a>&ensp;:&ensp;<a class="type" href="Language.Reflection.Syntax.html#Language.Reflection.Syntax.Named"><span class="name type">Named</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">String</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TT.Name"><span class="name type">Name</span></span></code></dt><dd><pre>  Generates the name of an interface&apos;s implementation function</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Derive.BoundArg"><code><span class="keyword">record</span>&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.BoundArg"><span class="name type">BoundArg</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<a class="type" href="Language.Reflection.Syntax.html#Language.Reflection.Syntax.Arg"><span class="name type">Arg</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd><pre>  A single constructor argument, for which we have `n` bound<br>  variables on the left hand side of a pattern match clause, and<br>  which is refined by predicate `p`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span><br>  <b>Constructor</b>:&ensp;<dl class="decls"><dt id="Language.Reflection.Derive.BA"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.BA"><span class="name constructor">BA</span></a>&ensp;:&ensp;(<span class="boundvar">arg</span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Syntax.html#Language.Reflection.Syntax.Arg"><span class="name type">Arg</span></a>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Data.Vect.Vect"><span class="name type">Vect</span></span>&ensp;<span class="boundvar">n</span>&ensp;<span class="name type">String</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">arg</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.BoundArg"><span class="name type">BoundArg</span></a>&ensp;<span class="boundvar">n</span>&ensp;<span class="boundvar">p</span></code></dt></dl><br>  <b>Projections</b>:<br><dl class="decls">  <dt id="Language.Reflection.Derive.BoundArg.(.arg)"><code><span class="type resolved" title="Language.Reflection.Derive.BoundArg.(.arg)"><span class="name function">.arg</span></span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.BoundArg"><span class="name type">BoundArg</span></a>&ensp;<span class="boundvar">n</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Language.Reflection.Syntax.html#Language.Reflection.Syntax.Arg"><span class="name type">Arg</span></a></code></dt>  <dt id="Language.Reflection.Derive.BoundArg.(.prf)"><code><span class="type resolved" title="Language.Reflection.Derive.BoundArg.(.prf)"><span class="name function">.prf</span></span>&ensp;:&ensp;(<span class="boundvar">{rec:0}</span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.BoundArg"><span class="name type">BoundArg</span></a>&ensp;<span class="boundvar">n</span>&ensp;<span class="boundvar">p</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;(<span class="type resolved" title="Language.Reflection.Derive.BoundArg.arg"><span class="name function">arg</span></span>&ensp;<span class="boundvar">{rec:0}</span>)</code></dt>  <dt id="Language.Reflection.Derive.BoundArg.(.vars)"><code><span class="type resolved" title="Language.Reflection.Derive.BoundArg.(.vars)"><span class="name function">.vars</span></span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.BoundArg"><span class="name type">BoundArg</span></a>&ensp;<span class="boundvar">n</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Data.Vect.Vect"><span class="name type">Vect</span></span>&ensp;<span class="boundvar">n</span>&ensp;<span class="name type">String</span></code></dt></dl></dd><dt id="Language.Reflection.Derive.BoundArg.(.arg)"><code><span class="type resolved" title="Language.Reflection.Derive.BoundArg.(.arg)"><span class="name function">.arg</span></span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.BoundArg"><span class="name type">BoundArg</span></a>&ensp;<span class="boundvar">n</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Language.Reflection.Syntax.html#Language.Reflection.Syntax.Arg"><span class="name type">Arg</span></a></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Language.Reflection.Derive.BoundArg.arg"><code><span class="type resolved" title="Language.Reflection.Derive.BoundArg.arg"><span class="name function">arg</span></span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.BoundArg"><span class="name type">BoundArg</span></a>&ensp;<span class="boundvar">n</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Language.Reflection.Syntax.html#Language.Reflection.Syntax.Arg"><span class="name type">Arg</span></a></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Language.Reflection.Derive.BoundArg.(.vars)"><code><span class="type resolved" title="Language.Reflection.Derive.BoundArg.(.vars)"><span class="name function">.vars</span></span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.BoundArg"><span class="name type">BoundArg</span></a>&ensp;<span class="boundvar">n</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Data.Vect.Vect"><span class="name type">Vect</span></span>&ensp;<span class="boundvar">n</span>&ensp;<span class="name type">String</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Language.Reflection.Derive.BoundArg.vars"><code><span class="type resolved" title="Language.Reflection.Derive.BoundArg.vars"><span class="name function">vars</span></span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.BoundArg"><span class="name type">BoundArg</span></a>&ensp;<span class="boundvar">n</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Data.Vect.Vect"><span class="name type">Vect</span></span>&ensp;<span class="boundvar">n</span>&ensp;<span class="name type">String</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Language.Reflection.Derive.BoundArg.(.prf)"><code><span class="type resolved" title="Language.Reflection.Derive.BoundArg.(.prf)"><span class="name function">.prf</span></span>&ensp;:&ensp;(<span class="boundvar">{rec:0}</span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.BoundArg"><span class="name type">BoundArg</span></a>&ensp;<span class="boundvar">n</span>&ensp;<span class="boundvar">p</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;(<span class="type resolved" title="Language.Reflection.Derive.BoundArg.arg"><span class="name function">arg</span></span>&ensp;<span class="boundvar">{rec:0}</span>)</code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Language.Reflection.Derive.BoundArg.prf"><code><span class="type resolved" title="Language.Reflection.Derive.BoundArg.prf"><span class="name function">prf</span></span>&ensp;:&ensp;(<span class="boundvar">{rec:0}</span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.BoundArg"><span class="name type">BoundArg</span></a>&ensp;<span class="boundvar">n</span>&ensp;<span class="boundvar">p</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">p</span>&ensp;(<span class="type resolved" title="Language.Reflection.Derive.BoundArg.arg"><span class="name function">arg</span></span>&ensp;<span class="boundvar">{rec:0}</span>)</code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Language.Reflection.Derive.split"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.split"><span class="name function">split</span></a>&ensp;:&ensp;<span class="type resolved" title="Data.Vect.Vect"><span class="name type">Vect</span></span>&ensp;<span class="boundvar">k</span>&ensp;(<span class="type resolved" title="Data.Vect.Vect"><span class="name type">Vect</span></span>&ensp;(<span class="type resolved" title="Prelude.Types.S"><span class="name constructor">S</span></span>&ensp;<span class="boundvar">n</span>)&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="type resolved" title="Data.Vect.Vect"><span class="name type">Vect</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">a</span>,&ensp;<span class="type resolved" title="Data.Vect.Vect"><span class="name type">Vect</span></span>&ensp;<span class="boundvar">k</span>&ensp;(<span class="type resolved" title="Data.Vect.Vect"><span class="name type">Vect</span></span>&ensp;<span class="boundvar">n</span>&ensp;<span class="boundvar">a</span>))</code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Language.Reflection.Derive.boundArgs"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.boundArgs"><span class="name function">boundArgs</span></a>&ensp;:&ensp;((<span class="boundvar">a</span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Syntax.html#Language.Reflection.Syntax.Arg"><span class="name type">Arg</span></a>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;(<span class="boundvar">p</span>&ensp;<span class="boundvar">a</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Data.Vect.Vect"><span class="name type">Vect</span></span>&ensp;<span class="boundvar">n</span>&ensp;<a class="type" href="Language.Reflection.Syntax.html#Language.Reflection.Syntax.Arg"><span class="name type">Arg</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Data.Vect.Vect"><span class="name type">Vect</span></span>&ensp;<span class="boundvar">k</span>&ensp;(<span class="type resolved" title="Data.Vect.Vect"><span class="name type">Vect</span></span>&ensp;<span class="boundvar">n</span>&ensp;<span class="name type">String</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.SnocList"><span class="name type">SnocList</span></span>&ensp;(<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.BoundArg"><span class="name type">BoundArg</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">p</span>)</code></dt><dd><pre>  Refine a list of constructor arguments with the given predicate<br>  and pair them with a number of bound variable names.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Derive.Explicit"><code><span class="keyword">data</span>&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.Explicit"><span class="name type">Explicit</span></a>&ensp;:&ensp;<a class="type" href="Language.Reflection.Syntax.html#Language.Reflection.Syntax.Arg"><span class="name type">Arg</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span><br>  <b>Constructor</b>:&ensp;<dl class="decls"><dt id="Language.Reflection.Derive.IsExplicit"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.IsExplicit"><span class="name constructor">IsExplicit</span></a>&ensp;:&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.Explicit"><span class="name type">Explicit</span></a>&ensp;(<a class="type" href="Language.Reflection.Syntax.html#Language.Reflection.Syntax.MkArg"><span class="name constructor">MkArg</span></a>&ensp;<span class="boundvar">c</span>&ensp;<span class="type resolved" title="Language.Reflection.TT.ExplicitArg"><span class="name constructor">ExplicitArg</span></span>&ensp;<span class="boundvar">n</span>&ensp;<span class="boundvar">t</span>)</code></dt></dl></dd><dt id="Language.Reflection.Derive.explicit"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.explicit"><span class="name function">explicit</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Syntax.html#Language.Reflection.Syntax.Arg"><span class="name type">Arg</span></a>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;(<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.Explicit"><span class="name type">Explicit</span></a>&ensp;<span class="boundvar">a</span>)</code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Language.Reflection.Derive.NamedArg"><code><span class="keyword">data</span>&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.NamedArg"><span class="name type">NamedArg</span></a>&ensp;:&ensp;<a class="type" href="Language.Reflection.Syntax.html#Language.Reflection.Syntax.Arg"><span class="name type">Arg</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span><br>  <b>Constructor</b>:&ensp;<dl class="decls"><dt id="Language.Reflection.Derive.IsNamed"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.IsNamed"><span class="name constructor">IsNamed</span></a>&ensp;:&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.NamedArg"><span class="name type">NamedArg</span></a>&ensp;(<a class="type" href="Language.Reflection.Syntax.html#Language.Reflection.Syntax.MkArg"><span class="name constructor">MkArg</span></a>&ensp;<span class="boundvar">c</span>&ensp;<span class="boundvar">p</span>&ensp;(<span class="type resolved" title="Prelude.Types.Just"><span class="name constructor">Just</span></span>&ensp;(<span class="type resolved" title="Language.Reflection.TT.UN"><span class="name constructor">UN</span></span>&ensp;(<span class="type resolved" title="Language.Reflection.TT.Basic"><span class="name constructor">Basic</span></span>&ensp;<span class="boundvar">n</span>)))&ensp;<span class="boundvar">t</span>)</code></dt></dl></dd><dt id="Language.Reflection.Derive.named"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.named"><span class="name function">named</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Syntax.html#Language.Reflection.Syntax.Arg"><span class="name type">Arg</span></a>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;(<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.NamedArg"><span class="name type">NamedArg</span></a>&ensp;<span class="boundvar">a</span>)</code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Language.Reflection.Derive.argName"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.argName"><span class="name function">argName</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Syntax.html#Language.Reflection.Syntax.Arg"><span class="name type">Arg</span></a>)&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.NamedArg"><span class="name type">NamedArg</span></a>&ensp;<span class="boundvar">a</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TT.Name"><span class="name type">Name</span></span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Language.Reflection.Derive.Unerased"><code><span class="keyword">data</span>&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.Unerased"><span class="name type">Unerased</span></a>&ensp;:&ensp;<a class="type" href="Language.Reflection.Syntax.html#Language.Reflection.Syntax.Arg"><span class="name type">Arg</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span><br>  <b>Constructors</b>:<br><dl class="decls">  <dt id="Language.Reflection.Derive.U1"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.U1"><span class="name constructor">U1</span></a>&ensp;:&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.Unerased"><span class="name type">Unerased</span></a>&ensp;(<a class="type" href="Language.Reflection.Syntax.html#Language.Reflection.Syntax.MkArg"><span class="name constructor">MkArg</span></a>&ensp;<span class="type resolved" title="Language.Reflection.TT.M1"><span class="name constructor">M1</span></span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">n</span>&ensp;<span class="boundvar">t</span>)</code></dt>  <dt id="Language.Reflection.Derive.UW"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.UW"><span class="name constructor">UW</span></a>&ensp;:&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.Unerased"><span class="name type">Unerased</span></a>&ensp;(<a class="type" href="Language.Reflection.Syntax.html#Language.Reflection.Syntax.MkArg"><span class="name constructor">MkArg</span></a>&ensp;<span class="type resolved" title="Language.Reflection.TT.MW"><span class="name constructor">MW</span></span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">n</span>&ensp;<span class="boundvar">t</span>)</code></dt></dl></dd><dt id="Language.Reflection.Derive.unerased"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.unerased"><span class="name function">unerased</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Syntax.html#Language.Reflection.Syntax.Arg"><span class="name type">Arg</span></a>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;(<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.Unerased"><span class="name type">Unerased</span></a>&ensp;<span class="boundvar">a</span>)</code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Language.Reflection.Derive.Erased"><code><span class="keyword">data</span>&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.Erased"><span class="name type">Erased</span></a>&ensp;:&ensp;<a class="type" href="Language.Reflection.Syntax.html#Language.Reflection.Syntax.Arg"><span class="name type">Arg</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span><br>  <b>Constructor</b>:&ensp;<dl class="decls"><dt id="Language.Reflection.Derive.IsErased"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.IsErased"><span class="name constructor">IsErased</span></a>&ensp;:&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.Erased"><span class="name type">Erased</span></a>&ensp;(<a class="type" href="Language.Reflection.Syntax.html#Language.Reflection.Syntax.MkArg"><span class="name constructor">MkArg</span></a>&ensp;<span class="type resolved" title="Language.Reflection.TT.M0"><span class="name constructor">M0</span></span>&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">n</span>&ensp;<span class="boundvar">t</span>)</code></dt></dl></dd><dt id="Language.Reflection.Derive.erased"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.erased"><span class="name function">erased</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Syntax.html#Language.Reflection.Syntax.Arg"><span class="name type">Arg</span></a>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;(<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.Erased"><span class="name type">Erased</span></a>&ensp;<span class="boundvar">a</span>)</code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Language.Reflection.Derive.Regular"><code><span class="keyword">0</span>&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.Regular"><span class="name function">Regular</span></a>&ensp;:&ensp;<a class="type" href="Language.Reflection.Syntax.html#Language.Reflection.Syntax.Arg"><span class="name type">Arg</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Language.Reflection.Derive.regular"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.regular"><span class="name function">regular</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Syntax.html#Language.Reflection.Syntax.Arg"><span class="name type">Arg</span></a>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;(<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.Regular"><span class="name function">Regular</span></a>&ensp;<span class="boundvar">a</span>)</code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Language.Reflection.Derive.RegularNamed"><code><span class="keyword">0</span>&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.RegularNamed"><span class="name function">RegularNamed</span></a>&ensp;:&ensp;<a class="type" href="Language.Reflection.Syntax.html#Language.Reflection.Syntax.Arg"><span class="name type">Arg</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Language.Reflection.Derive.regularNamed"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.regularNamed"><span class="name function">regularNamed</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Syntax.html#Language.Reflection.Syntax.Arg"><span class="name type">Arg</span></a>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;(<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.RegularNamed"><span class="name function">RegularNamed</span></a>&ensp;<span class="boundvar">a</span>)</code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Language.Reflection.Derive.NamedExplicit"><code><span class="keyword">0</span>&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.NamedExplicit"><span class="name function">NamedExplicit</span></a>&ensp;:&ensp;<a class="type" href="Language.Reflection.Syntax.html#Language.Reflection.Syntax.Arg"><span class="name type">Arg</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Language.Reflection.Derive.namedExplicit"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.namedExplicit"><span class="name function">namedExplicit</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Syntax.html#Language.Reflection.Syntax.Arg"><span class="name type">Arg</span></a>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;(<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.NamedExplicit"><span class="name function">NamedExplicit</span></a>&ensp;<span class="boundvar">a</span>)</code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Language.Reflection.Derive.toNamed"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.toNamed"><span class="name function">toNamed</span></a>&ensp;:&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.BoundArg"><span class="name type">BoundArg</span></a>&ensp;<span class="boundvar">n</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;(<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.BoundArg"><span class="name type">BoundArg</span></a>&ensp;<span class="boundvar">n</span>&ensp;(\<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.NamedArg"><span class="name type">NamedArg</span></a>&ensp;<span class="boundvar">a</span>,&ensp;<span class="boundvar">p</span>&ensp;<span class="boundvar">a</span>)))</code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Language.Reflection.Derive.failRecord"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.failRecord"><span class="name function">failRecord</span></a>&ensp;:&ensp;<span class="name type">String</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Language.Reflection.Types.html#Language.Reflection.Types.Res"><span class="name function">Res</span></a>&ensp;<span class="boundvar">a</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Derive.accumArgs"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.accumArgs"><span class="name function">accumArgs</span></a>&ensp;:&ensp;((<span class="boundvar">a</span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Syntax.html#Language.Reflection.Syntax.Arg"><span class="name type">Arg</span></a>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;(<span class="boundvar">p</span>&ensp;<span class="boundvar">a</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="type resolved" title="Prelude.Basics.SnocList"><span class="name type">SnocList</span></span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.BoundArg"><span class="name type">BoundArg</span></a>&ensp;<span class="name constructor">1</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Language.Reflection.Types.html#Language.Reflection.Types.Con"><span class="name type">Con</span></a>&ensp;<span class="boundvar">n</span>&ensp;<span class="boundvar">vs</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.Clause"><span class="name type">Clause</span></span></code></dt><dd><pre>  Generates a pattern clause for accumulating the arguments<br>  of a singled data constructor.<br>  <br>  This is used, for instance, to implement `showPrec`, when<br>  deriving `Show` implementations.<br>  <br>  @ p   : The predicate used to refine the constructor&apos;s arguments<br>  <br>  @ f   : Refining function.<br>  <br>  @ lhs : Adjusts the left-hand side of the clause.<br>          The argument corresponds to the constructor with<br>          all explicit arguments bound to variables named<br>          `x0`, `x1` etc.<br>  <br>  @ rhs : Adjusts the right-hand side of the clause.<br>          The `SnocList` contains the arguments, as transformed<br>          by `arg`.<br>  <br>  @ arg : Processes a single argument<br>  <br>  @ con : The constructor to process.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Derive.accumArgs2"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.accumArgs2"><span class="name function">accumArgs2</span></a>&ensp;:&ensp;((<span class="boundvar">a</span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Syntax.html#Language.Reflection.Syntax.Arg"><span class="name type">Arg</span></a>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;(<span class="boundvar">p</span>&ensp;<span class="boundvar">a</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="type resolved" title="Prelude.Basics.SnocList"><span class="name type">SnocList</span></span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.BoundArg"><span class="name type">BoundArg</span></a>&ensp;<span class="name constructor">2</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Language.Reflection.Types.html#Language.Reflection.Types.Con"><span class="name type">Con</span></a>&ensp;<span class="boundvar">n</span>&ensp;<span class="boundvar">vs</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.Clause"><span class="name type">Clause</span></span></code></dt><dd><pre>  Generates a pattern clause for accumulating the arguments<br>  of two equivalent data constructors.<br>  <br>  This is used, for instance, to implement `(==)`, when<br>  deriving `Eq` implementations.<br>  <br>  @ p   : The predicate used to refine the constructor&apos;s arguments<br>  <br>  @ f   : Refining function.<br>  <br>  @ lhs : Adjusts the left-hand side of the clause.<br>          The first argument corresponds to the constructor with<br>          all explicit arguments bound to variables named<br>          `x0`, `x1` etc., the second to the constructor<br>          with bound explicit arguments namd `y0`, `y1` etc.<br>  <br>  @ rhs : Adjusts the right-hand side of the clause.<br>          The `SnocList` contains the arguments, as transformed<br>          by `arg`.<br>  <br>  @ arg : Processes a single pair of arguments<br>  <br>  @ con : The constructor to process.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Derive.mapArgs"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.mapArgs"><span class="name function">mapArgs</span></a>&ensp;:&ensp;((<span class="boundvar">a</span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Syntax.html#Language.Reflection.Syntax.Arg"><span class="name type">Arg</span></a>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;(<span class="boundvar">p</span>&ensp;<span class="boundvar">a</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.BoundArg"><span class="name type">BoundArg</span></a>&ensp;<span class="name constructor">1</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Language.Reflection.Types.html#Language.Reflection.Types.Con"><span class="name type">Con</span></a>&ensp;<span class="boundvar">n</span>&ensp;<span class="boundvar">vs</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.Clause"><span class="name type">Clause</span></span></code></dt><dd><pre>  Generates a pattern clause for mapping the arguments<br>  of a data constructors over a unary function.<br>  <br>  This is used, for instance, to implement `abs`, when<br>  deriving `Abs` implementations.<br>  <br>  @ p   : The predicate used to refine the constructor&apos;s arguments<br>  <br>  @ f   : Refining function.<br>  <br>  @ lhs : Adjusts the left-hand side of the clause.<br>          The argument corresponds to the constructor with<br>          all explicit arguments bound to variables named<br>          `x0`, `x1` etc.<br>  <br>  @ arg : Processes a single argument<br>  <br>  @ con : The constructor to process.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Derive.mapArgs2"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.mapArgs2"><span class="name function">mapArgs2</span></a>&ensp;:&ensp;((<span class="boundvar">a</span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Syntax.html#Language.Reflection.Syntax.Arg"><span class="name type">Arg</span></a>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;(<span class="boundvar">p</span>&ensp;<span class="boundvar">a</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.BoundArg"><span class="name type">BoundArg</span></a>&ensp;<span class="name constructor">2</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Language.Reflection.Types.html#Language.Reflection.Types.Con"><span class="name type">Con</span></a>&ensp;<span class="boundvar">n</span>&ensp;<span class="boundvar">vs</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.Clause"><span class="name type">Clause</span></span></code></dt><dd><pre>  Generates a pattern clause for mapping the arguments<br>  of two data constructors over a binary function.<br>  <br>  This is used, for instance, to implement `(+)`, when<br>  deriving `Num` implementations.<br>  <br>  @ p   : The predicate used to refine the constructor&apos;s arguments<br>  <br>  @ f   : Refining function.<br>  <br>  @ lhs : Adjusts the left-hand side of the clause.<br>          The first argument corresponds to the constructor with<br>          all explicit arguments bound to variables named<br>          `x0`, `x1` etc., the second to the constructor<br>          with bound explicit arguments namd `y0`, `y1` etc.<br>  <br>  @ arg : Processes a pair of arguments<br>  <br>  @ con : The constructor to process.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Derive.injArgs"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.injArgs"><span class="name function">injArgs</span></a>&ensp;:&ensp;((<span class="boundvar">a</span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Syntax.html#Language.Reflection.Syntax.Arg"><span class="name type">Arg</span></a>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;(<span class="boundvar">p</span>&ensp;<span class="boundvar">a</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;(<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.BoundArg"><span class="name type">BoundArg</span></a>&ensp;<span class="name constructor">0</span>&ensp;<span class="boundvar">p</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Language.Reflection.Types.html#Language.Reflection.Types.Con"><span class="name type">Con</span></a>&ensp;<span class="boundvar">n</span>&ensp;<span class="boundvar">vs</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span></code></dt><dd><pre>  Generates a pattern clause for creating and applying<br>  constructor arguments.<br>  <br>  This is used, for instance, to implement `fromInteger`, when<br>  deriving `Num` implementations for record types.<br>  <br>  @ p   : The predicate used to refine the constructor&apos;s arguments<br>  <br>  @ f   : Refining function.<br>  <br>  @ arg : Processes a single argument<br>  <br>  @ con : The constructor to process.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Derive.TopLevel"><code><span class="keyword">record</span>&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.TopLevel"><span class="name type">TopLevel</span></a>&ensp;:&ensp;<span class="name type">Type</span></code></dt><dd><pre>  A top-level declaration plus its definition.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span><br>  <b>Constructor</b>:&ensp;<dl class="decls"><dt id="Language.Reflection.Derive.TL"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.TL"><span class="name constructor">TL</span></a>&ensp;:&ensp;<span class="type resolved" title="Language.Reflection.TTImp.Decl"><span class="name type">Decl</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.Decl"><span class="name type">Decl</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.TopLevel"><span class="name type">TopLevel</span></a></code></dt></dl><br>  <b>Projections</b>:<br><dl class="decls">  <dt id="Language.Reflection.Derive.TopLevel.(.claim)"><code><span class="type resolved" title="Language.Reflection.Derive.TopLevel.(.claim)"><span class="name function">.claim</span></span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.TopLevel"><span class="name type">TopLevel</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.Decl"><span class="name type">Decl</span></span></code></dt>  <dt id="Language.Reflection.Derive.TopLevel.(.defn)"><code><span class="type resolved" title="Language.Reflection.Derive.TopLevel.(.defn)"><span class="name function">.defn</span></span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.TopLevel"><span class="name type">TopLevel</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.Decl"><span class="name type">Decl</span></span></code></dt></dl></dd><dt id="Language.Reflection.Derive.TopLevel.(.claim)"><code><span class="type resolved" title="Language.Reflection.Derive.TopLevel.(.claim)"><span class="name function">.claim</span></span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.TopLevel"><span class="name type">TopLevel</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.Decl"><span class="name type">Decl</span></span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Language.Reflection.Derive.TopLevel.claim"><code><span class="type resolved" title="Language.Reflection.Derive.TopLevel.claim"><span class="name function">claim</span></span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.TopLevel"><span class="name type">TopLevel</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.Decl"><span class="name type">Decl</span></span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Language.Reflection.Derive.TopLevel.(.defn)"><code><span class="type resolved" title="Language.Reflection.Derive.TopLevel.(.defn)"><span class="name function">.defn</span></span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.TopLevel"><span class="name type">TopLevel</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.Decl"><span class="name type">Decl</span></span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Language.Reflection.Derive.TopLevel.defn"><code><span class="type resolved" title="Language.Reflection.Derive.TopLevel.defn"><span class="name function">defn</span></span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.TopLevel"><span class="name type">TopLevel</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.Decl"><span class="name type">Decl</span></span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Language.Reflection.Derive.implClaimVis"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.implClaimVis"><span class="name function">implClaimVis</span></a>&ensp;:&ensp;<span class="type resolved" title="Language.Reflection.TT.Visibility"><span class="name type">Visibility</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TT.Name"><span class="name type">Name</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.Decl"><span class="name type">Decl</span></span></code></dt><dd><pre>  Creates a function declaration with a `%hint` and `%inline`<br>  annotation.<br>  <br>  This is what you want if you use separate top-level function<br>  for the interface&apos;s implementation and the actual implementation<br>  just adds those functions to the interface constructor.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Language.Reflection.Derive.implClaim"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.implClaim"><span class="name function">implClaim</span></a>&ensp;:&ensp;<span class="type resolved" title="Language.Reflection.TT.Name"><span class="name type">Name</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.Decl"><span class="name type">Decl</span></span></code></dt><dd><pre>  Creates a function declaration with a `%hint` and `%inline`<br>  annotation.<br>  <br>  This is what you want if you use separate top-level function<br>  for the interface&apos;s implementation and the actual implementation<br>  just adds those functions to the interface constructor.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Language.Reflection.Derive.implType"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.implType"><span class="name function">implType</span></a>&ensp;:&ensp;<span class="type resolved" title="Language.Reflection.TT.Name"><span class="name type">Name</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Language.Reflection.Types.html#Language.Reflection.Types.ParamTypeInfo"><span class="name type">ParamTypeInfo</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span></code></dt><dd><pre>  Creates the function type for an interface implementation including<br>  the required implicit and auto-implicit arguments.<br>  <br>  For instance, if `Name` is `&quot;Eq&quot;` and the data type in question is<br>  `Either` with parameter names `a` and `b`, the `TTImp` returned<br>  corresponds to<br>  <br>  ```idris<br>  {0 a : _} -&gt; {0 b : _} -&gt; Eq a =&gt; Eq b =&gt; Eq (Either a b)`<br>  ```</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Derive.unAppAny"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.unAppAny"><span class="name function">unAppAny</span></a>&ensp;:&ensp;<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span></code></dt><dd><pre>  Extracts the innermost target of a function application.<br>  For instance, for `Foo @{bar} baz {n = 12}`, this will extract `Foo`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Derive.extractResult"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.extractResult"><span class="name function">extractResult</span></a>&ensp;:&ensp;<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;(<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span>,&ensp;<span class="type resolved" title="Language.Reflection.TT.Name"><span class="name type">Name</span></span>)</code></dt><dd><pre>  Tries to extract the result type from the current goal when<br>  deriving custom interface implementations.<br>  <br>  For instance, if the goal type is `Eq (Either a b)`, this<br>  returns a `TTImp` corresponding to `Either a b` plus the<br>  name of the data constructor `Either`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Derive.sequenceJoin"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.sequenceJoin"><span class="name function">sequenceJoin</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Interfaces.Applicative"><span class="name type">Applicative</span></span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;(<span class="boundvar">f</span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>)</code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Derive.ParamInfo"><code><span class="keyword">record</span>&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.ParamInfo"><span class="name type">ParamInfo</span></a>&ensp;:&ensp;<span class="name type">Type</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span><br>  <b>Constructor</b>:&ensp;<dl class="decls"><dt id="Language.Reflection.Derive.PI"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.PI"><span class="name constructor">PI</span></a>&ensp;:&ensp;<span class="type resolved" title="Language.Reflection.TT.Name"><span class="name type">Name</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;((<span class="boundvar">n</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;(<span class="implicit"><span class="name type">Exists</span></span>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>&ensp;(<a class="type" href="Language.Reflection.Types.html#Language.Reflection.Types.ParamPattern"><span class="name type">ParamPattern</span></a>&ensp;<span class="boundvar">n</span>)))&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="type resolved" title="Language.Reflection.TT.Name"><span class="name type">Name</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Language.Reflection.Types.html#Language.Reflection.Types.ParamTypeInfo"><span class="name type">ParamTypeInfo</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Language.Reflection.Types.html#Language.Reflection.Types.Res"><span class="name function">Res</span></a>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.TopLevel"><span class="name type">TopLevel</span></a>))&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.ParamInfo"><span class="name type">ParamInfo</span></a></code></dt></dl><br>  <b>Projections</b>:<br><dl class="decls">  <dt id="Language.Reflection.Derive.ParamInfo.(.goals)"><code><span class="type resolved" title="Language.Reflection.Derive.ParamInfo.(.goals)"><span class="name function">.goals</span></span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.ParamInfo"><span class="name type">ParamInfo</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="type resolved" title="Language.Reflection.TT.Name"><span class="name type">Name</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Language.Reflection.Types.html#Language.Reflection.Types.ParamTypeInfo"><span class="name type">ParamTypeInfo</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Language.Reflection.Types.html#Language.Reflection.Types.Res"><span class="name function">Res</span></a>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.TopLevel"><span class="name type">TopLevel</span></a>))</code></dt>  <dt id="Language.Reflection.Derive.ParamInfo.(.name)"><code><span class="type resolved" title="Language.Reflection.Derive.ParamInfo.(.name)"><span class="name function">.name</span></span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.ParamInfo"><span class="name type">ParamInfo</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TT.Name"><span class="name type">Name</span></span></code></dt>  <dt id="Language.Reflection.Derive.ParamInfo.(.strategy)"><code><span class="type resolved" title="Language.Reflection.Derive.ParamInfo.(.strategy)"><span class="name function">.strategy</span></span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.ParamInfo"><span class="name type">ParamInfo</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">n</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;(<span class="implicit"><span class="name type">Exists</span></span>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>&ensp;(<a class="type" href="Language.Reflection.Types.html#Language.Reflection.Types.ParamPattern"><span class="name type">ParamPattern</span></a>&ensp;<span class="boundvar">n</span>))</code></dt></dl></dd><dt id="Language.Reflection.Derive.ParamInfo.(.name)"><code><span class="type resolved" title="Language.Reflection.Derive.ParamInfo.(.name)"><span class="name function">.name</span></span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.ParamInfo"><span class="name type">ParamInfo</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TT.Name"><span class="name type">Name</span></span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Language.Reflection.Derive.ParamInfo.name"><code><span class="type resolved" title="Language.Reflection.Derive.ParamInfo.name"><span class="name function">name</span></span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.ParamInfo"><span class="name type">ParamInfo</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TT.Name"><span class="name type">Name</span></span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Language.Reflection.Derive.ParamInfo.(.strategy)"><code><span class="type resolved" title="Language.Reflection.Derive.ParamInfo.(.strategy)"><span class="name function">.strategy</span></span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.ParamInfo"><span class="name type">ParamInfo</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">n</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;(<span class="implicit"><span class="name type">Exists</span></span>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>&ensp;(<a class="type" href="Language.Reflection.Types.html#Language.Reflection.Types.ParamPattern"><span class="name type">ParamPattern</span></a>&ensp;<span class="boundvar">n</span>))</code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Language.Reflection.Derive.ParamInfo.strategy"><code><span class="type resolved" title="Language.Reflection.Derive.ParamInfo.strategy"><span class="name function">strategy</span></span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.ParamInfo"><span class="name type">ParamInfo</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">n</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;(<span class="implicit"><span class="name type">Exists</span></span>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>&ensp;(<a class="type" href="Language.Reflection.Types.html#Language.Reflection.Types.ParamPattern"><span class="name type">ParamPattern</span></a>&ensp;<span class="boundvar">n</span>))</code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Language.Reflection.Derive.ParamInfo.(.goals)"><code><span class="type resolved" title="Language.Reflection.Derive.ParamInfo.(.goals)"><span class="name function">.goals</span></span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.ParamInfo"><span class="name type">ParamInfo</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="type resolved" title="Language.Reflection.TT.Name"><span class="name type">Name</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Language.Reflection.Types.html#Language.Reflection.Types.ParamTypeInfo"><span class="name type">ParamTypeInfo</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Language.Reflection.Types.html#Language.Reflection.Types.Res"><span class="name function">Res</span></a>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.TopLevel"><span class="name type">TopLevel</span></a>))</code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Language.Reflection.Derive.ParamInfo.goals"><code><span class="type resolved" title="Language.Reflection.Derive.ParamInfo.goals"><span class="name function">goals</span></span>&ensp;:&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.ParamInfo"><span class="name type">ParamInfo</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="type resolved" title="Language.Reflection.TT.Name"><span class="name type">Name</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Language.Reflection.Types.html#Language.Reflection.Types.ParamTypeInfo"><span class="name type">ParamTypeInfo</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Language.Reflection.Types.html#Language.Reflection.Types.Res"><span class="name function">Res</span></a>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.TopLevel"><span class="name type">TopLevel</span></a>))</code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Language.Reflection.Derive.deriveParam"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.deriveParam"><span class="name function">deriveParam</span></a>&ensp;:&ensp;<span class="type resolved" title="Language.Reflection.Elaboration"><span class="name type">Elaboration</span></span>&ensp;<span class="boundvar">m</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.ParamInfo"><span class="name type">ParamInfo</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">m</span>&ensp;()</code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Derive.allParams"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.allParams"><span class="name function">allParams</span></a>&ensp;:&ensp;(<span class="boundvar">n</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;(<span class="implicit"><span class="name type">Exists</span></span>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>&ensp;(<a class="type" href="Language.Reflection.Types.html#Language.Reflection.Types.ParamPattern"><span class="name type">ParamPattern</span></a>&ensp;<span class="boundvar">n</span>))</code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Derive.allIndices"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.allIndices"><span class="name function">allIndices</span></a>&ensp;:&ensp;(<span class="boundvar">n</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;(<span class="implicit"><span class="name type">Exists</span></span>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>&ensp;(<a class="type" href="Language.Reflection.Types.html#Language.Reflection.Types.ParamPattern"><span class="name type">ParamPattern</span></a>&ensp;<span class="boundvar">n</span>))</code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Derive.match"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.match"><span class="name function">match</span></a>&ensp;:&ensp;<a class="type" href="Language.Reflection.Types.html#Language.Reflection.Types.ParamPattern"><span class="name type">ParamPattern</span></a>&ensp;<span class="boundvar">m</span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">n</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;(<span class="implicit"><span class="name type">Exists</span></span>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>&ensp;(<a class="type" href="Language.Reflection.Types.html#Language.Reflection.Types.ParamPattern"><span class="name type">ParamPattern</span></a>&ensp;<span class="boundvar">n</span>))</code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Derive.deriveMutual"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.deriveMutual"><span class="name function">deriveMutual</span></a>&ensp;:&ensp;<span class="type resolved" title="Language.Reflection.Elaboration"><span class="name type">Elaboration</span></span>&ensp;<span class="boundvar">m</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="type resolved" title="Language.Reflection.TT.Name"><span class="name type">Name</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="type resolved" title="Language.Reflection.TT.Name"><span class="name type">Name</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Language.Reflection.Types.html#Language.Reflection.Types.ParamTypeInfo"><span class="name type">ParamTypeInfo</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Language.Reflection.Types.html#Language.Reflection.Types.Res"><span class="name function">Res</span></a>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.TopLevel"><span class="name type">TopLevel</span></a>))&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">m</span>&ensp;()</code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Derive.derive"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.derive"><span class="name function">derive</span></a>&ensp;:&ensp;<span class="type resolved" title="Language.Reflection.Elaboration"><span class="name type">Elaboration</span></span>&ensp;<span class="boundvar">m</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TT.Name"><span class="name type">Name</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="type resolved" title="Language.Reflection.TT.Name"><span class="name type">Name</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Language.Reflection.Types.html#Language.Reflection.Types.ParamTypeInfo"><span class="name type">ParamTypeInfo</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Language.Reflection.Types.html#Language.Reflection.Types.Res"><span class="name function">Res</span></a>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.TopLevel"><span class="name type">TopLevel</span></a>))&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">m</span>&ensp;()</code></dt><dd><pre>  Given a name of a parameterized data type plus a list of<br>  interface generation functions, tries<br>  to implement these interfaces automatically using<br>  elaborator reflection.<br>  <br>  Again, see Doc.Generic4 for a tutorial and examples how<br>  to use this.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Derive.deriveIndexed"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.deriveIndexed"><span class="name function">deriveIndexed</span></a>&ensp;:&ensp;<span class="type resolved" title="Language.Reflection.Elaboration"><span class="name type">Elaboration</span></span>&ensp;<span class="boundvar">m</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TT.Name"><span class="name type">Name</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="type resolved" title="Language.Reflection.TT.Name"><span class="name type">Name</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Language.Reflection.Types.html#Language.Reflection.Types.ParamTypeInfo"><span class="name type">ParamTypeInfo</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Language.Reflection.Types.html#Language.Reflection.Types.Res"><span class="name function">Res</span></a>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.TopLevel"><span class="name type">TopLevel</span></a>))&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">m</span>&ensp;()</code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Derive.derivePattern"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.derivePattern"><span class="name function">derivePattern</span></a>&ensp;:&ensp;<span class="type resolved" title="Language.Reflection.Elaboration"><span class="name type">Elaboration</span></span>&ensp;<span class="boundvar">m</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TT.Name"><span class="name type">Name</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Language.Reflection.Types.html#Language.Reflection.Types.ParamPattern"><span class="name type">ParamPattern</span></a>&ensp;<span class="boundvar">n</span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="type resolved" title="Language.Reflection.TT.Name"><span class="name type">Name</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Language.Reflection.Types.html#Language.Reflection.Types.ParamTypeInfo"><span class="name type">ParamTypeInfo</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Language.Reflection.Types.html#Language.Reflection.Types.Res"><span class="name function">Res</span></a>&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.TopLevel"><span class="name type">TopLevel</span></a>))&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">m</span>&ensp;()</code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Derive.mkEq"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.mkEq"><span class="name function">mkEq</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.EqOrd.Eq"><span class="name type">Eq</span></span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Like `MkEq` but generates (/=) from the passed `eq` function.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Language.Reflection.Derive.mkOrd"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.mkOrd"><span class="name function">mkOrd</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Eq"><span class="name type">Eq</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.EqOrd.Ordering"><span class="name type">Ordering</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Creates an `Ord` value from the passed comparison function<br>  using default implementations based on `comp` for all<br>  other function.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Language.Reflection.Derive.mkShow"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.mkShow"><span class="name function">mkShow</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">String</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Show.Show"><span class="name type">Show</span></span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Creates a `Show` value from the passed `show` functions.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Language.Reflection.Derive.mkShowPrec"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.mkShowPrec"><span class="name function">mkShowPrec</span></a>&ensp;:&ensp;(<span class="type resolved" title="Prelude.Show.Prec"><span class="name type">Prec</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">String</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Show.Show"><span class="name type">Show</span></span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Creates a `Show` value from the passed `showPrec` functions.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Language.Reflection.Derive.mkDecEq"><code><a class="type" href="Language.Reflection.Derive.html#Language.Reflection.Derive.mkDecEq"><span class="name function">mkDecEq</span></a>&ensp;:&ensp;((<span class="boundvar">x1</span>&ensp;:&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">x2</span>&ensp;:&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Dec"><span class="name type">Dec</span></span>&ensp;(<span class="boundvar">x1</span>&ensp;<span class="keyword">=</span>&ensp;<span class="boundvar">x2</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="implicit"><span class="name type">DecEq</span></span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Creates a `DecEq` value from the passed implementation function<br>  for `decEq`</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd></dl></div><footer>Produced by Idris 2 version 0.7.0-da352d8ed</footer></body></html>
