<!DOCTYPE html><html lang="en">

<head>
  <meta charset="utf-8">
  <title>Language.Reflection.Refined</title>
  <link rel="stylesheet" type="text/css" id="preferredStyle" href="../default.css">
  <script>
    /* Updates the stylesheet to use the preferred one.
       Note that we set the link to root ++ sourceLoc because the config
       is shared across the whole website, so the root may differ from
       page to page.
    */
    function setStyleSource (sourceLoc) {
      document.getElementById("preferredStyle").href = "../" + sourceLoc + ".css";
      document.getElementById("selectPreferredStyle").value = sourceLoc;
    }
    /* Initialises the preferred style sheet:
       1. if there is a stored value then use that
          otherwise select the default
       2. set both the css link href & the drop down menu selected option
    */
    function initStyleSource () {
      var preferredStyle = localStorage.getItem("stylefile");
      if (preferredStyle !== null) {
        setStyleSource(preferredStyle);
      } else {
        setStyleSource("default");
      };
    }
    function saveStyleSource (preferredStyle) {
      localStorage.stylefile = preferredStyle;
    }
    </script>
</head>

<body class="namespace">
<header>
  <strong>Idris2Doc</strong> : Language.Reflection.Refined
  <nav><a href="../index.html">Index</a>

  <select id="selectPreferredStyle">
    <option value="default">Default</option>
<option value="alternative">Alternative</option>
<option value="blackandwhite">Black & White</option>

  </select>
  </nav>

  <script>
  /* We start by initialising the style source */
  initStyleSource();

  /* This listens for changes on the drop down menu and updates the
     css used for the current page when a selection is made.
  */
  document.getElementById("selectPreferredStyle").addEventListener("change", function(){
    var selected = this.options[this.selectedIndex].value; /* the option chosen */
    setStyleSource (selected);
    saveStyleSource (selected);
  });
</script>

</header>
<div class="container"><div id="module-header"><h1>Language.Reflection.Refined</h1><span style="float:right">(<a href="Language.Reflection.Refined.src.html">source</a>)</span><pre>The content of this module is based on the
tutorial post about [refined primitives](../../Doc/Primitives.md).
</pre></div><h2>Reexports</h2><code><span class="keyword">import</span>&ensp;<span class="keyword">public</span>&ensp;Language.Reflection.Refined.Util</code><h2>Definitions</h2><dl class="decls"><dt id="Language.Reflection.Refined.refinedEq"><code><a class="type" href="Language.Reflection.Refined.html#Language.Reflection.Refined.refinedEq"><span class="name function">refinedEq</span></a>&ensp;:&ensp;<span class="name type">String</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TT.Name"><span class="name type">Name</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.Elab"><span class="name type">Elab</span></span>&ensp;()</code></dt><dd><pre>  Creates an `Eq` implementation for the given datatype<br>  by using the given accessor function.<br>  <br>  This is hardly useful on its own but convenient when<br>  combined with other interface implementors.<br>  <br>  In some occasions it is useful to have one or several<br>  phantom types for the refined type. Therefore, the exact<br>  type should be given as a `TTImp`.<br>  <br>  ```idris example<br>  record AtomicNr a where<br>    constructor MkAtomicNr<br>    value : Int<br>    0 inBounds : So (1 &lt;= value &amp;&amp; value &lt;= 118)<br>  <br>  %runElab refinedEq &quot;AtomicNr&quot; `(AtomicNr a) `{{value}}<br>  ```</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Refined.refinedOrd"><code><a class="type" href="Language.Reflection.Refined.html#Language.Reflection.Refined.refinedOrd"><span class="name function">refinedOrd</span></a>&ensp;:&ensp;<span class="name type">String</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TT.Name"><span class="name type">Name</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.Elab"><span class="name type">Elab</span></span>&ensp;()</code></dt><dd><pre>  Creates an `Ord` implementation for the given datatype<br>  by using the given accessor function.<br>  <br>  This is hardly useful on its own but convenient when<br>  combined with other interface implementors.<br>  <br>  ```idris example<br>  record AtomicNr a where<br>    constructor MkAtomicNr<br>    value : Int<br>    0 inBounds : So (1 &lt;= value &amp;&amp; value &lt;= 118)<br>  <br>  %runElab refinedOrd &quot;AtomicNr&quot; `(AtomicNr a) `{{value}}<br>  ```</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Refined.refinedShow"><code><a class="type" href="Language.Reflection.Refined.html#Language.Reflection.Refined.refinedShow"><span class="name function">refinedShow</span></a>&ensp;:&ensp;<span class="name type">String</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TT.Name"><span class="name type">Name</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.Elab"><span class="name type">Elab</span></span>&ensp;()</code></dt><dd><pre>  Creates a `Show` implementation for the given datatype<br>  by using the given accessor function.<br>  <br>  This is hardly useful on its own but convenient when<br>  combined with other interface implementors.<br>  <br>  ```idris example<br>  record AtomicNr a where<br>    constructor MkAtomicNr<br>    value : Int<br>    0 inBounds : So (1 &lt;= value &amp;&amp; value &lt;= 118)<br>  <br>  %runElab refinedShow &quot;AtomicNr&quot; `(AtomicNr a) `{{value}}<br>  ```</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Refined.refinedEqOrdShow"><code><a class="type" href="Language.Reflection.Refined.html#Language.Reflection.Refined.refinedEqOrdShow"><span class="name function">refinedEqOrdShow</span></a>&ensp;:&ensp;<span class="name type">String</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TT.Name"><span class="name type">Name</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.Elab"><span class="name type">Elab</span></span>&ensp;()</code></dt><dd><pre>  Convenience function combining `refinedEq`, `refinedOrd`,<br>  and `refinedShow`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Refined.refinedIntegral"><code><a class="type" href="Language.Reflection.Refined.html#Language.Reflection.Refined.refinedIntegral"><span class="name function">refinedIntegral</span></a>&ensp;:&ensp;<span class="name type">String</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TT.Name"><span class="name type">Name</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TT.Name"><span class="name type">Name</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.Elab"><span class="name type">Elab</span></span>&ensp;()</code></dt><dd><pre>  This creates `Eq`, `Ord`, and `Show` implementations as<br>  well as conversion functions for a refined integral number.<br>  <br>  Conversion functions are called `refine` and `fromInteger`<br>  and are put in their own namespace, named after the<br>  data type&apos;s name.<br>  <br>  ```idris example<br>  record AtomicNr a where<br>    constructor MkAtomicNr<br>    value : Int<br>    0 inBounds : So (1 &lt;= value &amp;&amp; value &lt;= 118)<br>  <br>  %runElab refinedIntegral &quot;AtomicNr&quot;<br>                           `(AtomicNr a)<br>                           `{{MkAtomicNr}}<br>                           `{{value}}<br>                           `(Int)<br>  ```<br>  <br>  The above will result in the following declarations being generated:<br>  <br>  ```idris example<br>  Eq AtomicNr where<br>    (==) = (==) `on` value<br>  <br>  Ord AtomicNr where<br>    compare = compare `on` value<br>  <br>  Show AtomicNr where<br>    showPrec p = showPrec p . value<br>  <br>  namespace AtomicNr<br>    refine : Int -&gt; Maybe AtomicNr<br>    refine = refineSo MkAtomicNr<br>  <br>    fromInteger :<br>         (v : Integer)<br>      -&gt; {auto 0 _: IsJust (refine $ fromInteger v)}<br>      -&gt; AtomicNr<br>    fromInteger v = fromJust (refine $ fromInteger v)<br>  ```</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Refined.refinedIntegralDflt"><code><a class="type" href="Language.Reflection.Refined.html#Language.Reflection.Refined.refinedIntegralDflt"><span class="name function">refinedIntegralDflt</span></a>&ensp;:&ensp;<span class="name type">String</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.Elab"><span class="name type">Elab</span></span>&ensp;()</code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Refined.refinedInt"><code><a class="type" href="Language.Reflection.Refined.html#Language.Reflection.Refined.refinedInt"><span class="name function">refinedInt</span></a>&ensp;:&ensp;<span class="name type">String</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.Elab"><span class="name type">Elab</span></span>&ensp;()</code></dt><dd><pre>  Specialized version of `refinedIntegral` for data types,<br>  which adhere to the following conventions:<br>  <br>   * If a data type&apos;s name is `Foo` its constructor is named `MkFoo`.<br>   * The field accessor of the wrapped Int is named `value`.<br>   * The proof of validity consists of a single zero quantity `So`.<br>  <br>  ```idris example<br>  record AtomicNr where<br>    constructor MkAtomicNr<br>    value : Int<br>    0 inBounds : So (1 &lt;= value &amp;&amp; value &lt;= 118)<br>  <br>  %runElab refinedInt &quot;AtomicNr&quot;<br>  ```</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Refined.refinedBits8"><code><a class="type" href="Language.Reflection.Refined.html#Language.Reflection.Refined.refinedBits8"><span class="name function">refinedBits8</span></a>&ensp;:&ensp;<span class="name type">String</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.Elab"><span class="name type">Elab</span></span>&ensp;()</code></dt><dd><pre>  Specialized version of `refinedIntegral` for data types,<br>  which adhere to the following conventions:<br>  <br>   * If a data type&apos;s name is `Foo` its constructor is named `MkFoo`.<br>   * The field accessor of the wrapped Int is named `value`.<br>   * The proof of validity consists of a single zero quantity `So`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Refined.refinedBits16"><code><a class="type" href="Language.Reflection.Refined.html#Language.Reflection.Refined.refinedBits16"><span class="name function">refinedBits16</span></a>&ensp;:&ensp;<span class="name type">String</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.Elab"><span class="name type">Elab</span></span>&ensp;()</code></dt><dd><pre>  Specialized version of `refinedIntegral` for data types,<br>  which adhere to the following conventions:<br>  <br>   * If a data type&apos;s name is `Foo` its constructor is named `MkFoo`.<br>   * The field accessor of the wrapped Int is named `value`.<br>   * The proof of validity consists of a single zero quantity `So`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Refined.refinedBits32"><code><a class="type" href="Language.Reflection.Refined.html#Language.Reflection.Refined.refinedBits32"><span class="name function">refinedBits32</span></a>&ensp;:&ensp;<span class="name type">String</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.Elab"><span class="name type">Elab</span></span>&ensp;()</code></dt><dd><pre>  Specialized version of `refinedIntegral` for data types,<br>  which adhere to the following conventions:<br>  <br>   * If a data type&apos;s name is `Foo` its constructor is named `MkFoo`.<br>   * The field accessor of the wrapped Int is named `value`.<br>   * The proof of validity consists of a single zero quantity `So`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Refined.refinedBits64"><code><a class="type" href="Language.Reflection.Refined.html#Language.Reflection.Refined.refinedBits64"><span class="name function">refinedBits64</span></a>&ensp;:&ensp;<span class="name type">String</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.Elab"><span class="name type">Elab</span></span>&ensp;()</code></dt><dd><pre>  Specialized version of `refinedIntegral` for data types,<br>  which adhere to the following conventions:<br>  <br>   * If a data type&apos;s name is `Foo` its constructor is named `MkFoo`.<br>   * The field accessor of the wrapped Int is named `value`.<br>   * The proof of validity consists of a single zero quantity `So`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Refined.refinedInt8"><code><a class="type" href="Language.Reflection.Refined.html#Language.Reflection.Refined.refinedInt8"><span class="name function">refinedInt8</span></a>&ensp;:&ensp;<span class="name type">String</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.Elab"><span class="name type">Elab</span></span>&ensp;()</code></dt><dd><pre>  Specialized version of `refinedIntegral` for data types,<br>  which adhere to the following conventions:<br>  <br>   * If a data type&apos;s name is `Foo` its constructor is named `MkFoo`.<br>   * The field accessor of the wrapped Int is named `value`.<br>   * The proof of validity consists of a single zero quantity `So`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Refined.refinedInt16"><code><a class="type" href="Language.Reflection.Refined.html#Language.Reflection.Refined.refinedInt16"><span class="name function">refinedInt16</span></a>&ensp;:&ensp;<span class="name type">String</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.Elab"><span class="name type">Elab</span></span>&ensp;()</code></dt><dd><pre>  Specialized version of `refinedIntegral` for data types,<br>  which adhere to the following conventions:<br>  <br>   * If a data type&apos;s name is `Foo` its constructor is named `MkFoo`.<br>   * The field accessor of the wrapped Int is named `value`.<br>   * The proof of validity consists of a single zero quantity `So`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Refined.refinedInt32"><code><a class="type" href="Language.Reflection.Refined.html#Language.Reflection.Refined.refinedInt32"><span class="name function">refinedInt32</span></a>&ensp;:&ensp;<span class="name type">String</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.Elab"><span class="name type">Elab</span></span>&ensp;()</code></dt><dd><pre>  Specialized version of `refinedIntegral` for data types,<br>  which adhere to the following conventions:<br>  <br>   * If a data type&apos;s name is `Foo` its constructor is named `MkFoo`.<br>   * The field accessor of the wrapped Int is named `value`.<br>   * The proof of validity consists of a single zero quantity `So`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Refined.refinedInt64"><code><a class="type" href="Language.Reflection.Refined.html#Language.Reflection.Refined.refinedInt64"><span class="name function">refinedInt64</span></a>&ensp;:&ensp;<span class="name type">String</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.Elab"><span class="name type">Elab</span></span>&ensp;()</code></dt><dd><pre>  Specialized version of `refinedIntegral` for data types,<br>  which adhere to the following conventions:<br>  <br>   * If a data type&apos;s name is `Foo` its constructor is named `MkFoo`.<br>   * The field accessor of the wrapped Int is named `value`.<br>   * The proof of validity consists of a single zero quantity `So`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Refined.refinedFloating"><code><a class="type" href="Language.Reflection.Refined.html#Language.Reflection.Refined.refinedFloating"><span class="name function">refinedFloating</span></a>&ensp;:&ensp;<span class="name type">String</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TT.Name"><span class="name type">Name</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TT.Name"><span class="name type">Name</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.Elab"><span class="name type">Elab</span></span>&ensp;()</code></dt><dd><pre>  This creates `Eq`, `Ord`, and `Show` implementations as<br>  well as conversion functions for a refined floating point<br>  number.<br>  <br>  Conversion functions are called `refine` and `fromDouble`<br>  and are put in their own namespace, named after the<br>  data type&apos;s name.<br>  <br>  ```idris example<br>  record Abundance a where<br>    constructor MkAbundance<br>    value : Double<br>    0 inBounds : So (0 &lt; value &amp;&amp; value &lt;= 1)<br>  <br>  %runElab refinedFloating &quot;Abundance&quot; `(Abundance a) `{{MkAbundance}} `{{value}}<br>  ```<br>  <br>  The above will result in the following declarations being generated:<br>  <br>  ```idris example<br>  Eq Abundance where<br>    (==) = (==) `on` value<br>  <br>  Ord Abundance where<br>    compare = compare `on` value<br>  <br>  Show Abundance where<br>    showPrec p = showPrec p . value<br>  <br>  namespace Abundance<br>    refine : Double -&gt; Maybe Abundance<br>    refine = refineSo MkAbundance<br>  <br>    fromDouble :  (v : Double)<br>               -&gt; {auto 0 _: IsJust (refine v)}<br>               -&gt; Abundance<br>    fromDouble v = fromJust (refine v)<br>  ```</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Refined.refinedDouble"><code><a class="type" href="Language.Reflection.Refined.html#Language.Reflection.Refined.refinedDouble"><span class="name function">refinedDouble</span></a>&ensp;:&ensp;<span class="name type">String</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.Elab"><span class="name type">Elab</span></span>&ensp;()</code></dt><dd><pre>  Convenience version of `refinedFloating` for data types,<br>  which adhere to the following conventions:<br>  <br>   * If a data type&apos;s name is `Foo` its constructor is named `MkFoo`.<br>   * The field accessor of the wrapped Int is named `value`.<br>   * The proof of validity consists of a single zero quantity `So`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Refined.refinedText"><code><a class="type" href="Language.Reflection.Refined.html#Language.Reflection.Refined.refinedText"><span class="name function">refinedText</span></a>&ensp;:&ensp;<span class="name type">String</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TT.Name"><span class="name type">Name</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TT.Name"><span class="name type">Name</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.Elab"><span class="name type">Elab</span></span>&ensp;()</code></dt><dd><pre>  This creates `Eq`, `Ord`, and `Show` implementations as<br>  well as conversion functions for a refined string value.<br>  <br>  Conversion functions are called `refine` and `fromString`<br>  and are put in their own namespace, named after the<br>  data type&apos;s name.<br>  <br>  ```idris example<br>  record Html a where<br>    constructor MkHtml<br>    value : String<br>    0 inBounds : So (isValidHtml value)<br>  <br>  %runElab refinedText &quot;Html&quot; `(Html a) `{{MkHtml}} `{{value}}<br>  ```<br>  <br>  The above will result in the following declarations being generated:<br>  <br>  ```idris example<br>  Eq Html where<br>    (==) = (==) `on` value<br>  <br>  Ord Html where<br>    compare = compare `on` value<br>  <br>  Show Html where<br>    showPrec p = showPrec p . value<br>  <br>  namespace Html<br>    refine : String -&gt; Maybe Html<br>    refine = refineSo MkHtml<br>  <br>    fromString :  (v : String)<br>               -&gt; {auto 0 _: IsJust (refine v)}<br>               -&gt; Html<br>    fromString v = fromJust (refine v)<br>  ```</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Refined.refinedString"><code><a class="type" href="Language.Reflection.Refined.html#Language.Reflection.Refined.refinedString"><span class="name function">refinedString</span></a>&ensp;:&ensp;<span class="name type">String</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.Elab"><span class="name type">Elab</span></span>&ensp;()</code></dt><dd><pre>  Convenience version of `refinedText` for data types,<br>  which adhere to the following conventions:<br>  <br>   * If a data type&apos;s name is `Foo` its constructor is named `MkFoo`.<br>   * The field accessor of the wrapped Int is named `value`.<br>   * The proof of validity consists of a single zero quantity `So`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Refined.refinedCharacter"><code><a class="type" href="Language.Reflection.Refined.html#Language.Reflection.Refined.refinedCharacter"><span class="name function">refinedCharacter</span></a>&ensp;:&ensp;<span class="name type">String</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TTImp.TTImp"><span class="name type">TTImp</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TT.Name"><span class="name type">Name</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.TT.Name"><span class="name type">Name</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.Elab"><span class="name type">Elab</span></span>&ensp;()</code></dt><dd><pre>  This creates `Eq`, `Ord`, and `Show` implementations as<br>  well as conversion functions for a refined charater.<br>  <br>  Conversion functions are called `refine` and `fromChar`<br>  and are put in their own namespace, named after the<br>  data type&apos;s name.<br>  <br>  ```idris example<br>  record Digit a where<br>    constructor MkDigit<br>    value : Char<br>    0 inBounds : So (isDigit value)<br>  <br>  %runElab refinedText &quot;Digit&quot; `(Digit a) `{{MkDigit}} `{{value}}<br>  ```<br>  <br>  The above will result in the following declarations being generated:<br>  <br>  ```idris example<br>  Eq Digit where<br>    (==) = (==) `on` value<br>  <br>  Ord Digit where<br>    compare = compare `on` value<br>  <br>  Show Digit where<br>    showPrec p = showPrec p . value<br>  <br>  namespace Digit<br>    refine : Char -&gt; Maybe Digit<br>    refine = refineSo MkDigit<br>  <br>    fromChar :  (v : Char)<br>             -&gt; {auto 0 _: IsJust (refine v)}<br>             -&gt; Digit<br>    fromChar v = fromJust (refine v)<br>  ```</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Language.Reflection.Refined.refinedChar"><code><a class="type" href="Language.Reflection.Refined.html#Language.Reflection.Refined.refinedChar"><span class="name function">refinedChar</span></a>&ensp;:&ensp;<span class="name type">String</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Language.Reflection.Elab"><span class="name type">Elab</span></span>&ensp;()</code></dt><dd><pre>  Convenience version of `refinedCharacter` for data types,<br>  which adhere to the following conventions:<br>  <br>   * If a data type&apos;s name is `Foo` its constructor is named `MkFoo`.<br>   * The field accessor of the wrapped Char is named `value`.<br>   * The proof of validity consists of a single zero quantity `So`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd></dl></div><footer>Produced by Idris 2 version 0.7.0-da352d8ed</footer></body></html>
