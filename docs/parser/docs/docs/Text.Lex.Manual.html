<!DOCTYPE html><html lang="en">

<head>
  <meta charset="utf-8">
  <title>Text.Lex.Manual</title>
  <link rel="stylesheet" type="text/css" id="preferredStyle" href="../default.css">
  <script>
    /* Updates the stylesheet to use the preferred one.
       Note that we set the link to root ++ sourceLoc because the config
       is shared across the whole website, so the root may differ from
       page to page.
    */
    function setStyleSource (sourceLoc) {
      document.getElementById("preferredStyle").href = "../" + sourceLoc + ".css";
      document.getElementById("selectPreferredStyle").value = sourceLoc;
    }
    /* Initialises the preferred style sheet:
       1. if there is a stored value then use that
          otherwise select the default
       2. set both the css link href & the drop down menu selected option
    */
    function initStyleSource () {
      var preferredStyle = localStorage.getItem("stylefile");
      if (preferredStyle !== null) {
        setStyleSource(preferredStyle);
      } else {
        setStyleSource("default");
      };
    }
    function saveStyleSource (preferredStyle) {
      localStorage.stylefile = preferredStyle;
    }
    </script>
</head>

<body class="namespace">
<header>
  <strong>Idris2Doc</strong> : Text.Lex.Manual
  <nav><a href="../index.html">Index</a>

  <select id="selectPreferredStyle">
    <option value="default">Default</option>
<option value="alternative">Alternative</option>
<option value="blackandwhite">Black & White</option>

  </select>
  </nav>

  <script>
  /* We start by initialising the style source */
  initStyleSource();

  /* This listens for changes on the drop down menu and updates the
     css used for the current page when a selection is made.
  */
  document.getElementById("selectPreferredStyle").addEventListener("change", function(){
    var selected = this.options[this.selectedIndex].value; /* the option chosen */
    setStyleSource (selected);
    saveStyleSource (selected);
  });
</script>

</header>
<div class="container"><div id="module-header"><h1>Text.Lex.Manual</h1><span style="float:right">(<a href="Text.Lex.Manual.src.html">source</a>)</span><pre></pre></div><h2>Reexports</h2><code><span class="keyword">import</span>&ensp;<span class="keyword">public</span>&ensp;Text.ParseError<br><span class="keyword">import</span>&ensp;<span class="keyword">public</span>&ensp;Data.List.Suffix<br><span class="keyword">import</span>&ensp;<span class="keyword">public</span>&ensp;Data.List.Suffix.Result</code><h2>Definitions</h2><dl class="decls"><dt id="Text.Lex.Manual.LexRes"><code><span class="keyword">0</span>&ensp;<a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.LexRes"><span class="name function">LexRes</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="name type">Char</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd><pre>  Result of running a (strict) tokenizer.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Lex.Manual.(&lt;|&gt;)"><code><a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.(&lt;|&gt;)"><span class="name function">(&lt;|&gt;)</span></a>&ensp;:&ensp;<a class="type" href="Data.List.Suffix.Result.html#Data.List.Suffix.Result.Result"><span class="name type">Result</span></a>&ensp;<span class="boundvar">b</span>&ensp;<span class="boundvar">t</span>&ensp;<span class="boundvar">ts</span>&ensp;<span class="boundvar">r</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;Lazy&ensp;(<a class="type" href="Data.List.Suffix.Result.html#Data.List.Suffix.Result.Result"><span class="name type">Result</span></a>&ensp;<span class="boundvar">b</span>&ensp;<span class="boundvar">t</span>&ensp;<span class="boundvar">ts</span>&ensp;<span class="boundvar">r</span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.List.Suffix.Result.html#Data.List.Suffix.Result.Result"><span class="name type">Result</span></a>&ensp;<span class="boundvar">b</span>&ensp;<span class="boundvar">t</span>&ensp;<span class="boundvar">ts</span>&ensp;<span class="boundvar">r</span>&ensp;<span class="boundvar">a</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span><br>  <b>Fixity Declaration</b>:&ensp;infixr&ensp;operator,&ensp;level&ensp;2</dd><dt id="Text.Lex.Manual.isSpaceChar"><code><a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.isSpaceChar"><span class="name function">isSpaceChar</span></a>&ensp;:&ensp;<span class="name type">Char</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span></code></dt><dd><pre>  Returns true if the character is a space (`&apos; &apos;`) character.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Lex.Manual.isLineFeed"><code><a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.isLineFeed"><span class="name function">isLineFeed</span></a>&ensp;:&ensp;<span class="name type">Char</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span></code></dt><dd><pre>  Returns true if the character is a line feed (`&apos;\n&apos;`) character.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Lex.Manual.octDigit"><code><a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.octDigit"><span class="name function">octDigit</span></a>&ensp;:&ensp;<span class="name type">Char</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span></code></dt><dd><pre>  Converts a character to an octal digit. This works under the<br>  assumption that the character has already been verified to be<br>  an octal digit.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Lex.Manual.digit"><code><a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.digit"><span class="name function">digit</span></a>&ensp;:&ensp;<span class="name type">Char</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span></code></dt><dd><pre>  Converts a character to a decimal digit. This works under the<br>  assumption that the character has already been verified to be<br>  a decimal digit.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Lex.Manual.hexDigit"><code><a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.hexDigit"><span class="name function">hexDigit</span></a>&ensp;:&ensp;<span class="name type">Char</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span></code></dt><dd><pre>  Converts a character to a hexadecimal digit. This works under the<br>  assumption that the character has already been verified to be<br>  a hexadecimal digit.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Lex.Manual.isBinDigit"><code><a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.isBinDigit"><span class="name function">isBinDigit</span></a>&ensp;:&ensp;<span class="name type">Char</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span></code></dt><dd><pre>  True if the given character is a binary digit.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Lex.Manual.binDigit"><code><a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.binDigit"><span class="name function">binDigit</span></a>&ensp;:&ensp;<span class="name type">Char</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span></code></dt><dd><pre>  Converts a character to a binary digit. This works under the<br>  assumption that the character has already been verified to be<br>  a binary digit.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Lex.Manual.Tok"><code><span class="keyword">0</span>&ensp;<a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.Tok"><span class="name function">Tok</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd><pre>  A tokenizing function, which will consume a strict<br>  prefix of the input list or fail with a stop reason.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Lex.Manual.AutoTok"><code><span class="keyword">0</span>&ensp;<a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.AutoTok"><span class="name function">AutoTok</span></a>&ensp;:&ensp;<span class="name type">Type</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd><pre>  A tokenizing function, which will consume additional characters<br>  from the input string. This can only be used if already some<br>  have been consumed.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Lex.Manual.SafeTok"><code><span class="keyword">0</span>&ensp;<a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.SafeTok"><span class="name function">SafeTok</span></a>&ensp;:&ensp;<span class="name type">Type</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd><pre>  A tokenizing function that cannot fail.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Lex.Manual.StrictTok"><code><span class="keyword">0</span>&ensp;<a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.StrictTok"><span class="name function">StrictTok</span></a>&ensp;:&ensp;<span class="name type">Type</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd><pre>  A tokenizing function, which will consume additional characters<br>  from the input string.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Lex.Manual.tok"><code><a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.tok"><span class="name function">tok</span></a>&ensp;:&ensp;<a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.StrictTok"><span class="name function">StrictTok</span></a>&ensp;<span class="boundvar">e</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.Tok"><span class="name function">Tok</span></a>&ensp;<span class="type resolved" title="Prelude.Basics.True"><span class="name constructor">True</span></span>&ensp;<span class="boundvar">e</span>&ensp;<span class="boundvar">a</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Lex.Manual.autoTok"><code><a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.autoTok"><span class="name function">autoTok</span></a>&ensp;:&ensp;<a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.StrictTok"><span class="name function">StrictTok</span></a>&ensp;<span class="boundvar">e</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.AutoTok"><span class="name function">AutoTok</span></a>&ensp;<span class="boundvar">e</span>&ensp;<span class="boundvar">a</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Lex.Manual.safeTok"><code><a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.safeTok"><span class="name function">safeTok</span></a>&ensp;:&ensp;<a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.SafeTok"><span class="name function">SafeTok</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.AutoTok"><span class="name function">AutoTok</span></a>&ensp;<span class="boundvar">e</span>&ensp;<span class="boundvar">a</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Lex.Manual.range"><code><a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.range"><span class="name function">range</span></a>&ensp;:&ensp;<a class="type" href="Text.ParseError.html#Text.ParseError.ParseError"><span class="name type">ParseError</span></a>&ensp;<span class="type resolved" title="Builtin.Void"><span class="name type">Void</span></span>&ensp;<span class="boundvar">e</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.List.Suffix.html#Data.List.Suffix.Suffix"><span class="name type">Suffix</span></a>&ensp;<span class="boundvar">b</span>&ensp;<span class="boundvar">errBegin</span>&ensp;<span class="boundvar">orig</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="keyword">0</span>&ensp;<span class="boundvar">errEnd</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="name type">Char</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.List.Suffix.html#Data.List.Suffix.Suffix"><span class="name type">Suffix</span></a>&ensp;<span class="type resolved" title="Prelude.Basics.False"><span class="name constructor">False</span></span>&ensp;<span class="boundvar">errEnd</span>&ensp;<span class="boundvar">errBegin</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.LexRes"><span class="name function">LexRes</span></a>&ensp;<span class="boundvar">bres</span>&ensp;<span class="boundvar">orig</span>&ensp;<span class="boundvar">e</span>&ensp;<span class="boundvar">a</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Lex.Manual.invalidEscape"><code><a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.invalidEscape"><span class="name function">invalidEscape</span></a>&ensp;:&ensp;<a class="type" href="Data.List.Suffix.html#Data.List.Suffix.Suffix"><span class="name type">Suffix</span></a>&ensp;<span class="boundvar">b</span>&ensp;<span class="boundvar">errBegin</span>&ensp;<span class="boundvar">orig</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="keyword">0</span>&ensp;<span class="boundvar">errEnd</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="name type">Char</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.List.Suffix.html#Data.List.Suffix.Suffix"><span class="name type">Suffix</span></a>&ensp;<span class="type resolved" title="Prelude.Basics.False"><span class="name constructor">False</span></span>&ensp;<span class="boundvar">errEnd</span>&ensp;<span class="boundvar">errBegin</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.LexRes"><span class="name function">LexRes</span></a>&ensp;<span class="boundvar">bres</span>&ensp;<span class="boundvar">orig</span>&ensp;<span class="boundvar">e</span>&ensp;<span class="boundvar">a</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Lex.Manual.unknownRange"><code><a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.unknownRange"><span class="name function">unknownRange</span></a>&ensp;:&ensp;<a class="type" href="Data.List.Suffix.html#Data.List.Suffix.Suffix"><span class="name type">Suffix</span></a>&ensp;<span class="boundvar">b</span>&ensp;<span class="boundvar">errBegin</span>&ensp;<span class="boundvar">orig</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="keyword">0</span>&ensp;<span class="boundvar">errEnd</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="name type">Char</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.List.Suffix.html#Data.List.Suffix.Suffix"><span class="name type">Suffix</span></a>&ensp;<span class="type resolved" title="Prelude.Basics.False"><span class="name constructor">False</span></span>&ensp;<span class="boundvar">errEnd</span>&ensp;<span class="boundvar">errBegin</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.LexRes"><span class="name function">LexRes</span></a>&ensp;<span class="boundvar">bres</span>&ensp;<span class="boundvar">orig</span>&ensp;<span class="boundvar">e</span>&ensp;<span class="boundvar">a</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Lex.Manual.single"><code><a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.single"><span class="name function">single</span></a>&ensp;:&ensp;<a class="type" href="Text.ParseError.html#Text.ParseError.ParseError"><span class="name type">ParseError</span></a>&ensp;<span class="type resolved" title="Builtin.Void"><span class="name type">Void</span></span>&ensp;<span class="boundvar">e</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.List.Suffix.html#Data.List.Suffix.Suffix"><span class="name type">Suffix</span></a>&ensp;<span class="boundvar">b</span>&ensp;(<span class="boundvar">c</span>&ensp;<span class="type resolved" title="Prelude.Basics.(::)"><span class="name constructor">::</span></span>&ensp;<span class="boundvar">errEnd</span>)&ensp;<span class="boundvar">orig</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.LexRes"><span class="name function">LexRes</span></a>&ensp;<span class="boundvar">bres</span>&ensp;<span class="boundvar">orig</span>&ensp;<span class="boundvar">e</span>&ensp;<span class="boundvar">a</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Lex.Manual.unknown"><code><a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.unknown"><span class="name function">unknown</span></a>&ensp;:&ensp;<a class="type" href="Data.List.Suffix.html#Data.List.Suffix.Suffix"><span class="name type">Suffix</span></a>&ensp;<span class="boundvar">b</span>&ensp;(<span class="boundvar">c</span>&ensp;<span class="type resolved" title="Prelude.Basics.(::)"><span class="name constructor">::</span></span>&ensp;<span class="boundvar">errEnd</span>)&ensp;<span class="boundvar">orig</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.LexRes"><span class="name function">LexRes</span></a>&ensp;<span class="boundvar">bres</span>&ensp;<span class="boundvar">orig</span>&ensp;<span class="boundvar">e</span>&ensp;<span class="boundvar">a</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Lex.Manual.eoiAt"><code><a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.eoiAt"><span class="name function">eoiAt</span></a>&ensp;:&ensp;<a class="type" href="Data.List.Suffix.html#Data.List.Suffix.Suffix"><span class="name type">Suffix</span></a>&ensp;<span class="boundvar">b</span>&ensp;[]&ensp;<span class="boundvar">orig</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.LexRes"><span class="name function">LexRes</span></a>&ensp;<span class="boundvar">bres</span>&ensp;<span class="boundvar">orig</span>&ensp;<span class="boundvar">e</span>&ensp;<span class="boundvar">a</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Lex.Manual.failCharClass"><code><a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.failCharClass"><span class="name function">failCharClass</span></a>&ensp;:&ensp;<a class="type" href="Text.ParseError.html#Text.ParseError.CharClass"><span class="name type">CharClass</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.List.Suffix.html#Data.List.Suffix.Suffix"><span class="name type">Suffix</span></a>&ensp;<span class="boundvar">b</span>&ensp;(<span class="boundvar">c</span>&ensp;<span class="type resolved" title="Prelude.Basics.(::)"><span class="name constructor">::</span></span>&ensp;<span class="boundvar">errEnd</span>)&ensp;<span class="boundvar">orig</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.LexRes"><span class="name function">LexRes</span></a>&ensp;<span class="boundvar">bres</span>&ensp;<span class="boundvar">orig</span>&ensp;<span class="boundvar">e</span>&ensp;<span class="boundvar">a</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Lex.Manual.failDigit"><code><a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.failDigit"><span class="name function">failDigit</span></a>&ensp;:&ensp;<a class="type" href="Text.ParseError.html#Text.ParseError.DigitType"><span class="name type">DigitType</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.List.Suffix.html#Data.List.Suffix.Suffix"><span class="name type">Suffix</span></a>&ensp;<span class="boundvar">b</span>&ensp;(<span class="boundvar">c</span>&ensp;<span class="type resolved" title="Prelude.Basics.(::)"><span class="name constructor">::</span></span>&ensp;<span class="boundvar">errEnd</span>)&ensp;<span class="boundvar">orig</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.LexRes"><span class="name function">LexRes</span></a>&ensp;<span class="boundvar">bres</span>&ensp;<span class="boundvar">orig</span>&ensp;<span class="boundvar">e</span>&ensp;<span class="boundvar">a</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Lex.Manual.fail"><code><a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.fail"><span class="name function">fail</span></a>&ensp;:&ensp;<a class="type" href="Data.List.Suffix.html#Data.List.Suffix.Suffix"><span class="name type">Suffix</span></a>&ensp;<span class="boundvar">b</span>&ensp;<span class="boundvar">errBegin</span>&ensp;<span class="boundvar">orig</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.LexRes"><span class="name function">LexRes</span></a>&ensp;<span class="boundvar">bres</span>&ensp;<span class="boundvar">orig</span>&ensp;<span class="boundvar">e</span>&ensp;<span class="boundvar">a</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Lex.Manual.dec1"><code><a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.dec1"><span class="name function">dec1</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.SafeTok"><span class="name function">SafeTok</span></a>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span></code></dt><dd><pre>  Tries to read additional decimal digits onto a growing natural number.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Lex.Manual.dec"><code><a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.dec"><span class="name function">dec</span></a>&ensp;:&ensp;<a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.StrictTok"><span class="name function">StrictTok</span></a>&ensp;<span class="boundvar">e</span>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span></code></dt><dd><pre>  Tries to read a natural number. Fails, if this does not contain at least<br>  one digit.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Lex.Manual.dec_1"><code><a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.dec_1"><span class="name function">dec_1</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.AutoTok"><span class="name function">AutoTok</span></a>&ensp;<span class="boundvar">e</span>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span></code></dt><dd><pre>  Tries to read more decimal digits onto a growing natural number.<br>  Supports underscores as separators for better readability.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Lex.Manual.decSep"><code><a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.decSep"><span class="name function">decSep</span></a>&ensp;:&ensp;<a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.StrictTok"><span class="name function">StrictTok</span></a>&ensp;<span class="boundvar">e</span>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span></code></dt><dd><pre>  Tries to read a natural number.<br>  Supports underscores as separators for better readability.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Lex.Manual.bin1"><code><a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.bin1"><span class="name function">bin1</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.SafeTok"><span class="name function">SafeTok</span></a>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span></code></dt><dd><pre>  Tries to read more binary digits onto a growing natural number.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Lex.Manual.bin"><code><a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.bin"><span class="name function">bin</span></a>&ensp;:&ensp;<a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.StrictTok"><span class="name function">StrictTok</span></a>&ensp;<span class="boundvar">e</span>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span></code></dt><dd><pre>  Tries to read a binary natural number.<br>  Fails, if this does not contain at least one digit.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Lex.Manual.bin_1"><code><a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.bin_1"><span class="name function">bin_1</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.AutoTok"><span class="name function">AutoTok</span></a>&ensp;<span class="boundvar">e</span>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span></code></dt><dd><pre>  Tries to read more binary digits onto a growing natural number.<br>  Supports underscores as separators for better readability.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Lex.Manual.binSep"><code><a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.binSep"><span class="name function">binSep</span></a>&ensp;:&ensp;<a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.StrictTok"><span class="name function">StrictTok</span></a>&ensp;<span class="boundvar">e</span>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span></code></dt><dd><pre>  Tries to read a binary natural number.<br>  Fails, if this does not contain at least one digit.<br>  Supports underscores as separators for better readability.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Lex.Manual.oct1"><code><a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.oct1"><span class="name function">oct1</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.SafeTok"><span class="name function">SafeTok</span></a>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span></code></dt><dd><pre>  Tries to read more octal digits onto a growing natural number.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Lex.Manual.oct"><code><a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.oct"><span class="name function">oct</span></a>&ensp;:&ensp;<a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.StrictTok"><span class="name function">StrictTok</span></a>&ensp;<span class="boundvar">e</span>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span></code></dt><dd><pre>  Tries to read a octal natural number.<br>  Fails, if this does not contain at least one digit.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Lex.Manual.oct_1"><code><a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.oct_1"><span class="name function">oct_1</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.AutoTok"><span class="name function">AutoTok</span></a>&ensp;<span class="boundvar">e</span>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span></code></dt><dd><pre>  Tries to read more octal digits onto a growing natural number.<br>  Supports underscores as separators for better readability.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Lex.Manual.octSep"><code><a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.octSep"><span class="name function">octSep</span></a>&ensp;:&ensp;<a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.StrictTok"><span class="name function">StrictTok</span></a>&ensp;<span class="boundvar">e</span>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span></code></dt><dd><pre>  Tries to read a octal natural number.<br>  Fails, if this does not contain at least one digit.<br>  Supports underscores as separators for better readability.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Lex.Manual.hex1"><code><a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.hex1"><span class="name function">hex1</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.SafeTok"><span class="name function">SafeTok</span></a>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span></code></dt><dd><pre>  Tries to read more hexadecimal digits onto a growing natural number.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Lex.Manual.hex"><code><a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.hex"><span class="name function">hex</span></a>&ensp;:&ensp;<a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.StrictTok"><span class="name function">StrictTok</span></a>&ensp;<span class="boundvar">e</span>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span></code></dt><dd><pre>  Tries to read a hexadecimal natural number.<br>  Fails, if this does not contain at least one digit.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Lex.Manual.hex_1"><code><a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.hex_1"><span class="name function">hex_1</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.AutoTok"><span class="name function">AutoTok</span></a>&ensp;<span class="boundvar">e</span>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span></code></dt><dd><pre>  Tries to read more hexadecimal digits onto a growing natural number.<br>  Supports underscores as separators for better readability.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Lex.Manual.hexSep"><code><a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.hexSep"><span class="name function">hexSep</span></a>&ensp;:&ensp;<a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.StrictTok"><span class="name function">StrictTok</span></a>&ensp;<span class="boundvar">e</span>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span></code></dt><dd><pre>  Tries to read a hexadecimal natural number.<br>  Fails, if this does not contain at least one digit.<br>  Supports underscores as separators for better readability.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Lex.Manual.int"><code><a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.int"><span class="name function">int</span></a>&ensp;:&ensp;<a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.StrictTok"><span class="name function">StrictTok</span></a>&ensp;<span class="boundvar">e</span>&ensp;<span class="name type">Integer</span></code></dt><dd><pre>  A shifter that takes moves an integer prefix</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Lex.Manual.intPlus"><code><a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.intPlus"><span class="name function">intPlus</span></a>&ensp;:&ensp;<a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.StrictTok"><span class="name function">StrictTok</span></a>&ensp;<span class="boundvar">e</span>&ensp;<span class="name type">Integer</span></code></dt><dd><pre>  Like `int` but also allows an optional leading `&apos;+&apos;` character.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Lex.Manual.takeJustOnto"><code><a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.takeJustOnto"><span class="name function">takeJustOnto</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.SnocList"><span class="name type">SnocList</span></span>&ensp;<span class="boundvar">y</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="name type">Char</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;<span class="boundvar">y</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.SafeTok"><span class="name function">SafeTok</span></a>&ensp;(<span class="type resolved" title="Prelude.Basics.SnocList"><span class="name type">SnocList</span></span>&ensp;<span class="boundvar">y</span>)</code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Lex.Manual.takeJust"><code><a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.takeJust"><span class="name function">takeJust</span></a>&ensp;:&ensp;(<span class="name type">Char</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;<span class="boundvar">y</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.SafeTok"><span class="name function">SafeTok</span></a>&ensp;(<span class="type resolved" title="Prelude.Basics.SnocList"><span class="name type">SnocList</span></span>&ensp;<span class="boundvar">y</span>)</code></dt><dd><pre>  Consumes and converts a list prefix until the given<br>  function returns `Nothing`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Lex.Manual.takeJust1"><code><a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.takeJust1"><span class="name function">takeJust1</span></a>&ensp;:&ensp;(<span class="name type">Char</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;<span class="boundvar">y</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.StrictTok"><span class="name function">StrictTok</span></a>&ensp;<span class="boundvar">e</span>&ensp;(<span class="type resolved" title="Prelude.Basics.SnocList"><span class="name type">SnocList</span></span>&ensp;<span class="boundvar">y</span>)</code></dt><dd><pre>  Consumes and converts a strict list prefix until the given<br>  function returns `Nothing`.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Lex.Manual.singleLineDropSpaces"><code><a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.singleLineDropSpaces"><span class="name function">singleLineDropSpaces</span></a>&ensp;:&ensp;<a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.Tok"><span class="name function">Tok</span></a>&ensp;<span class="type resolved" title="Prelude.Basics.True"><span class="name constructor">True</span></span>&ensp;<span class="boundvar">e</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">String</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Either"><span class="name type">Either</span></span>&ensp;(<a class="type" href="Text.Bounds.html#Text.Bounds.Bounded"><span class="name type">Bounded</span></a>&ensp;(<a class="type" href="Text.ParseError.html#Text.ParseError.ParseError"><span class="name type">ParseError</span></a>&ensp;<span class="type resolved" title="Builtin.Void"><span class="name type">Void</span></span>&ensp;<span class="boundvar">e</span>))&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;(<a class="type" href="Text.Bounds.html#Text.Bounds.Bounded"><span class="name type">Bounded</span></a>&ensp;<span class="boundvar">a</span>))</code></dt><dd><pre>  Repeatedly consumes a strict prefix of a list of characters<br>  until the whole list is consumed. Drops all white space<br>  it encounters (unsing `Prelude.isSpace` to determine, what is<br>  a whitespace character).<br>  <br>  This assumes that every token is on a single line. Therefore, it is<br>  more efficient than `multilineDropSpaces`, because it does not have<br>  to traverse the consumed characters to find line breaks.<br>  <br>  This is provably total, due to the strictness of the consuming<br>  function.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Lex.Manual.multiLineDropSpaces"><code><a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.multiLineDropSpaces"><span class="name function">multiLineDropSpaces</span></a>&ensp;:&ensp;<a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.Tok"><span class="name function">Tok</span></a>&ensp;<span class="type resolved" title="Prelude.Basics.True"><span class="name constructor">True</span></span>&ensp;<span class="boundvar">e</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">String</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Either"><span class="name type">Either</span></span>&ensp;(<a class="type" href="Text.Bounds.html#Text.Bounds.Bounded"><span class="name type">Bounded</span></a>&ensp;(<a class="type" href="Text.ParseError.html#Text.ParseError.ParseError"><span class="name type">ParseError</span></a>&ensp;<span class="type resolved" title="Builtin.Void"><span class="name type">Void</span></span>&ensp;<span class="boundvar">e</span>))&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;(<a class="type" href="Text.Bounds.html#Text.Bounds.Bounded"><span class="name type">Bounded</span></a>&ensp;<span class="boundvar">a</span>))</code></dt><dd><pre>  Like `singleLineDropSpaces`, but consumed tokens might be<br>  spread across several lines.<br>  <br>  This is provably total, due to the strictness of the consuming<br>  function.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Lex.Manual.lexManual"><code><a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.lexManual"><span class="name function">lexManual</span></a>&ensp;:&ensp;<a class="type" href="Text.Lex.Manual.html#Text.Lex.Manual.Tok"><span class="name function">Tok</span></a>&ensp;<span class="type resolved" title="Prelude.Basics.True"><span class="name constructor">True</span></span>&ensp;<span class="boundvar">e</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">String</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Either"><span class="name type">Either</span></span>&ensp;(<a class="type" href="Text.Bounds.html#Text.Bounds.Bounded"><span class="name type">Bounded</span></a>&ensp;(<a class="type" href="Text.ParseError.html#Text.ParseError.ParseError"><span class="name type">ParseError</span></a>&ensp;<span class="type resolved" title="Builtin.Void"><span class="name type">Void</span></span>&ensp;<span class="boundvar">e</span>))&ensp;(<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;(<a class="type" href="Text.Bounds.html#Text.Bounds.Bounded"><span class="name type">Bounded</span></a>&ensp;<span class="boundvar">a</span>))</code></dt><dd><pre>  Repeatedly consumes a strict prefix of a list of characters<br>  until the whole list is consumed. It uses the amount of characters<br>  consumed to determine the bounds of the consumed lexemes.<br>  <br>  This is provably total, due to the strictness of the consuming<br>  function.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd></dl></div><footer>Produced by Idris 2 version 0.7.0-da352d8ed</footer></body></html>
