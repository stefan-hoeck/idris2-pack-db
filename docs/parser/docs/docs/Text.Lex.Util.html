<!DOCTYPE html><html lang="en">

<head>
  <meta charset="utf-8">
  <title>Text.Lex.Util</title>
  <link rel="stylesheet" type="text/css" id="preferredStyle" href="../default.css">
  <script>
    /* Updates the stylesheet to use the preferred one.
       Note that we set the link to root ++ sourceLoc because the config
       is shared across the whole website, so the root may differ from
       page to page.
    */
    function setStyleSource (sourceLoc) {
      document.getElementById("preferredStyle").href = "../" + sourceLoc + ".css";
      document.getElementById("selectPreferredStyle").value = sourceLoc;
    }
    /* Initialises the preferred style sheet:
       1. if there is a stored value then use that
          otherwise select the default
       2. set both the css link href & the drop down menu selected option
    */
    function initStyleSource () {
      var preferredStyle = localStorage.getItem("stylefile");
      if (preferredStyle !== null) {
        setStyleSource(preferredStyle);
      } else {
        setStyleSource("default");
      };
    }
    function saveStyleSource (preferredStyle) {
      localStorage.stylefile = preferredStyle;
    }
    </script>
</head>

<body class="namespace">
<header>
  <strong>Idris2Doc</strong> : Text.Lex.Util
  <nav><a href="../index.html">Index</a>

  <select id="selectPreferredStyle">
    <option value="default">Default</option>
<option value="alternative">Alternative</option>
<option value="blackandwhite">Black & White</option>

  </select>
  </nav>

  <script>
  /* We start by initialising the style source */
  initStyleSource();

  /* This listens for changes on the drop down menu and updates the
     css used for the current page when a selection is made.
  */
  document.getElementById("selectPreferredStyle").addEventListener("change", function(){
    var selected = this.options[this.selectedIndex].value; /* the option chosen */
    setStyleSource (selected);
    saveStyleSource (selected);
  });
</script>

</header>
<div class="container"><div id="module-header"><h1>Text.Lex.Util</h1><span style="float:right">(<a href="Text.Lex.Util.src.html">source</a>)</span><pre></pre></div><code></code><h2>Definitions</h2><dl class="decls"><dt id="Text.Lex.Util.stripQuotes"><code><a class="type" href="Text.Lex.Util.html#Text.Lex.Util.stripQuotes"><span class="name function">stripQuotes</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.SnocList"><span class="name type">SnocList</span></span>&ensp;<span class="name type">Char</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">String</span></code></dt><dd>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Lex.Util.List.ltrim"><code><span class="type resolved" title="Text.Lex.Util.List.ltrim"><span class="name function">ltrim</span></span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="name type">Char</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="name type">Char</span></code></dt><dd>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Text.Lex.Util.List.countHashtag"><code><span class="type resolved" title="Text.Lex.Util.List.countHashtag"><span class="name function">countHashtag</span></span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="name type">Char</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span></code></dt><dd>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Text.Lex.Util.SnocList.rtrim"><code><span class="type resolved" title="Text.Lex.Util.SnocList.rtrim"><span class="name function">rtrim</span></span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.SnocList"><span class="name type">SnocList</span></span>&ensp;<span class="name type">Char</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.SnocList"><span class="name type">SnocList</span></span>&ensp;<span class="name type">Char</span></code></dt><dd>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Text.Lex.Util.SnocList.dropHead"><code><span class="type resolved" title="Text.Lex.Util.SnocList.dropHead"><span class="name function">dropHead</span></span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.SnocList"><span class="name type">SnocList</span></span>&ensp;<span class="name type">Char</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="name type">Char</span></code></dt><dd>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Text.Lex.Util.SnocList.countHashtag"><code><span class="type resolved" title="Text.Lex.Util.SnocList.countHashtag"><span class="name function">countHashtag</span></span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.SnocList"><span class="name type">SnocList</span></span>&ensp;<span class="name type">Char</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span></code></dt><dd>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Text.Lex.Util.any"><code><a class="type" href="Text.Lex.Util.html#Text.Lex.Util.any"><span class="name function">any</span></a>&ensp;:&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Lexer"><span class="name function">Lexer</span></a></code></dt><dd>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Text.Lex.Util.non"><code><a class="type" href="Text.Lex.Util.html#Text.Lex.Util.non"><span class="name function">non</span></a>&ensp;:&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Lexer"><span class="name function">Lexer</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Lexer"><span class="name function">Lexer</span></a></code></dt><dd><pre>  Recognise any character if the sub-lexer `l` fails.<br>  /(?!`l`)./</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Text.Lex.Util.is"><code><a class="type" href="Text.Lex.Util.html#Text.Lex.Util.is"><span class="name function">is</span></a>&ensp;:&ensp;<span class="name type">Char</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Lexer"><span class="name function">Lexer</span></a></code></dt><dd><pre>  Recognise a specific item.<br>  /[`x`]/</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Text.Lex.Util.isNot"><code><a class="type" href="Text.Lex.Util.html#Text.Lex.Util.isNot"><span class="name function">isNot</span></a>&ensp;:&ensp;<span class="name type">Char</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Lexer"><span class="name function">Lexer</span></a></code></dt><dd><pre>  Recognise anything but the given item.<br>  /[\^`x`]/</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Text.Lex.Util.space"><code><a class="type" href="Text.Lex.Util.html#Text.Lex.Util.space"><span class="name function">space</span></a>&ensp;:&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Lexer"><span class="name function">Lexer</span></a></code></dt><dd><pre>  Recognise a single whitespace character.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Text.Lex.Util.digit"><code><a class="type" href="Text.Lex.Util.html#Text.Lex.Util.digit"><span class="name function">digit</span></a>&ensp;:&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Lexer"><span class="name function">Lexer</span></a></code></dt><dd><pre>  Recognise a single digit.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Text.Lex.Util.like"><code><a class="type" href="Text.Lex.Util.html#Text.Lex.Util.like"><span class="name function">like</span></a>&ensp;:&ensp;<span class="name type">Char</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Lexer"><span class="name function">Lexer</span></a></code></dt><dd><pre>  Recognise a specific character (case-insensitive).<br>  /[`x`]/i</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Text.Lex.Util.notLike"><code><a class="type" href="Text.Lex.Util.html#Text.Lex.Util.notLike"><span class="name function">notLike</span></a>&ensp;:&ensp;<span class="name type">Char</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Lexer"><span class="name function">Lexer</span></a></code></dt><dd><pre>  Recognise anything but the given character (case-insensitive).<br>  /[\^`x`]/i</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Text.Lex.Util.oneOf"><code><a class="type" href="Text.Lex.Util.html#Text.Lex.Util.oneOf"><span class="name function">oneOf</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="name type">Char</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Lexer"><span class="name function">Lexer</span></a></code></dt><dd><pre>  Recognises one of the given characters.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Text.Lex.Util.range"><code><a class="type" href="Text.Lex.Util.html#Text.Lex.Util.range"><span class="name function">range</span></a>&ensp;:&ensp;<span class="name type">Char</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Char</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Lexer"><span class="name function">Lexer</span></a></code></dt><dd><pre>  Recognise a character in a range. Also works in reverse!<br>  /[`start`-`end`]/</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Text.Lex.Util.prefixBy"><code><a class="type" href="Text.Lex.Util.html#Text.Lex.Util.prefixBy"><span class="name function">prefixBy</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;(<span class="name type">Char</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Lexer"><span class="name function">Lexer</span></a></code></dt><dd>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Text.Lex.Util.exact"><code><a class="type" href="Text.Lex.Util.html#Text.Lex.Util.exact"><span class="name function">exact</span></a>&ensp;:&ensp;<span class="name type">String</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Lexer"><span class="name function">Lexer</span></a></code></dt><dd>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Text.Lex.Util.approx"><code><a class="type" href="Text.Lex.Util.html#Text.Lex.Util.approx"><span class="name function">approx</span></a>&ensp;:&ensp;<span class="name type">String</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Lexer"><span class="name function">Lexer</span></a></code></dt><dd>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Text.Lex.Util.digits"><code><a class="type" href="Text.Lex.Util.html#Text.Lex.Util.digits"><span class="name function">digits</span></a>&ensp;:&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Lexer"><span class="name function">Lexer</span></a></code></dt><dd><pre>  Recognise a non-empty sequence of digits.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Text.Lex.Util.symbol"><code><a class="type" href="Text.Lex.Util.html#Text.Lex.Util.symbol"><span class="name function">symbol</span></a>&ensp;:&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Lexer"><span class="name function">Lexer</span></a></code></dt><dd><pre>  Recognise a single non-whitespace, non-alphanumeric character<br>  /[\^\\sA-Za-z0-9]/</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Text.Lex.Util.symbols"><code><a class="type" href="Text.Lex.Util.html#Text.Lex.Util.symbols"><span class="name function">symbols</span></a>&ensp;:&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Lexer"><span class="name function">Lexer</span></a></code></dt><dd><pre>  Recognise one or more non-whitespace, non-alphanumeric characters<br>  /[\^\\sA-Za-z0-9]+/</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Text.Lex.Util.control"><code><a class="type" href="Text.Lex.Util.html#Text.Lex.Util.control"><span class="name function">control</span></a>&ensp;:&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Lexer"><span class="name function">Lexer</span></a></code></dt><dd>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Text.Lex.Util.controls"><code><a class="type" href="Text.Lex.Util.html#Text.Lex.Util.controls"><span class="name function">controls</span></a>&ensp;:&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Lexer"><span class="name function">Lexer</span></a></code></dt><dd><pre>  Recognise one or more control characters<br>  /[\\x00-\\x1f\\x7f-\\x9f]+/</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Text.Lex.Util.someOf"><code><a class="type" href="Text.Lex.Util.html#Text.Lex.Util.someOf"><span class="name function">someOf</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="name type">Char</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Lexer"><span class="name function">Lexer</span></a></code></dt><dd><pre>  Recognises a non-empty sequence of the given items</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Text.Lex.Util.ranges"><code><a class="type" href="Text.Lex.Util.html#Text.Lex.Util.ranges"><span class="name function">ranges</span></a>&ensp;:&ensp;<span class="name type">Char</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Char</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Lexer"><span class="name function">Lexer</span></a></code></dt><dd><pre>  Recognise some items in a range. Also works in reverse!<br>  /[`start`-`end`]/</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Text.Lex.Util.spaces"><code><a class="type" href="Text.Lex.Util.html#Text.Lex.Util.spaces"><span class="name function">spaces</span></a>&ensp;:&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Lexer"><span class="name function">Lexer</span></a></code></dt><dd><pre>  Recognise a non-empty sequence of whitespace characters.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Text.Lex.Util.spaceChars"><code><a class="type" href="Text.Lex.Util.html#Text.Lex.Util.spaceChars"><span class="name function">spaceChars</span></a>&ensp;:&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Lexer"><span class="name function">Lexer</span></a></code></dt><dd><pre>  Recognise a non-empty sequence of space characters.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Text.Lex.Util.newline"><code><a class="type" href="Text.Lex.Util.html#Text.Lex.Util.newline"><span class="name function">newline</span></a>&ensp;:&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Lexer"><span class="name function">Lexer</span></a></code></dt><dd><pre>  Recognise a single newline character sequence</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Text.Lex.Util.manyTillNewline"><code><a class="type" href="Text.Lex.Util.html#Text.Lex.Util.manyTillNewline"><span class="name function">manyTillNewline</span></a>&ensp;:&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Recognise"><span class="name type">Recognise</span></a>&ensp;<span class="type resolved" title="Prelude.Basics.False"><span class="name constructor">False</span></span></code></dt><dd><pre>  Reads characters until the next newline character is<br>  encountered.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Text.Lex.Util.manyTillLineFeed"><code><a class="type" href="Text.Lex.Util.html#Text.Lex.Util.manyTillLineFeed"><span class="name function">manyTillLineFeed</span></a>&ensp;:&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Recognise"><span class="name type">Recognise</span></a>&ensp;<span class="type resolved" title="Prelude.Basics.False"><span class="name constructor">False</span></span></code></dt><dd><pre>  Reads characters until the next linefeed character (`&apos;\n&apos;`) is<br>  encountered.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Text.Lex.Util.lineComment"><code><a class="type" href="Text.Lex.Util.html#Text.Lex.Util.lineComment"><span class="name function">lineComment</span></a>&ensp;:&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Lexer"><span class="name function">Lexer</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Lexer"><span class="name function">Lexer</span></a></code></dt><dd><pre>  Lexer for single line comments starting with the given prefix.<br>  <br>  This reads until (but does not include) the first newline<br>  character `&apos;\n&apos;` or `&apos;\r&apos;`.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Text.Lex.Util.linefeedComment"><code><a class="type" href="Text.Lex.Util.html#Text.Lex.Util.linefeedComment"><span class="name function">linefeedComment</span></a>&ensp;:&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Lexer"><span class="name function">Lexer</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Lexer"><span class="name function">Lexer</span></a></code></dt><dd><pre>  Lexer for single line comments starting with the given prefix.<br>  <br>  This reads until (but does not include) the first line feed<br>  character (`&apos;\n&apos;`).</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Text.Lex.Util.atLeast"><code><a class="type" href="Text.Lex.Util.html#Text.Lex.Util.atLeast"><span class="name function">atLeast</span></a>&ensp;:&ensp;(<span class="boundvar">n</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Lexer"><span class="name function">Lexer</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Recognise"><span class="name type">Recognise</span></a>&ensp;(<span class="type resolved" title="Data.Nat.isSucc"><span class="name function">isSucc</span></span>&ensp;<span class="boundvar">n</span>)</code></dt><dd>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Text.Lex.Util.exactly"><code><a class="type" href="Text.Lex.Util.html#Text.Lex.Util.exactly"><span class="name function">exactly</span></a>&ensp;:&ensp;(<span class="boundvar">n</span>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Lexer"><span class="name function">Lexer</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;{<span class="keyword">auto</span>&ensp;<span class="keyword">0</span>&ensp;<span class="boundvar">_</span>&ensp;:&ensp;<span class="type resolved" title="Data.Nat.IsSucc"><span class="name type">IsSucc</span></span>&ensp;<span class="boundvar">n</span>}&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Lexer"><span class="name function">Lexer</span></a></code></dt><dd>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Text.Lex.Util.manyUntil"><code><a class="type" href="Text.Lex.Util.html#Text.Lex.Util.manyUntil"><span class="name function">manyUntil</span></a>&ensp;:&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Recognise"><span class="name type">Recognise</span></a>&ensp;<span class="boundvar">c</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Lexer"><span class="name function">Lexer</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Recognise"><span class="name type">Recognise</span></a>&ensp;<span class="type resolved" title="Prelude.Basics.False"><span class="name constructor">False</span></span></code></dt><dd>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Text.Lex.Util.someUntil"><code><a class="type" href="Text.Lex.Util.html#Text.Lex.Util.someUntil"><span class="name function">someUntil</span></a>&ensp;:&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Recognise"><span class="name type">Recognise</span></a>&ensp;<span class="boundvar">c</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Lexer"><span class="name function">Lexer</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Lexer"><span class="name function">Lexer</span></a></code></dt><dd>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Text.Lex.Util.manyThen"><code><a class="type" href="Text.Lex.Util.html#Text.Lex.Util.manyThen"><span class="name function">manyThen</span></a>&ensp;:&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Recognise"><span class="name type">Recognise</span></a>&ensp;<span class="boundvar">c</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Lexer"><span class="name function">Lexer</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Recognise"><span class="name type">Recognise</span></a>&ensp;<span class="boundvar">c</span></code></dt><dd>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Text.Lex.Util.surround"><code><a class="type" href="Text.Lex.Util.html#Text.Lex.Util.surround"><span class="name function">surround</span></a>&ensp;:&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Lexer"><span class="name function">Lexer</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Lexer"><span class="name function">Lexer</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Lexer"><span class="name function">Lexer</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Lexer"><span class="name function">Lexer</span></a></code></dt><dd><pre>  Recognise zero or more occurrences of a sub-lexer between<br>  delimiting lexers<br>  /`start`(`l`)\*?`end`/</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Text.Lex.Util.quote"><code><a class="type" href="Text.Lex.Util.html#Text.Lex.Util.quote"><span class="name function">quote</span></a>&ensp;:&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Lexer"><span class="name function">Lexer</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Lexer"><span class="name function">Lexer</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Lexer"><span class="name function">Lexer</span></a></code></dt><dd><pre>  Recognise zero or more occurrences of a sub-lexer surrounded<br>  by the same quote lexer on both sides (useful for strings)<br>  /`q`(`l`)\*?`q`/</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Text.Lex.Util.escape"><code><a class="type" href="Text.Lex.Util.html#Text.Lex.Util.escape"><span class="name function">escape</span></a>&ensp;:&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Lexer"><span class="name function">Lexer</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Lexer"><span class="name function">Lexer</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Lexer"><span class="name function">Lexer</span></a></code></dt><dd><pre>  Recognise an escape sub-lexer (often &apos;\\&apos;) followed by<br>  another sub-lexer<br>  /[`esc`]`l`/</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Text.Lex.Util.stringLit"><code><a class="type" href="Text.Lex.Util.html#Text.Lex.Util.stringLit"><span class="name function">stringLit</span></a>&ensp;:&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Lexer"><span class="name function">Lexer</span></a></code></dt><dd>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Text.Lex.Util.intLit"><code><a class="type" href="Text.Lex.Util.html#Text.Lex.Util.intLit"><span class="name function">intLit</span></a>&ensp;:&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Lexer"><span class="name function">Lexer</span></a></code></dt><dd><pre>  Recognise an integer literal (possibly with a &apos;-&apos; prefix)<br>  /-?[0-9]+/</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Text.Lex.Util.intLitPlus"><code><a class="type" href="Text.Lex.Util.html#Text.Lex.Util.intLitPlus"><span class="name function">intLitPlus</span></a>&ensp;:&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Lexer"><span class="name function">Lexer</span></a></code></dt><dd><pre>  Recognise an integer literal (possibly with a &apos;+&apos; or &apos;-&apos; prefix)</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Text.Lex.Util.binDigits"><code><a class="type" href="Text.Lex.Util.html#Text.Lex.Util.binDigits"><span class="name function">binDigits</span></a>&ensp;:&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Lexer"><span class="name function">Lexer</span></a></code></dt><dd>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Text.Lex.Util.hexDigits"><code><a class="type" href="Text.Lex.Util.html#Text.Lex.Util.hexDigits"><span class="name function">hexDigits</span></a>&ensp;:&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Lexer"><span class="name function">Lexer</span></a></code></dt><dd>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Text.Lex.Util.octDigits"><code><a class="type" href="Text.Lex.Util.html#Text.Lex.Util.octDigits"><span class="name function">octDigits</span></a>&ensp;:&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Lexer"><span class="name function">Lexer</span></a></code></dt><dd>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Text.Lex.Util.binLit"><code><a class="type" href="Text.Lex.Util.html#Text.Lex.Util.binLit"><span class="name function">binLit</span></a>&ensp;:&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Lexer"><span class="name function">Lexer</span></a></code></dt><dd><pre>  Recognise a binary literal, prefixed by &quot;0b&quot;<br>  /0b[0-1]+/</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Text.Lex.Util.hexLit"><code><a class="type" href="Text.Lex.Util.html#Text.Lex.Util.hexLit"><span class="name function">hexLit</span></a>&ensp;:&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Lexer"><span class="name function">Lexer</span></a></code></dt><dd><pre>  Recognise a hexidecimal literal, prefixed by &quot;0x&quot; or &quot;0X&quot;<br>  /0[Xx][0-9A-Fa-f]+/</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Text.Lex.Util.octLit"><code><a class="type" href="Text.Lex.Util.html#Text.Lex.Util.octLit"><span class="name function">octLit</span></a>&ensp;:&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Lexer"><span class="name function">Lexer</span></a></code></dt><dd><pre>  Recognise an octal literal, prefixed by &quot;0o&quot;<br>  /0o[0-9A-Fa-f]+/</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Text.Lex.Util.digitsUnderscoredLit"><code><a class="type" href="Text.Lex.Util.html#Text.Lex.Util.digitsUnderscoredLit"><span class="name function">digitsUnderscoredLit</span></a>&ensp;:&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Lexer"><span class="name function">Lexer</span></a></code></dt><dd><pre>  Recognise a decimal integer literal with optional undescores for<br>  improved readability.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Text.Lex.Util.binUnderscoredLit"><code><a class="type" href="Text.Lex.Util.html#Text.Lex.Util.binUnderscoredLit"><span class="name function">binUnderscoredLit</span></a>&ensp;:&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Lexer"><span class="name function">Lexer</span></a></code></dt><dd><pre>  Recognise a binary literal with optional undescores for<br>  improved readability.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Text.Lex.Util.hexUnderscoredLit"><code><a class="type" href="Text.Lex.Util.html#Text.Lex.Util.hexUnderscoredLit"><span class="name function">hexUnderscoredLit</span></a>&ensp;:&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Lexer"><span class="name function">Lexer</span></a></code></dt><dd><pre>  Recognise a hexadecimal literal with optional undescores for<br>  improved readability.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Text.Lex.Util.octUnderscoredLit"><code><a class="type" href="Text.Lex.Util.html#Text.Lex.Util.octUnderscoredLit"><span class="name function">octUnderscoredLit</span></a>&ensp;:&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Lexer"><span class="name function">Lexer</span></a></code></dt><dd><pre>  Recognise an octal literal with optional undescores for<br>  improved readability.</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Text.Lex.Util.charLit"><code><a class="type" href="Text.Lex.Util.html#Text.Lex.Util.charLit"><span class="name function">charLit</span></a>&ensp;:&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Lexer"><span class="name function">Lexer</span></a></code></dt><dd><pre>  Recognise a character literal, including escaped characters.<br>  (Note: doesn&apos;t yet handle escape sequences such as \123)<br>  /&apos;(\\\\.|[\^&apos;])&apos;/</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Text.Lex.Util.doubleLit"><code><a class="type" href="Text.Lex.Util.html#Text.Lex.Util.doubleLit"><span class="name function">doubleLit</span></a>&ensp;:&ensp;<a class="type" href="Text.Lex.Core.html#Text.Lex.Core.Lexer"><span class="name function">Lexer</span></a></code></dt><dd>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd></dl></div><footer>Produced by Idris 2 version 0.7.0-da352d8ed</footer></body></html>
