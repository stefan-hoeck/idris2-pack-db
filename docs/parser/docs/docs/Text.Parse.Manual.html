<!DOCTYPE html><html lang="en">

<head>
  <meta charset="utf-8">
  <title>Text.Parse.Manual</title>
  <link rel="stylesheet" type="text/css" id="preferredStyle" href="../default.css">
  <script>
    /* Updates the stylesheet to use the preferred one.
       Note that we set the link to root ++ sourceLoc because the config
       is shared across the whole website, so the root may differ from
       page to page.
    */
    function setStyleSource (sourceLoc) {
      document.getElementById("preferredStyle").href = "../" + sourceLoc + ".css";
      document.getElementById("selectPreferredStyle").value = sourceLoc;
    }
    /* Initialises the preferred style sheet:
       1. if there is a stored value then use that
          otherwise select the default
       2. set both the css link href & the drop down menu selected option
    */
    function initStyleSource () {
      var preferredStyle = localStorage.getItem("stylefile");
      if (preferredStyle !== null) {
        setStyleSource(preferredStyle);
      } else {
        setStyleSource("default");
      };
    }
    function saveStyleSource (preferredStyle) {
      localStorage.stylefile = preferredStyle;
    }
    </script>
</head>

<body class="namespace">
<header>
  <strong>Idris2Doc</strong> : Text.Parse.Manual
  <nav><a href="../index.html">Index</a>

  <select id="selectPreferredStyle">
    <option value="default">Default</option>
<option value="alternative">Alternative</option>
<option value="blackandwhite">Black & White</option>

  </select>
  </nav>

  <script>
  /* We start by initialising the style source */
  initStyleSource();

  /* This listens for changes on the drop down menu and updates the
     css used for the current page when a selection is made.
  */
  document.getElementById("selectPreferredStyle").addEventListener("change", function(){
    var selected = this.options[this.selectedIndex].value; /* the option chosen */
    setStyleSource (selected);
    saveStyleSource (selected);
  });
</script>

</header>
<div class="container"><div id="module-header"><h1>Text.Parse.Manual</h1><span style="float:right">(<a href="Text.Parse.Manual.src.html">source</a>)</span><pre>This module provides utilities for writing parsers by hand (without
using the combinators from module `Text.Parse.Core`).

Typically, you get the best performance by using direct pattern matches
and explicit recursion. However, for those cases where performance is
not the main issue, this module provides some combinators for
certain reoccuring patterns.

It is strongly recommended to use a lexer and probably one or two
cleanup passes over the sequence of generated tokens before parsing,
as this can significantly simplify the parsers.

Example parsers can be found in sub-packages `parser-json` and
`parser-toml`.

Note: The raison d&apos;etre of this module is that writing provably total
      parsers for (recursive) syntax trees is cumbersome or even impossible
      when using parser combinators. In such cases, you have to arrange
      things manually, using a `SuffixAcc` helper to proof termination.
      For everything else, the combinators in here can make your life
      easier.
</pre></div><h2>Reexports</h2><code><span class="keyword">import</span>&ensp;<span class="keyword">public</span>&ensp;Data.Bool.Rewrite<br><span class="keyword">import</span>&ensp;<span class="keyword">public</span>&ensp;Data.List1<br><span class="keyword">import</span>&ensp;<span class="keyword">public</span>&ensp;Data.List.Shift<br><span class="keyword">import</span>&ensp;<span class="keyword">public</span>&ensp;Data.List.Suffix<br><span class="keyword">import</span>&ensp;<span class="keyword">public</span>&ensp;Data.List.Suffix.Result<br><span class="keyword">import</span>&ensp;<span class="keyword">public</span>&ensp;Data.List.Suffix.Result0<br><span class="keyword">import</span>&ensp;<span class="keyword">public</span>&ensp;Text.Bounds<br><span class="keyword">import</span>&ensp;<span class="keyword">public</span>&ensp;Text.FC<br><span class="keyword">import</span>&ensp;<span class="keyword">public</span>&ensp;Text.ParseError<br><span class="keyword">import</span>&ensp;<span class="keyword">public</span>&ensp;Text.Lex.Manual<br><span class="keyword">import</span>&ensp;<span class="keyword">public</span>&ensp;Text.Lex.Shift</code><h2>Definitions</h2><dl class="decls"><dt id="Text.Parse.Manual.Res"><code><span class="keyword">0</span>&ensp;<a class="type" href="Text.Parse.Manual.html#Text.Parse.Manual.Res"><span class="name function">Res</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">t</span>&ensp;:&ensp;<span class="name type">Type</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;(<a class="type" href="Text.Bounds.html#Text.Bounds.Bounded"><span class="name type">Bounded</span></a>&ensp;<span class="boundvar">t</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Parse.Manual.Grammar"><code><span class="keyword">0</span>&ensp;<a class="type" href="Text.Parse.Manual.html#Text.Parse.Manual.Grammar"><span class="name function">Grammar</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Parse.Manual.AccGrammar"><code><span class="keyword">0</span>&ensp;<a class="type" href="Text.Parse.Manual.html#Text.Parse.Manual.AccGrammar"><span class="name function">AccGrammar</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">Type</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Parse.Manual.acc"><code><a class="type" href="Text.Parse.Manual.html#Text.Parse.Manual.acc"><span class="name function">acc</span></a>&ensp;:&ensp;<a class="type" href="Text.Parse.Manual.html#Text.Parse.Manual.AccGrammar"><span class="name function">AccGrammar</span></a>&ensp;<span class="boundvar">b</span>&ensp;<span class="boundvar">t</span>&ensp;<span class="boundvar">e</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Parse.Manual.html#Text.Parse.Manual.Grammar"><span class="name function">Grammar</span></a>&ensp;<span class="boundvar">b</span>&ensp;<span class="boundvar">t</span>&ensp;<span class="boundvar">e</span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Converts a grammar requiring a proof of accessibility to a regular<br>  grammar.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Parse.Manual.swapOr"><code><a class="type" href="Text.Parse.Manual.html#Text.Parse.Manual.swapOr"><span class="name function">swapOr</span></a>&ensp;:&ensp;<a class="type" href="Text.Parse.Manual.html#Text.Parse.Manual.Grammar"><span class="name function">Grammar</span></a>&ensp;(<span class="boundvar">x</span>&ensp;<span class="type resolved" title="Prelude.Basics.(||)"><span class="name function">||</span></span>&ensp;Delay&ensp;<span class="boundvar">y</span>)&ensp;<span class="boundvar">t</span>&ensp;<span class="boundvar">e</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Parse.Manual.html#Text.Parse.Manual.Grammar"><span class="name function">Grammar</span></a>&ensp;(<span class="boundvar">y</span>&ensp;<span class="type resolved" title="Prelude.Basics.(||)"><span class="name function">||</span></span>&ensp;Delay&ensp;<span class="boundvar">x</span>)&ensp;<span class="boundvar">t</span>&ensp;<span class="boundvar">e</span>&ensp;<span class="boundvar">a</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Parse.Manual.orSame"><code><a class="type" href="Text.Parse.Manual.html#Text.Parse.Manual.orSame"><span class="name function">orSame</span></a>&ensp;:&ensp;<a class="type" href="Text.Parse.Manual.html#Text.Parse.Manual.Grammar"><span class="name function">Grammar</span></a>&ensp;(<span class="boundvar">x</span>&ensp;<span class="type resolved" title="Prelude.Basics.(||)"><span class="name function">||</span></span>&ensp;Delay&ensp;<span class="boundvar">x</span>)&ensp;<span class="boundvar">t</span>&ensp;<span class="boundvar">e</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Parse.Manual.html#Text.Parse.Manual.Grammar"><span class="name function">Grammar</span></a>&ensp;<span class="boundvar">x</span>&ensp;<span class="boundvar">t</span>&ensp;<span class="boundvar">e</span>&ensp;<span class="boundvar">a</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Parse.Manual.orTrue"><code><a class="type" href="Text.Parse.Manual.html#Text.Parse.Manual.orTrue"><span class="name function">orTrue</span></a>&ensp;:&ensp;<a class="type" href="Text.Parse.Manual.html#Text.Parse.Manual.Grammar"><span class="name function">Grammar</span></a>&ensp;(<span class="boundvar">x</span>&ensp;<span class="type resolved" title="Prelude.Basics.(||)"><span class="name function">||</span></span>&ensp;Delay&ensp;<span class="type resolved" title="Prelude.Basics.True"><span class="name constructor">True</span></span>)&ensp;<span class="boundvar">t</span>&ensp;<span class="boundvar">e</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Parse.Manual.html#Text.Parse.Manual.Grammar"><span class="name function">Grammar</span></a>&ensp;<span class="type resolved" title="Prelude.Basics.True"><span class="name constructor">True</span></span>&ensp;<span class="boundvar">t</span>&ensp;<span class="boundvar">e</span>&ensp;<span class="boundvar">a</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Parse.Manual.orFalse"><code><a class="type" href="Text.Parse.Manual.html#Text.Parse.Manual.orFalse"><span class="name function">orFalse</span></a>&ensp;:&ensp;<a class="type" href="Text.Parse.Manual.html#Text.Parse.Manual.Grammar"><span class="name function">Grammar</span></a>&ensp;(<span class="boundvar">x</span>&ensp;<span class="type resolved" title="Prelude.Basics.(||)"><span class="name function">||</span></span>&ensp;Delay&ensp;<span class="type resolved" title="Prelude.Basics.False"><span class="name constructor">False</span></span>)&ensp;<span class="boundvar">t</span>&ensp;<span class="boundvar">e</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Parse.Manual.html#Text.Parse.Manual.Grammar"><span class="name function">Grammar</span></a>&ensp;<span class="boundvar">x</span>&ensp;<span class="boundvar">t</span>&ensp;<span class="boundvar">e</span>&ensp;<span class="boundvar">a</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Parse.Manual.swapAnd"><code><a class="type" href="Text.Parse.Manual.html#Text.Parse.Manual.swapAnd"><span class="name function">swapAnd</span></a>&ensp;:&ensp;<a class="type" href="Text.Parse.Manual.html#Text.Parse.Manual.Grammar"><span class="name function">Grammar</span></a>&ensp;(<span class="boundvar">x</span>&ensp;<span class="type resolved" title="Prelude.Basics.(&amp;&amp;)"><span class="name function">&amp;&amp;</span></span>&ensp;Delay&ensp;<span class="boundvar">y</span>)&ensp;<span class="boundvar">t</span>&ensp;<span class="boundvar">e</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Parse.Manual.html#Text.Parse.Manual.Grammar"><span class="name function">Grammar</span></a>&ensp;(<span class="boundvar">y</span>&ensp;<span class="type resolved" title="Prelude.Basics.(&amp;&amp;)"><span class="name function">&amp;&amp;</span></span>&ensp;Delay&ensp;<span class="boundvar">x</span>)&ensp;<span class="boundvar">t</span>&ensp;<span class="boundvar">e</span>&ensp;<span class="boundvar">a</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Parse.Manual.andSame"><code><a class="type" href="Text.Parse.Manual.html#Text.Parse.Manual.andSame"><span class="name function">andSame</span></a>&ensp;:&ensp;<a class="type" href="Text.Parse.Manual.html#Text.Parse.Manual.Grammar"><span class="name function">Grammar</span></a>&ensp;(<span class="boundvar">x</span>&ensp;<span class="type resolved" title="Prelude.Basics.(&amp;&amp;)"><span class="name function">&amp;&amp;</span></span>&ensp;Delay&ensp;<span class="boundvar">x</span>)&ensp;<span class="boundvar">t</span>&ensp;<span class="boundvar">e</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Parse.Manual.html#Text.Parse.Manual.Grammar"><span class="name function">Grammar</span></a>&ensp;<span class="boundvar">x</span>&ensp;<span class="boundvar">t</span>&ensp;<span class="boundvar">e</span>&ensp;<span class="boundvar">a</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Parse.Manual.andTrue"><code><a class="type" href="Text.Parse.Manual.html#Text.Parse.Manual.andTrue"><span class="name function">andTrue</span></a>&ensp;:&ensp;<a class="type" href="Text.Parse.Manual.html#Text.Parse.Manual.Grammar"><span class="name function">Grammar</span></a>&ensp;(<span class="boundvar">x</span>&ensp;<span class="type resolved" title="Prelude.Basics.(&amp;&amp;)"><span class="name function">&amp;&amp;</span></span>&ensp;Delay&ensp;<span class="type resolved" title="Prelude.Basics.True"><span class="name constructor">True</span></span>)&ensp;<span class="boundvar">t</span>&ensp;<span class="boundvar">e</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Parse.Manual.html#Text.Parse.Manual.Grammar"><span class="name function">Grammar</span></a>&ensp;<span class="boundvar">x</span>&ensp;<span class="boundvar">t</span>&ensp;<span class="boundvar">e</span>&ensp;<span class="boundvar">a</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Parse.Manual.andFalse"><code><a class="type" href="Text.Parse.Manual.html#Text.Parse.Manual.andFalse"><span class="name function">andFalse</span></a>&ensp;:&ensp;<a class="type" href="Text.Parse.Manual.html#Text.Parse.Manual.Grammar"><span class="name function">Grammar</span></a>&ensp;(<span class="boundvar">x</span>&ensp;<span class="type resolved" title="Prelude.Basics.(&amp;&amp;)"><span class="name function">&amp;&amp;</span></span>&ensp;Delay&ensp;<span class="type resolved" title="Prelude.Basics.False"><span class="name constructor">False</span></span>)&ensp;<span class="boundvar">t</span>&ensp;<span class="boundvar">e</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Parse.Manual.html#Text.Parse.Manual.Grammar"><span class="name function">Grammar</span></a>&ensp;<span class="type resolved" title="Prelude.Basics.False"><span class="name constructor">False</span></span>&ensp;<span class="boundvar">t</span>&ensp;<span class="boundvar">e</span>&ensp;<span class="boundvar">a</span></code></dt><dd>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Parse.Manual.terminal"><code><a class="type" href="Text.Parse.Manual.html#Text.Parse.Manual.terminal"><span class="name function">terminal</span></a>&ensp;:&ensp;(<span class="boundvar">t</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Parse.Manual.html#Text.Parse.Manual.Grammar"><span class="name function">Grammar</span></a>&ensp;<span class="type resolved" title="Prelude.Basics.True"><span class="name constructor">True</span></span>&ensp;<span class="boundvar">t</span>&ensp;<span class="boundvar">e</span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Tries to convert the head of the list of tokens.<br>  Fails with appropriate errors if the list is empty or the conversion<br>  fails.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Parse.Manual.terminalE"><code><a class="type" href="Text.Parse.Manual.html#Text.Parse.Manual.terminalE"><span class="name function">terminalE</span></a>&ensp;:&ensp;(<span class="boundvar">t</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Either"><span class="name type">Either</span></span>&ensp;<span class="boundvar">e</span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Parse.Manual.html#Text.Parse.Manual.Grammar"><span class="name function">Grammar</span></a>&ensp;<span class="type resolved" title="Prelude.Basics.True"><span class="name constructor">True</span></span>&ensp;<span class="boundvar">t</span>&ensp;<span class="boundvar">e</span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Like `terminal` but fails with a custom error if the conversion fails.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Parse.Manual.exact"><code><a class="type" href="Text.Parse.Manual.html#Text.Parse.Manual.exact"><span class="name function">exact</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Eq"><span class="name type">Eq</span></span>&ensp;<span class="boundvar">t</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">t</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Parse.Manual.html#Text.Parse.Manual.Grammar"><span class="name function">Grammar</span></a>&ensp;<span class="type resolved" title="Prelude.Basics.True"><span class="name constructor">True</span></span>&ensp;<span class="boundvar">t</span>&ensp;<span class="boundvar">e</span>&ensp;()</code></dt><dd><pre>  Tries to drop the given token from the head of the list of tokens.<br>  Fails with appropriate errors if the list is empty or the token<br>  at the head does not match.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Parse.Manual.peek"><code><a class="type" href="Text.Parse.Manual.html#Text.Parse.Manual.peek"><span class="name function">peek</span></a>&ensp;:&ensp;<a class="type" href="Text.Parse.Manual.html#Text.Parse.Manual.Grammar"><span class="name function">Grammar</span></a>&ensp;<span class="type resolved" title="Prelude.Basics.False"><span class="name constructor">False</span></span>&ensp;<span class="boundvar">t</span>&ensp;<span class="boundvar">e</span>&ensp;<span class="boundvar">t</span></code></dt><dd><pre>  Look at the next token without consuming any input.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Parse.Manual.nextIs"><code><a class="type" href="Text.Parse.Manual.html#Text.Parse.Manual.nextIs"><span class="name function">nextIs</span></a>&ensp;:&ensp;(<span class="boundvar">t</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Parse.Manual.html#Text.Parse.Manual.Grammar"><span class="name function">Grammar</span></a>&ensp;<span class="type resolved" title="Prelude.Basics.False"><span class="name constructor">False</span></span>&ensp;<span class="boundvar">t</span>&ensp;<span class="boundvar">e</span>&ensp;<span class="boundvar">t</span></code></dt><dd><pre>  Check whether the next token satisfies a predicate. Does not consume.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Parse.Manual.nextEquals"><code><a class="type" href="Text.Parse.Manual.html#Text.Parse.Manual.nextEquals"><span class="name function">nextEquals</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Eq"><span class="name type">Eq</span></span>&ensp;<span class="boundvar">t</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">t</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Text.Parse.Manual.html#Text.Parse.Manual.Grammar"><span class="name function">Grammar</span></a>&ensp;<span class="type resolved" title="Prelude.Basics.False"><span class="name constructor">False</span></span>&ensp;<span class="boundvar">t</span>&ensp;<span class="boundvar">e</span>&ensp;<span class="boundvar">t</span></code></dt><dd><pre>  Check whether the next token equals the given value. Does not consume.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">public&ensp;export</span></dd><dt id="Text.Parse.Manual.testParse"><code><a class="type" href="Text.Parse.Manual.html#Text.Parse.Manual.testParse"><span class="name function">testParse</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Show.Show"><span class="name type">Show</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.Interpolation.Interpolation"><span class="name type">Interpolation</span></span>&ensp;<span class="boundvar">e</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<a class="type" href="Text.FC.html#Text.FC.Origin"><span class="name type">Origin</span></a>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">String</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Either"><span class="name type">Either</span></span>&ensp;(<a class="type" href="Text.FC.html#Text.FC.FileContext"><span class="name type">FileContext</span></a>,&ensp;<span class="boundvar">e</span>)&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="name type">String</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="PrimIO.IO"><span class="name type">IO</span></span>&ensp;()</code></dt><dd><pre>  Utility for testing a parses and the error messages it produces<br>  at the REPL.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd></dl></div><footer>Produced by Idris 2 version 0.7.0-da352d8ed</footer></body></html>
