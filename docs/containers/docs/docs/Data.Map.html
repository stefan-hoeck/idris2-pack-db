<!DOCTYPE html><html lang="en">

<head>
  <meta charset="utf-8">
  <title>Data.Map</title>
  <link rel="stylesheet" type="text/css" id="preferredStyle" href="../default.css">
  <script>
    /* Updates the stylesheet to use the preferred one.
       Note that we set the link to root ++ sourceLoc because the config
       is shared across the whole website, so the root may differ from
       page to page.
    */
    function setStyleSource (sourceLoc) {
      document.getElementById("preferredStyle").href = "../" + sourceLoc + ".css";
      document.getElementById("selectPreferredStyle").value = sourceLoc;
    }
    /* Initialises the preferred style sheet:
       1. if there is a stored value then use that
          otherwise select the default
       2. set both the css link href & the drop down menu selected option
    */
    function initStyleSource () {
      var preferredStyle = localStorage.getItem("stylefile");
      if (preferredStyle !== null) {
        setStyleSource(preferredStyle);
      } else {
        setStyleSource("default");
      };
    }
    function saveStyleSource (preferredStyle) {
      localStorage.stylefile = preferredStyle;
    }
    </script>
</head>

<body class="namespace">
<header>
  <strong>Idris2Doc</strong> : Data.Map
  <nav><a href="../index.html">Index</a>

  <select id="selectPreferredStyle">
    <option value="default">Default</option>
<option value="alternative">Alternative</option>
<option value="blackandwhite">Black & White</option>

  </select>
  </nav>

  <script>
  /* We start by initialising the style source */
  initStyleSource();

  /* This listens for changes on the drop down menu and updates the
     css used for the current page when a selection is made.
  */
  document.getElementById("selectPreferredStyle").addEventListener("change", function(){
    var selected = this.options[this.selectedIndex].value; /* the option chosen */
    setStyleSource (selected);
    saveStyleSource (selected);
  });
</script>

</header>
<div class="container"><div id="module-header"><h1>Data.Map</h1><span style="float:right">(<a href="Data.Map.src.html">source</a>)</span><pre>Finite Maps
</pre></div><h2>Reexports</h2><code><span class="keyword">import</span>&ensp;<span class="keyword">public</span>&ensp;Data.Map.Internal</code><h2>Definitions</h2><dl class="decls"><dt id="Data.Map.empty"><code><a class="type" href="Data.Map.html#Data.Map.empty"><span class="name function">empty</span></a>&ensp;:&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span></code></dt><dd><pre>  The empty map. O(1)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.foldl"><code><a class="type" href="Data.Map.html#Data.Map.foldl"><span class="name function">foldl</span></a>&ensp;:&ensp;(<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">w</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">v</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">w</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">v</span></code></dt><dd><pre>  Fold the values in the map using the given left-associative binary operator. O(n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.foldr"><code><a class="type" href="Data.Map.html#Data.Map.foldr"><span class="name function">foldr</span></a>&ensp;:&ensp;(<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">w</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">w</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">w</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">w</span></code></dt><dd><pre>  Fold the values in the map using the given right-associative binary operator. O(n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.foldlWithKey"><code><a class="type" href="Data.Map.html#Data.Map.foldlWithKey"><span class="name function">foldlWithKey</span></a>&ensp;:&ensp;(<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">w</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">v</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">w</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">v</span></code></dt><dd><pre>  Fold the keys and values in the map using the given left-associative binary operator. O(n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.foldrWithKey"><code><a class="type" href="Data.Map.html#Data.Map.foldrWithKey"><span class="name function">foldrWithKey</span></a>&ensp;:&ensp;(<span class="boundvar">k</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">w</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">w</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">w</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">w</span></code></dt><dd><pre>  Fold the keys and values in the map using the given right-associative binary operator. O(n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.insert"><code><a class="type" href="Data.Map.html#Data.Map.insert"><span class="name function">insert</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Eq"><span class="name type">Eq</span></span>&ensp;(<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>)&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.EqOrd.Eq"><span class="name type">Eq</span></span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span></code></dt><dd><pre>  Insert a new key and value in the map.<br>  If the key is already present in the map, the associated value is<br>  replaced with the supplied value. O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.insertWith"><code><a class="type" href="Data.Map.html#Data.Map.insertWith"><span class="name function">insertWith</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">v</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span></code></dt><dd><pre>  Insert with a function, combining new value and old value.<br>  insertWith f key value mp<br>  will insert the pair (key, value) into mp if key does<br>  not exist in the map. If the key does exist, the function will<br>  insert the pair (key, f new_value old_value). O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.insertWithKey"><code><a class="type" href="Data.Map.html#Data.Map.insertWithKey"><span class="name function">insertWithKey</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">k</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">v</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span></code></dt><dd><pre>  Insert with a function, combining key, new value and old value.<br>  insertWithKey f key value mp<br>  will insert the pair (key, value) into mp if key does<br>  not exist in the map. If the key does exist, the function will<br>  insert the pair (key,f key new_value old_value). O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.insertLookupWithKey"><code><a class="type" href="Data.Map.html#Data.Map.insertLookupWithKey"><span class="name function">insertLookupWithKey</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">k</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">v</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;<span class="boundvar">v</span>,&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>)</code></dt><dd><pre>  Combines insert operation with old value retrieval.<br>  The expression (insertLookupWithKey f k x map)<br>  is a pair where the first element is equal to (lookup k map)<br>  and the second element equal to (insertWithKey f k x map). O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.delete"><code><a class="type" href="Data.Map.html#Data.Map.delete"><span class="name function">delete</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Eq"><span class="name type">Eq</span></span>&ensp;(<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>)&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.EqOrd.Eq"><span class="name type">Eq</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span></code></dt><dd><pre>  Delete a key and its value from the map. When the key is not<br>  a member of the map, the original map is returned. O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.adjustWithKey"><code><a class="type" href="Data.Map.html#Data.Map.adjustWithKey"><span class="name function">adjustWithKey</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">k</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">v</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span></code></dt><dd><pre>  Adjust a value at a specific key. When the key is not<br>  a member of the map, the original map is returned. O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.adjust"><code><a class="type" href="Data.Map.html#Data.Map.adjust"><span class="name function">adjust</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">v</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span></code></dt><dd><pre>  Update a value at a specific key with the result of the provided function.<br>  When the key is not a member of the map, the original map is returned. O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.updateWithKey"><code><a class="type" href="Data.Map.html#Data.Map.updateWithKey"><span class="name function">updateWithKey</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">k</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;<span class="boundvar">v</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span></code></dt><dd><pre>  The expression (updateWithKey f k map) updates the<br>  value x at k (if it is in the map). If (f k x) is Nothing,<br>  the element is deleted. If it is (Just y), the key k is bound<br>  to the new value y. O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.update"><code><a class="type" href="Data.Map.html#Data.Map.update"><span class="name function">update</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;<span class="boundvar">v</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span></code></dt><dd><pre>  The expression (update f k map) updates the value x<br>  at k (if it is in the map). If (f x) is Nothing, the element is<br>  deleted. If it is (Just y), the key k is bound to the new value y. O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.updateLookupWithKey"><code><a class="type" href="Data.Map.html#Data.Map.updateLookupWithKey"><span class="name function">updateLookupWithKey</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">k</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;<span class="boundvar">v</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;<span class="boundvar">v</span>,&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>)</code></dt><dd><pre>  Lookup and update. See also updateWithKey.<br>  The function returns changed value, if it is updated.<br>  Returns the original key value if the map entry is deleted. O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.alter"><code><a class="type" href="Data.Map.html#Data.Map.alter"><span class="name function">alter</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;<span class="boundvar">v</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span></code></dt><dd><pre>  The expression (alter f k map) alters the value x at k, or absence thereof.<br>  alter can be used to insert, delete, or update a value in a Map. O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.lookup"><code><a class="type" href="Data.Map.html#Data.Map.lookup"><span class="name function">lookup</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;<span class="boundvar">v</span></code></dt><dd><pre>  Lookup the value at a key in the map.<br>  The function will return the corresponding value as (Just value),<br>  or Nothing if the key isn&apos;t in the map. O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.(!?)"><code><a class="type" href="Data.Map.html#Data.Map.(!?)"><span class="name function">(!?)</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;<span class="boundvar">v</span></code></dt><dd><pre>  Find the value at a key.<br>  Returns Nothing when the element can not be found. O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.member"><code><a class="type" href="Data.Map.html#Data.Map.member"><span class="name function">member</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span></code></dt><dd><pre>  Is the key a member of the map? See also notMember. O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.notMember"><code><a class="type" href="Data.Map.html#Data.Map.notMember"><span class="name function">notMember</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span></code></dt><dd><pre>  Is the key not a member of the map? See also member. O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.find"><code><a class="type" href="Data.Map.html#Data.Map.find"><span class="name function">find</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">v</span></code></dt><dd><pre>  Find the value at a key.<br>  Calls idris_crash when the element can not be found. O(log n)</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.(!!)"><code><a class="type" href="Data.Map.html#Data.Map.(!!)"><span class="name function">(!!)</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">v</span></code></dt><dd><pre>  Find the value at a key.<br>  Calls idris_crash when the element can not be found. O(log n)</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.findWithDefault"><code><a class="type" href="Data.Map.html#Data.Map.findWithDefault"><span class="name function">findWithDefault</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">v</span></code></dt><dd><pre>  The expression (findWithDefault def k map) returns<br>  the value at key k or returns default value def<br>  when the key is not in the map. O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.lookupLT"><code><a class="type" href="Data.Map.html#Data.Map.lookupLT"><span class="name function">lookupLT</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;(<span class="boundvar">k</span>,&ensp;<span class="boundvar">v</span>)</code></dt><dd><pre>  Find largest key smaller than the given one and return the<br>  corresponding (key, value) pair. O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.lookupGT"><code><a class="type" href="Data.Map.html#Data.Map.lookupGT"><span class="name function">lookupGT</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;(<span class="boundvar">k</span>,&ensp;<span class="boundvar">v</span>)</code></dt><dd><pre>  Find smallest key greater than the given one and return the<br>  corresponding (key, value) pair. O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.lookupLE"><code><a class="type" href="Data.Map.html#Data.Map.lookupLE"><span class="name function">lookupLE</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;(<span class="boundvar">k</span>,&ensp;<span class="boundvar">v</span>)</code></dt><dd><pre>  Find largest key smaller or equal to the given one and return<br>  the corresponding (key, value) pair. O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.lookupGE"><code><a class="type" href="Data.Map.html#Data.Map.lookupGE"><span class="name function">lookupGE</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;(<span class="boundvar">k</span>,&ensp;<span class="boundvar">v</span>)</code></dt><dd><pre>  Find smallest key greater or equal to the given one and return<br>  the corresponding (key, value) pair. O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.null"><code><a class="type" href="Data.Map.html#Data.Map.null"><span class="name function">null</span></a>&ensp;:&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span></code></dt><dd><pre>  Is the map empty? O(1)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.splitRoot"><code><a class="type" href="Data.Map.html#Data.Map.splitRoot"><span class="name function">splitRoot</span></a>&ensp;:&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;(<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>)</code></dt><dd><pre>  Decompose a map into pieces based on the structure of the underlying tree.<br>  This function is useful for consuming a map in parallel. O(1)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.splitLookup"><code><a class="type" href="Data.Map.html#Data.Map.splitLookup"><span class="name function">splitLookup</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>,&ensp;(<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;<span class="boundvar">v</span>,&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>))</code></dt><dd><pre>  The expression (splitLookup k map) splits a map just<br>  like split but also returns lookup k map. O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.split"><code><a class="type" href="Data.Map.html#Data.Map.split"><span class="name function">split</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>,&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>)</code></dt><dd><pre>  The expression (split k map) is a pair (map1,map2) where<br>  the keys in map1 are smaller than k and the keys in map2 larger than k.<br>  Any key equal to k is found in neither map1 nor map2. O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.filterWithKey"><code><a class="type" href="Data.Map.html#Data.Map.filterWithKey"><span class="name function">filterWithKey</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Eq"><span class="name type">Eq</span></span>&ensp;(<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>)&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">k</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span></code></dt><dd><pre>  Filter all keys/values that satisfy the predicate. O(n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.filter"><code><a class="type" href="Data.Map.html#Data.Map.filter"><span class="name function">filter</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Eq"><span class="name type">Eq</span></span>&ensp;(<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>)&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span></code></dt><dd><pre>  Filter all values that satisfy the predicate. O(n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.partitionWithKey"><code><a class="type" href="Data.Map.html#Data.Map.partitionWithKey"><span class="name function">partitionWithKey</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Eq"><span class="name type">Eq</span></span>&ensp;(<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>)&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">k</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>,&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>)</code></dt><dd><pre>  Partition the map according to a predicate. The first<br>  map contains all elements that satisfy the predicate, the second all<br>  elements that fail the predicate. See also split. O(n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.takeWhileAntitone"><code><a class="type" href="Data.Map.html#Data.Map.takeWhileAntitone"><span class="name function">takeWhileAntitone</span></a>&ensp;:&ensp;(<span class="boundvar">k</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span></code></dt><dd><pre>  Take while a predicate on the keys holds.<br>  The user is responsible for ensuring that for all keys j and k in the map,<br>  j &lt; k ==&gt; p j &gt;= p k. See note at spanAntitone. O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.dropWhileAntitone"><code><a class="type" href="Data.Map.html#Data.Map.dropWhileAntitone"><span class="name function">dropWhileAntitone</span></a>&ensp;:&ensp;(<span class="boundvar">k</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span></code></dt><dd><pre>  Drop while a predicate on the keys holds.<br>  The user is responsible for ensuring that for all keys j and k in the map,<br>  j &lt; k ==&gt; p j &gt;= p k. See note at spanAntitone. O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.spanAntitone"><code><a class="type" href="Data.Map.html#Data.Map.spanAntitone"><span class="name function">spanAntitone</span></a>&ensp;:&ensp;(<span class="boundvar">k</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>,&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>)</code></dt><dd><pre>  Divide a map at the point where a predicate on the keys stops holding.<br>  The user is responsible for ensuring that for all keys j and k in the map,<br>  j &lt; k ==&gt; p j&gt;= p k. O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.mapMaybeWithKey"><code><a class="type" href="Data.Map.html#Data.Map.mapMaybeWithKey"><span class="name function">mapMaybeWithKey</span></a>&ensp;:&ensp;(<span class="boundvar">k</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;<span class="boundvar">b</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">b</span></code></dt><dd><pre>  Map keys/values and collect the Just results. O(n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.mapMaybe"><code><a class="type" href="Data.Map.html#Data.Map.mapMaybe"><span class="name function">mapMaybe</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;<span class="boundvar">b</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">b</span></code></dt><dd><pre>  Map values and collect the Just results. O(n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.mapEitherWithKey"><code><a class="type" href="Data.Map.html#Data.Map.mapEitherWithKey"><span class="name function">mapEitherWithKey</span></a>&ensp;:&ensp;(<span class="boundvar">k</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Either"><span class="name type">Either</span></span>&ensp;<span class="boundvar">b</span>&ensp;<span class="boundvar">c</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">b</span>,&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">c</span>)</code></dt><dd><pre>  Map keys/values and separate the Left and Right results. O(n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.mapEither"><code><a class="type" href="Data.Map.html#Data.Map.mapEither"><span class="name function">mapEither</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Either"><span class="name type">Either</span></span>&ensp;<span class="boundvar">b</span>&ensp;<span class="boundvar">c</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">b</span>,&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">c</span>)</code></dt><dd><pre>  Map values and separate the Left and Right results. O(n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.isSubmapOfBy"><code><a class="type" href="Data.Map.html#Data.Map.isSubmapOfBy"><span class="name function">isSubmapOfBy</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span></code></dt><dd><pre>  The expression (isSubmapOfBy f t1 t2) returns True if<br>  all keys in t1 are in tree t2, and when f returns True when<br>  applied to their respective values.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.isSubmapOf"><code><a class="type" href="Data.Map.html#Data.Map.isSubmapOf"><span class="name function">isSubmapOf</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Eq"><span class="name type">Eq</span></span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span></code></dt><dd><pre>  This function is defined as (isSubmapOf = isSubmapOfBy (==)).</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.isProperSubmapOfBy"><code><a class="type" href="Data.Map.html#Data.Map.isProperSubmapOfBy"><span class="name function">isProperSubmapOfBy</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span></code></dt><dd><pre>  Is this a proper submap? (ie. a submap but not equal).<br>  The expression (isProperSubmapOfBy f m1 m2) returns True when<br>  keys m1 and keys m2 are not equal,<br>  all keys in m1 are in m2, and when f returns True when<br>  applied to their respective values.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.isProperSubmapOf"><code><a class="type" href="Data.Map.html#Data.Map.isProperSubmapOf"><span class="name function">isProperSubmapOf</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Eq"><span class="name type">Eq</span></span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span></code></dt><dd><pre>  Is this a proper submap? (ie. a submap but not equal).<br>  Defined as (isProperSubmapOf = isProperSubmapOfBy (==)).</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.lookupIndex"><code><a class="type" href="Data.Map.html#Data.Map.lookupIndex"><span class="name function">lookupIndex</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span></code></dt><dd><pre>  Lookup the index of a key, which is its zero-based index in<br>  the sequence sorted by keys. The index is a number from 0 up to, but not<br>  including, the size of the map. O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.findIndex"><code><a class="type" href="Data.Map.html#Data.Map.findIndex"><span class="name function">findIndex</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span></code></dt><dd><pre>  Return the index of a key, which is its zero-based index in<br>  the sequence sorted by keys. The index is a number from 0 up to, but not<br>  including, the size of the map. Calls idris_crash when the key is not<br>  a member of the map. O(log n)</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.elemAt"><code><a class="type" href="Data.Map.html#Data.Map.elemAt"><span class="name function">elemAt</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">k</span>,&ensp;<span class="boundvar">v</span>)</code></dt><dd><pre>  Retrieve an element by its index, i.e. by its zero-based<br>  index in the sequence sorted by keys. If the index is out of range (less<br>  than zero, greater or equal to size of the map), idris_crash is called. O(log n)</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.updateAt"><code><a class="type" href="Data.Map.html#Data.Map.updateAt"><span class="name function">updateAt</span></a>&ensp;:&ensp;(<span class="boundvar">k</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;<span class="boundvar">v</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span></code></dt><dd><pre>  Update the element at index, i.e. by its zero-based index in<br>  the sequence sorted by keys. If the index is out of range (less than zero,<br>  greater or equal to size of the map), idris_crash is called. O(log n)</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.deleteAt"><code><a class="type" href="Data.Map.html#Data.Map.deleteAt"><span class="name function">deleteAt</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span></code></dt><dd><pre>  Delete the element at index, i.e. by its zero-based index in<br>  the sequence sorted by keys. If the index is out of range (less than zero,<br>  greater or equal to size of the map), idris_crash is called. O(log n)</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.take"><code><a class="type" href="Data.Map.html#Data.Map.take"><span class="name function">take</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span></code></dt><dd><pre>  Take a given number of entries in key order, beginning<br>  with the smallest keys. O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.drop"><code><a class="type" href="Data.Map.html#Data.Map.drop"><span class="name function">drop</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span></code></dt><dd><pre>  Drop a given number of entries in key order, beginning<br>  with the smallest keys. O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.splitAt"><code><a class="type" href="Data.Map.html#Data.Map.splitAt"><span class="name function">splitAt</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>,&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>)</code></dt><dd><pre>  Split a map at a particular index. O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.lookupMin"><code><a class="type" href="Data.Map.html#Data.Map.lookupMin"><span class="name function">lookupMin</span></a>&ensp;:&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;(<span class="boundvar">k</span>,&ensp;<span class="boundvar">v</span>)</code></dt><dd><pre>  The minimal key of the map. Returns Nothing if the map is empty. O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.lookupMax"><code><a class="type" href="Data.Map.html#Data.Map.lookupMax"><span class="name function">lookupMax</span></a>&ensp;:&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;(<span class="boundvar">k</span>,&ensp;<span class="boundvar">v</span>)</code></dt><dd><pre>  The maximal key of the map. Returns Nothing if the map is empty. O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.findMin"><code><a class="type" href="Data.Map.html#Data.Map.findMin"><span class="name function">findMin</span></a>&ensp;:&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">k</span>,&ensp;<span class="boundvar">v</span>)</code></dt><dd><pre>  The minimal key of the map. Calls idris_crash if the map is empty. O(log n)</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.findMax"><code><a class="type" href="Data.Map.html#Data.Map.findMax"><span class="name function">findMax</span></a>&ensp;:&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">k</span>,&ensp;<span class="boundvar">v</span>)</code></dt><dd><pre>  The maximal key of the map. Calls idris_crash if the map is empty. O(log n)</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.deleteMin"><code><a class="type" href="Data.Map.html#Data.Map.deleteMin"><span class="name function">deleteMin</span></a>&ensp;:&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span></code></dt><dd><pre>  Delete the minimal key. Returns an empty map if the map is empty. O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.deleteMax"><code><a class="type" href="Data.Map.html#Data.Map.deleteMax"><span class="name function">deleteMax</span></a>&ensp;:&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span></code></dt><dd><pre>  Delete the maximal key. Returns an empty map if the map is empty. O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.minViewWithKey"><code><a class="type" href="Data.Map.html#Data.Map.minViewWithKey"><span class="name function">minViewWithKey</span></a>&ensp;:&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;((<span class="boundvar">k</span>,&ensp;<span class="boundvar">v</span>),&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>)</code></dt><dd><pre>  Retrieves the minimal (key,value) pair of the map, and<br>  the map stripped of that element, or Nothing if passed an empty map. O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.deleteFindMin"><code><a class="type" href="Data.Map.html#Data.Map.deleteFindMin"><span class="name function">deleteFindMin</span></a>&ensp;:&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;((<span class="boundvar">k</span>,&ensp;<span class="boundvar">v</span>),&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>)</code></dt><dd><pre>  Delete and find the minimal element. O(log n)</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.maxViewWithKey"><code><a class="type" href="Data.Map.html#Data.Map.maxViewWithKey"><span class="name function">maxViewWithKey</span></a>&ensp;:&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;((<span class="boundvar">k</span>,&ensp;<span class="boundvar">v</span>),&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>)</code></dt><dd><pre>  Retrieves the maximal (key,value) pair of the map, and<br>  the map stripped of that element, or Nothing if passed an empty map. O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.deleteFindMax"><code><a class="type" href="Data.Map.html#Data.Map.deleteFindMax"><span class="name function">deleteFindMax</span></a>&ensp;:&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;((<span class="boundvar">k</span>,&ensp;<span class="boundvar">v</span>),&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>)</code></dt><dd><pre>  Delete and find the maximal element. O(log n)</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.updateMinWithKey"><code><a class="type" href="Data.Map.html#Data.Map.updateMinWithKey"><span class="name function">updateMinWithKey</span></a>&ensp;:&ensp;(<span class="boundvar">k</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;<span class="boundvar">v</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span></code></dt><dd><pre>  Update the value at the minimal key. O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.updateMin"><code><a class="type" href="Data.Map.html#Data.Map.updateMin"><span class="name function">updateMin</span></a>&ensp;:&ensp;(<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;<span class="boundvar">v</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span></code></dt><dd><pre>  Update the value at the minimal key. O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.updateMaxWithKey"><code><a class="type" href="Data.Map.html#Data.Map.updateMaxWithKey"><span class="name function">updateMaxWithKey</span></a>&ensp;:&ensp;(<span class="boundvar">k</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;<span class="boundvar">v</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span></code></dt><dd><pre>  Update the value at the maximal key. O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.updateMax"><code><a class="type" href="Data.Map.html#Data.Map.updateMax"><span class="name function">updateMax</span></a>&ensp;:&ensp;(<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;<span class="boundvar">v</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span></code></dt><dd><pre>  Update the value at the maximal key. O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.minView"><code><a class="type" href="Data.Map.html#Data.Map.minView"><span class="name function">minView</span></a>&ensp;:&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;(<span class="boundvar">v</span>,&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>)</code></dt><dd><pre>  Retrieves the value associated with minimal key of the<br>  map, and the map stripped of that element, or Nothing if passed an empty map. O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.maxView"><code><a class="type" href="Data.Map.html#Data.Map.maxView"><span class="name function">maxView</span></a>&ensp;:&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;(<span class="boundvar">v</span>,&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>)</code></dt><dd><pre>  Retrieves the value associated with maximal key of the<br>  map, and the map stripped of that element, or Nothing if passed an empty map. O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.union"><code><a class="type" href="Data.Map.html#Data.Map.union"><span class="name function">union</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Eq"><span class="name type">Eq</span></span>&ensp;(<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>)&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.EqOrd.Eq"><span class="name type">Eq</span></span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span></code></dt><dd><pre>  The expression (union t1 t2) takes the left-biased union of t1 and t2.<br>  It prefers t1 when duplicate keys are encountered.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.unionWith"><code><a class="type" href="Data.Map.html#Data.Map.unionWith"><span class="name function">unionWith</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">v</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span></code></dt><dd><pre>  Union with a combining function.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.unionWithKey"><code><a class="type" href="Data.Map.html#Data.Map.unionWithKey"><span class="name function">unionWithKey</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">k</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">v</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span></code></dt><dd><pre>  Union with a combining function.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.unions"><code><a class="type" href="Data.Map.html#Data.Map.unions"><span class="name function">unions</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Eq"><span class="name type">Eq</span></span>&ensp;(<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>)&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.EqOrd.Eq"><span class="name type">Eq</span></span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.Interfaces.Foldable"><span class="name type">Foldable</span></span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;(<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span></code></dt><dd><pre>  The union of a list of maps.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.unionsWith"><code><a class="type" href="Data.Map.html#Data.Map.unionsWith"><span class="name function">unionsWith</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Interfaces.Foldable"><span class="name type">Foldable</span></span>&ensp;<span class="boundvar">f</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">v</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">f</span>&ensp;(<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span></code></dt><dd><pre>  The union of a list of maps, with a combining operation.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.difference"><code><a class="type" href="Data.Map.html#Data.Map.difference"><span class="name function">difference</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Difference of two maps.<br>  Return elements of the first map not existing in the second map.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.(\\)"><code><a class="type" href="Data.Map.html#Data.Map.(\\)"><span class="name function">(\\)</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Same as difference.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infix&ensp;operator,&ensp;level&ensp;7</dd><dt id="Data.Map.intersection"><code><a class="type" href="Data.Map.html#Data.Map.intersection"><span class="name function">intersection</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Eq"><span class="name type">Eq</span></span>&ensp;(<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Intersection of two maps.<br>  Return data in the first map for the keys existing in both maps.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.intersectionWith"><code><a class="type" href="Data.Map.html#Data.Map.intersectionWith"><span class="name function">intersectionWith</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">c</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">c</span></code></dt><dd><pre>  Intersection with a combining function.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.intersectionWithKey"><code><a class="type" href="Data.Map.html#Data.Map.intersectionWithKey"><span class="name function">intersectionWithKey</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">k</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">c</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">c</span></code></dt><dd><pre>  Intersection with a combining function.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.disjoint"><code><a class="type" href="Data.Map.html#Data.Map.disjoint"><span class="name function">disjoint</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span></code></dt><dd><pre>  Check whether the key sets of two<br>  maps are disjoint (i.e., their intersection is empty).</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.compose"><code><a class="type" href="Data.Map.html#Data.Map.compose"><span class="name function">compose</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">b</span>&ensp;<span class="boundvar">c</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">c</span></code></dt><dd><pre>  Relate the keys of one map to the values of<br>  the other, by using the values of the former as keys for lookups in the latter.<br>  O(n * log(m)), where m is the size of the first argument.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.map"><code><a class="type" href="Data.Map.html#Data.Map.map"><span class="name function">map</span></a>&ensp;:&ensp;(<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">w</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">w</span></code></dt><dd><pre>  Map a function over all values in the map. O(n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.mapWithKey"><code><a class="type" href="Data.Map.html#Data.Map.mapWithKey"><span class="name function">mapWithKey</span></a>&ensp;:&ensp;(<span class="boundvar">k</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">w</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">w</span></code></dt><dd><pre>  Map a function over all values in the map. O(n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.mapAccumL"><code><a class="type" href="Data.Map.html#Data.Map.mapAccumL"><span class="name function">mapAccumL</span></a>&ensp;:&ensp;(<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">w</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">v</span>,&ensp;<span class="boundvar">c</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">w</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">v</span>,&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">c</span>)</code></dt><dd><pre>  The function mapAccumL threads an accumulating<br>  argument through the map in ascending order of keys. O(n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.mapAccumRWithKey"><code><a class="type" href="Data.Map.html#Data.Map.mapAccumRWithKey"><span class="name function">mapAccumRWithKey</span></a>&ensp;:&ensp;(<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">w</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">v</span>,&ensp;<span class="boundvar">c</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">w</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">v</span>,&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">c</span>)</code></dt><dd><pre>  The function mapAccumRWithKey threads an accumulating<br>  argument through the map in descending order of keys. O(n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.mapAccumWithKey"><code><a class="type" href="Data.Map.html#Data.Map.mapAccumWithKey"><span class="name function">mapAccumWithKey</span></a>&ensp;:&ensp;(<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">w</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">v</span>,&ensp;<span class="boundvar">c</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">w</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">v</span>,&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">c</span>)</code></dt><dd><pre>  The function mapAccumWithKey threads an accumulating<br>  argument through the map in ascending order of keys. O(n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.mapAccum"><code><a class="type" href="Data.Map.html#Data.Map.mapAccum"><span class="name function">mapAccum</span></a>&ensp;:&ensp;(<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">w</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">v</span>,&ensp;<span class="boundvar">c</span>))&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">w</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">v</span>,&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">c</span>)</code></dt><dd><pre>  The function mapAccum threads an accumulating<br>  argument through the map in ascending order of keys. O(n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.toDescList"><code><a class="type" href="Data.Map.html#Data.Map.toDescList"><span class="name function">toDescList</span></a>&ensp;:&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;(<span class="boundvar">k</span>,&ensp;<span class="boundvar">v</span>)</code></dt><dd><pre>  Convert the map to a list of key/value pairs where the keys are in descending order. O(n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.toAscList"><code><a class="type" href="Data.Map.html#Data.Map.toAscList"><span class="name function">toAscList</span></a>&ensp;:&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;(<span class="boundvar">k</span>,&ensp;<span class="boundvar">v</span>)</code></dt><dd><pre>  Convert the map to a list of key/value pairs where the keys are in ascending order. O(n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.toList"><code><a class="type" href="Data.Map.html#Data.Map.toList"><span class="name function">toList</span></a>&ensp;:&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;(<span class="boundvar">k</span>,&ensp;<span class="boundvar">v</span>)</code></dt><dd><pre>  Convert the map to a list of key/value pairs.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.fromList"><code><a class="type" href="Data.Map.html#Data.Map.fromList"><span class="name function">fromList</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;(<span class="boundvar">k</span>,&ensp;<span class="boundvar">v</span>)&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">k</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;(<span class="boundvar">k</span>,&ensp;<span class="boundvar">v</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span></code></dt><dd><pre>  Build a map from a list of key/value pairs.<br>  If the list contains more than one value for the same key, the last value<br>  for the key is retained.<br>  If the keys of the list are ordered, a linear-time implementation is used. O(n * log(n))</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.keys"><code><a class="type" href="Data.Map.html#Data.Map.keys"><span class="name function">keys</span></a>&ensp;:&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">k</span></code></dt><dd><pre>  Gets the keys of the map.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Map.values"><code><a class="type" href="Data.Map.html#Data.Map.values"><span class="name function">values</span></a>&ensp;:&ensp;<a class="type" href="Data.Map.Internal.html#Data.Map.Internal.Map"><span class="name type">Map</span></a>&ensp;<span class="boundvar">k</span>&ensp;<span class="boundvar">v</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">v</span></code></dt><dd><pre>  Gets the values of the map.<br>  Could contain duplicates.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd></dl></div><footer>Produced by Idris 2 version 0.7.0-da352d8ed</footer></body></html>
