<!DOCTYPE html><html lang="en">

<head>
  <meta charset="utf-8">
  <title>Data.Set</title>
  <link rel="stylesheet" type="text/css" id="preferredStyle" href="../default.css">
  <script>
    /* Updates the stylesheet to use the preferred one.
       Note that we set the link to root ++ sourceLoc because the config
       is shared across the whole website, so the root may differ from
       page to page.
    */
    function setStyleSource (sourceLoc) {
      document.getElementById("preferredStyle").href = "../" + sourceLoc + ".css";
      document.getElementById("selectPreferredStyle").value = sourceLoc;
    }
    /* Initialises the preferred style sheet:
       1. if there is a stored value then use that
          otherwise select the default
       2. set both the css link href & the drop down menu selected option
    */
    function initStyleSource () {
      var preferredStyle = localStorage.getItem("stylefile");
      if (preferredStyle !== null) {
        setStyleSource(preferredStyle);
      } else {
        setStyleSource("default");
      };
    }
    function saveStyleSource (preferredStyle) {
      localStorage.stylefile = preferredStyle;
    }
    </script>
</head>

<body class="namespace">
<header>
  <strong>Idris2Doc</strong> : Data.Set
  <nav><a href="../index.html">Index</a>

  <select id="selectPreferredStyle">
    <option value="default">Default</option>
<option value="alternative">Alternative</option>
<option value="blackandwhite">Black & White</option>

  </select>
  </nav>

  <script>
  /* We start by initialising the style source */
  initStyleSource();

  /* This listens for changes on the drop down menu and updates the
     css used for the current page when a selection is made.
  */
  document.getElementById("selectPreferredStyle").addEventListener("change", function(){
    var selected = this.options[this.selectedIndex].value; /* the option chosen */
    setStyleSource (selected);
    saveStyleSource (selected);
  });
</script>

</header>
<div class="container"><div id="module-header"><h1>Data.Set</h1><span style="float:right">(<a href="Data.Set.src.html">source</a>)</span><pre>Finite Sets
</pre></div><h2>Reexports</h2><code><span class="keyword">import</span>&ensp;<span class="keyword">public</span>&ensp;Data.Set.Internal</code><h2>Definitions</h2><dl class="decls"><dt id="Data.Set.empty"><code><a class="type" href="Data.Set.html#Data.Set.empty"><span class="name function">empty</span></a>&ensp;:&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  The empty set. O(1)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Set.foldl"><code><a class="type" href="Data.Set.html#Data.Set.foldl"><span class="name function">foldl</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Fold the values in the set using the given left-associative binary operator. O(n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Set.foldr"><code><a class="type" href="Data.Set.html#Data.Set.foldr"><span class="name function">foldr</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">b</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">b</span></code></dt><dd><pre>  Fold the values in the set using the given right-associative binary operator. O(n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Set.insert"><code><a class="type" href="Data.Set.html#Data.Set.insert"><span class="name function">insert</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Eq"><span class="name type">Eq</span></span>&ensp;(<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.EqOrd.Eq"><span class="name type">Eq</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Insert an element in a set.<br>  If the set already contains an element equal to the given value,<br>  it is replaced with the new value. O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Set.delete"><code><a class="type" href="Data.Set.html#Data.Set.delete"><span class="name function">delete</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Eq"><span class="name type">Eq</span></span>&ensp;(<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.EqOrd.Eq"><span class="name type">Eq</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Delete an element from a set. When the element is not<br>  a member of the set, the original set is returned. O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Set.member"><code><a class="type" href="Data.Set.html#Data.Set.member"><span class="name function">member</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span></code></dt><dd><pre>  Is the element in the set? O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Set.notMember"><code><a class="type" href="Data.Set.html#Data.Set.notMember"><span class="name function">notMember</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span></code></dt><dd><pre>  Is the element not in the set? O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Set.lookupLT"><code><a class="type" href="Data.Set.html#Data.Set.lookupLT"><span class="name function">lookupLT</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Find largest element smaller than the given one. O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Set.lookupGT"><code><a class="type" href="Data.Set.html#Data.Set.lookupGT"><span class="name function">lookupGT</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Find smallest element greater than the given one. O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Set.lookupLE"><code><a class="type" href="Data.Set.html#Data.Set.lookupLE"><span class="name function">lookupLE</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Find the largest element smaller or equal to the given one. O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Set.lookupGE"><code><a class="type" href="Data.Set.html#Data.Set.lookupGE"><span class="name function">lookupGE</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Find the smallest element greater or equal to the given one. O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Set.null"><code><a class="type" href="Data.Set.html#Data.Set.null"><span class="name function">null</span></a>&ensp;:&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span></code></dt><dd><pre>  Is the set empty? O(1)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Set.splitMember"><code><a class="type" href="Data.Set.html#Data.Set.splitMember"><span class="name function">splitMember</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>,&ensp;(<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span>,&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>))</code></dt><dd><pre>  Performs a split but also returns whether<br>  the pivot element was found in the original set. O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Set.splitRoot"><code><a class="type" href="Data.Set.html#Data.Set.splitRoot"><span class="name function">splitRoot</span></a>&ensp;:&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;(<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>)</code></dt><dd><pre>  Decompose a set into pieces based on the structure of the underlying tree.<br>  This function is useful for consuming a set in parallel. O(1)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Set.split"><code><a class="type" href="Data.Set.html#Data.Set.split"><span class="name function">split</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>,&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>)</code></dt><dd><pre>  The expression (split x set) is a pair (set1,set2) where<br>  set1 comprises the elements of set less than x and<br>  set2 comprises the elements of set greater than x. O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Set.isSubsetOf"><code><a class="type" href="Data.Set.html#Data.Set.isSubsetOf"><span class="name function">isSubsetOf</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span></code></dt><dd><pre>  Indicates whether s1 is a subset of s2.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Set.isProperSubsetOf"><code><a class="type" href="Data.Set.html#Data.Set.isProperSubsetOf"><span class="name function">isProperSubsetOf</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span></code></dt><dd><pre>  Indicates whether s1 is a proper subset of s2.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Set.disjoint"><code><a class="type" href="Data.Set.html#Data.Set.disjoint"><span class="name function">disjoint</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span></code></dt><dd><pre>  Check whether two sets are disjoint (i.e. their intersection is empty).</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Set.filter"><code><a class="type" href="Data.Set.html#Data.Set.filter"><span class="name function">filter</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Eq"><span class="name type">Eq</span></span>&ensp;(<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">=&gt;</span>&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Filter all elements that satisfy the predicate. O(n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Set.takeWhileAntitone"><code><a class="type" href="Data.Set.html#Data.Set.takeWhileAntitone"><span class="name function">takeWhileAntitone</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Take while a predicate on the keys holds.<br>  The user is responsible for ensuring that for all elements j and k in the set,<br>  j &lt; k ==&gt; p j &gt;= p k. See note at spanAntitone. O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Set.dropWhileAntitone"><code><a class="type" href="Data.Set.html#Data.Set.dropWhileAntitone"><span class="name function">dropWhileAntitone</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Drop while a predicate on the keys holds.<br>  The user is responsible for ensuring that for all elements j and k in the map,<br>  j &lt; k ==&gt; p j &gt;= p k. See note at spanAntitone. O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Set.spanAntitone"><code><a class="type" href="Data.Set.html#Data.Set.spanAntitone"><span class="name function">spanAntitone</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.Bool"><span class="name type">Bool</span></span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>,&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>)</code></dt><dd><pre>  Divide a map at the point where a predicate on the keys stops holding.<br>  The user is responsible for ensuring that for all keys j and k in the map,<br>  j &lt; k ==&gt; p j&gt;= p k. O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Set.lookupIndex"><code><a class="type" href="Data.Set.html#Data.Set.lookupIndex"><span class="name function">lookupIndex</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span></code></dt><dd><pre>  Lookup the index of a element, which is its zero-based index in<br>  the sorted sequence of elements. The index is a number from 0 up to, but not<br>  including, the size of the set. O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Set.findIndex"><code><a class="type" href="Data.Set.html#Data.Set.findIndex"><span class="name function">findIndex</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span></code></dt><dd><pre>  Return the index of an element, which is its zero-based index in<br>  the sorted sequence of elements. The index is a number from 0 up to, but not<br>  including, the size of the set. Calls idris_crash when the element is not<br>  a member of the set. O(log n)</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Set.elemAt"><code><a class="type" href="Data.Set.html#Data.Set.elemAt"><span class="name function">elemAt</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Retrieve an element by its index, i.e. by its zero-based<br>  index in the sorted sequence of elements. If the index is out of range (less<br>  than zero, greater or equal to size of the set), idris_crash is called. O(log n)</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Set.deleteAt"><code><a class="type" href="Data.Set.html#Data.Set.deleteAt"><span class="name function">deleteAt</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Delete the element at index, i.e. by its zero-based index in<br>  the sorted sequence of elements. If the index is out of range (less than zero,<br>  greater or equal to size of the set), idris_crash is called. O(log n)</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Set.take"><code><a class="type" href="Data.Set.html#Data.Set.take"><span class="name function">take</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Take a given number of elements in order, beginning<br>  with the smallest keys. O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Set.drop"><code><a class="type" href="Data.Set.html#Data.Set.drop"><span class="name function">drop</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Drop a given number of elements in order, beginning<br>  with the smallest ones. O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Set.splitAt"><code><a class="type" href="Data.Set.html#Data.Set.splitAt"><span class="name function">splitAt</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.Types.Nat"><span class="name type">Nat</span></span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>,&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>)</code></dt><dd><pre>  Split a set at a particular index. O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Set.lookupMin"><code><a class="type" href="Data.Set.html#Data.Set.lookupMin"><span class="name function">lookupMin</span></a>&ensp;:&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  The minimal element of the set. Returns Nothing if the set is empty. O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Set.lookupMax"><code><a class="type" href="Data.Set.html#Data.Set.lookupMax"><span class="name function">lookupMax</span></a>&ensp;:&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  The maximal element of the set. Returns Nothing if the set is empty. O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Set.findMin"><code><a class="type" href="Data.Set.html#Data.Set.findMin"><span class="name function">findMin</span></a>&ensp;:&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  The minimal element of the set. Calls idris_crash if the set is empty. O(log n)</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Set.findMax"><code><a class="type" href="Data.Set.html#Data.Set.findMax"><span class="name function">findMax</span></a>&ensp;:&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  The maximal element of the set. Calls idris_crash if the set is empty. O(log n)</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Set.deleteMin"><code><a class="type" href="Data.Set.html#Data.Set.deleteMin"><span class="name function">deleteMin</span></a>&ensp;:&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Delete the minimal element. Returns an empty set if the set is empty. O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Set.deleteMax"><code><a class="type" href="Data.Set.html#Data.Set.deleteMax"><span class="name function">deleteMax</span></a>&ensp;:&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Delete the maximal element. Returns an empty set if the set is empty. O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Set.minView"><code><a class="type" href="Data.Set.html#Data.Set.minView"><span class="name function">minView</span></a>&ensp;:&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;(<span class="boundvar">a</span>,&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>)</code></dt><dd><pre>  Retrieves the minimal element of the set, and<br>  the set stripped of that element, or Nothing if passed an empty set. O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Set.deleteFindMin"><code><a class="type" href="Data.Set.html#Data.Set.deleteFindMin"><span class="name function">deleteFindMin</span></a>&ensp;:&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">a</span>,&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>)</code></dt><dd><pre>  Delete and find the minimal element. O(log n)</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Set.maxView"><code><a class="type" href="Data.Set.html#Data.Set.maxView"><span class="name function">maxView</span></a>&ensp;:&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Types.Maybe"><span class="name type">Maybe</span></span>&ensp;(<span class="boundvar">a</span>,&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>)</code></dt><dd><pre>  Retrieves the maximal element of the set, and<br>  the set stripped of that element, or Nothing if passed an empty set. O(log n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Set.deleteFindMax"><code><a class="type" href="Data.Set.html#Data.Set.deleteFindMax"><span class="name function">deleteFindMax</span></a>&ensp;:&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;(<span class="boundvar">a</span>,&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>)</code></dt><dd><pre>  Delete and find the maximal element. O(log n)</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Set.union"><code><a class="type" href="Data.Set.html#Data.Set.union"><span class="name function">union</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Eq"><span class="name type">Eq</span></span>&ensp;(<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.EqOrd.Eq"><span class="name type">Eq</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  The expression (union t1 t2) takes the left-biased union of t1 and t2.<br>  It prefers t1 when duplicate keys are encountered.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Set.difference"><code><a class="type" href="Data.Set.html#Data.Set.difference"><span class="name function">difference</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Difference of two sets.<br>  Return elements of the first set not existing in the second set.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Set.(\\)"><code><a class="type" href="Data.Set.html#Data.Set.(\\)"><span class="name function">(\\)</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Same as difference.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span><br>  <b>Fixity Declaration</b>:&ensp;infix&ensp;operator,&ensp;level&ensp;7</dd><dt id="Data.Set.intersection"><code><a class="type" href="Data.Set.html#Data.Set.intersection"><span class="name function">intersection</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Eq"><span class="name type">Eq</span></span>&ensp;(<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>)&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Intersection of two sets.<br>  Return data in the first set for elements existing in both sets.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Set.toDescList"><code><a class="type" href="Data.Set.html#Data.Set.toDescList"><span class="name function">toDescList</span></a>&ensp;:&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Convert the set to a list of elements where the elements are in descending order. O(n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Set.toAscList"><code><a class="type" href="Data.Set.html#Data.Set.toAscList"><span class="name function">toAscList</span></a>&ensp;:&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Convert the set to a list of elements where the elements are in ascending order. O(n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Set.toList"><code><a class="type" href="Data.Set.html#Data.Set.toList"><span class="name function">toList</span></a>&ensp;:&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Convert the set to a list of elements.</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Set.fromList"><code><a class="type" href="Data.Set.html#Data.Set.fromList"><span class="name function">fromList</span></a>&ensp;:&ensp;<span class="type resolved" title="Prelude.EqOrd.Ord"><span class="name type">Ord</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">=&gt;</span>&ensp;<span class="type resolved" title="Prelude.Basics.List"><span class="name type">List</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span></code></dt><dd><pre>  Build a set from a list of elements.<br>  If the list contains identical element(s),<br>  the last of each identical elemen is retained.<br>  If the elements of the list are ordered, a linear-time implementation is used. O(n * log(n))</pre><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Set.map"><code><a class="type" href="Data.Set.html#Data.Set.map"><span class="name function">map</span></a>&ensp;:&ensp;(<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<span class="boundvar">b</span>)&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">b</span></code></dt><dd><pre>  Map a function over all elements in the set. O(n)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd><dt id="Data.Set.disjointUnion"><code><a class="type" href="Data.Set.html#Data.Set.disjointUnion"><span class="name function">disjointUnion</span></a>&ensp;:&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">a</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;<span class="boundvar">b</span>&ensp;<span class="keyword">-&gt;</span>&ensp;<a class="type" href="Data.Set.Internal.html#Data.Set.Internal.Set"><span class="name type">Set</span></a>&ensp;(<span class="type resolved" title="Prelude.Types.Either"><span class="name type">Either</span></span>&ensp;<span class="boundvar">a</span>&ensp;<span class="boundvar">b</span>)</code></dt><dd><pre>  Calculate the disjoint union of two sets. O(n + m)</pre><br>  <b>Totality</b>:&ensp;<span class="keyword">total</span><br>  <b>Visibility</b>:&ensp;<span class="keyword">export</span></dd></dl></div><footer>Produced by Idris 2 version 0.7.0-da352d8ed</footer></body></html>
